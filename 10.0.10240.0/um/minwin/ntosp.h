/*++ BUILD Version: 0306    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntosp.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to external projects like Windows and Termsrv

Revision History:

--*/
#ifndef _NTOSP_
#define _NTOSP_

#ifdef _NTDDK_
#error "Can't include ntddk.h and ntosp.h"
#else
#define _NTDDK_
#endif

// Required to identify drivers that include ntosp
#define _NTOSP_INCLUDED

#define NT_PROCESSOR_GROUPS 1

#include <nt.h>
__internal_kernel_driver
#include <ntrtl.h>
#include <excpt.h>
#include <ntdef.h>
#include <bugcodes.h>
#include <arc.h>
#include <rtlrbtree.h>

#if defined(_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) /* structured padded due to __declspec(align) */
#pragma warning(disable:4365) /* unsigned/signed mismatch */
#pragma warning(disable:4668) /* #if not_defined treated as #if 0 */
#pragma warning(disable:4820) /* padding added after data member */
#endif
#pragma warning(disable:4001) /* nonstandard extension : single line comment */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other then int */
#ifndef __cplusplus
#pragma warning(disable:4115) /* named type definition in parentheses */
#endif
#endif // defined(_MSC_VER)

#ifdef __cplusplus
extern "C" {   // extern "C"
#endif
//
// Define types that are not exported.
//

typedef struct _ACCESS_STATE *PACCESS_STATE;
typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _EJOB *PEJOB;
typedef struct _ESILO *PESILO;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ERESOURCE *PERESOURCE;
typedef struct _ETHREAD *PETHREAD;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _IRP *PIRP;
typedef struct _KPROCESS *PKPROCESS, *RESTRICTED_POINTER PRKPROCESS;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _KTRAP_FRAME *PKTRAP_FRAME;
typedef struct _LOADER_PARAMETER_BLOCK *PLOADER_PARAMETER_BLOCK;
typedef struct _TRANSLATOR_INTERFACE *PTRANSLATOR_INTERFACE;
typedef struct _HANDLE_TABLE *PHANDLE_TABLE;
typedef struct _OBJECT_HANDLE_INFORMATION *POBJECT_HANDLE_INFORMATION;
typedef struct _KGDTENTRY *PKGDTENTRY;
typedef struct _AUX_ACCESS_DATA *PAUX_ACCESS_DATA;
typedef struct _SYSTEM_ROOT_SILO_INFORMATION *PSYSTEM_ROOT_SILO_INFORMATION;

//
// Define macros to fix up structure references
//

#define PEProcessToPKProcess(P) ((PKPROCESS)P)

#if defined(_M_AMD64)

#ifdef __cplusplus
extern "C" {
#endif

ULONG64
__readgsqword (
    _In_ ULONG Offset
    );

#pragma intrinsic(__readgsqword)

__forceinline
PKTHREAD
KeGetCurrentThread (
    VOID
    )

{
    return (struct _KTHREAD *)__readgsqword(0x188);
}

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64)

#if defined(_M_IX86) || defined(_M_ARM) || defined(_M_ARM64)
NTSYSAPI
PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );
#endif // defined(_M_IX86) || defined(_M_ARM) || defined(_M_ARM64)


#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_WIN64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   // structure padded due to align()

typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
    struct _SLIST_ENTRY *Next;
} SLIST_ENTRY, *PSLIST_ENTRY;

#pragma warning(pop)

#else

typedef struct _SINGLE_LIST_ENTRY SLIST_ENTRY, *PSLIST_ENTRY;

#endif // _WIN64

#if defined(_AMD64_)

typedef union DECLSPEC_ALIGN(16) _SLIST_HEADER {
    struct {  // original struct
        ULONGLONG Alignment;
        ULONGLONG Region;
    } DUMMYSTRUCTNAME;
    struct {  // x64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG Reserved:4;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;

#elif defined(_ARM64_)

// ARM64_WORKITEM: should this be merged with AMD64 above?
typedef union DECLSPEC_ALIGN(16) _SLIST_HEADER {
    struct {  // original struct
        ULONGLONG Alignment;
        ULONGLONG Region;
    } DUMMYSTRUCTNAME;
    struct {  // ARM64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG Reserved:4;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } HeaderArm64;
} SLIST_HEADER, *PSLIST_HEADER;

#elif defined(_X86_)

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT CpuId;
    } DUMMYSTRUCTNAME;
} SLIST_HEADER, *PSLIST_HEADER;

#elif defined(_ARM_)

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT Reserved;
    } DUMMYSTRUCTNAME;
} SLIST_HEADER, *PSLIST_HEADER;

#endif

#endif // _SLIST_HEADER_


#ifndef _RTL_ELEVATION_FLAGS_QUERY
#define _RTL_ELEVATION_FLAGS_QUERY

typedef union _RTL_ELEVATION_FLAGS {
    ULONG Flags;
    struct {
        ULONG ElevationEnabled          : 1;
        ULONG VirtualizationEnabled     : 1;
        ULONG InstallerDetectEnabled    : 1;
        ULONG ReservedBits              : 29;
    } DUMMYSTRUCTNAME;
} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;

#endif // _RTL_ELEVATION_FLAGS_QUERY

_IRQL_requires_max_(APC_LEVEL)
_Must_inspect_result_
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryElevationFlags (
    _Out_ PRTL_ELEVATION_FLAGS Flags
    );


#if (NTDDI_VERSION >= NTDDI_WINBLUE)

__drv_maxIRQL(PASSIVE_LEVEL)
NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUIDEx(
    __in REFGUID Guid,
    __inout PUNICODE_STRING GuidString,
    __in BOOLEAN Allocate
    );

#endif // (NTDDI_VERSION >= NTDDI_WINBLUE)


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryPackageIdentity (
    _In_ PVOID TokenObject,
    _Out_writes_bytes_to_(*PackageSize, *PackageSize) PWSTR PackageFullName,
    _Inout_ PSIZE_T PackageSize,
    _Out_writes_bytes_to_opt_(*AppIdSize, *AppIdSize) PWSTR AppId,
    _Inout_opt_ PSIZE_T AppIdSize,
    _Out_opt_ PBOOLEAN Packaged
    );

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryPackageIdentityEx (
    _In_ PVOID TokenObject,
    _Out_writes_bytes_to_(*PackageSize, *PackageSize) PWSTR PackageFullName,
    _Inout_ PSIZE_T PackageSize,
    _Out_writes_bytes_to_opt_(*AppIdSize, *AppIdSize) PWSTR AppId,
    _Inout_opt_ PSIZE_T AppIdSize,
    _Out_opt_ LPGUID DynamicId,
    _Out_opt_ PULONG64 Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryPackageClaims (
    _In_ PVOID TokenObject,
    _Out_writes_bytes_to_opt_(*PackageSize, *PackageSize) PWSTR PackageFullName,
    _Inout_opt_ PSIZE_T PackageSize,
    _Out_writes_bytes_to_opt_(*AppIdSize, *AppIdSize) PWSTR AppId,
    _Inout_opt_ PSIZE_T AppIdSize,
    _Out_opt_ LPGUID DynamicId,
    _Out_opt_ PPS_PKG_CLAIM PkgClaim
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN8) && !defined(MIDL_PASS)

NTSYSAPI
NTSTATUS
NTAPI
RtlIsUntrustedObject (
    _In_opt_ HANDLE Handle,
    _In_opt_ PVOID Object,
    _Out_ PBOOLEAN UntrustedObject
    );

#endif // (NTDDI_VERSION >= NTDDI_WIN8) && !defined(MIDL_PASS)


#if (NTDDI_VERSION >= NTDDI_WIN8)
NTSYSAPI
ULONG
NTAPI
RtlQueryValidationRunlevel (
    _In_opt_ PCUNICODE_STRING ComponentName
    );
#endif


#if !defined(VRL_GLOBAL_LEVEL)

#if (NTDDI_VERSION >= NTDDI_WIN8)

//
// VRL_GLOBAL_LEVEL is a shortcut to querying the global validation runlevel.
// This should only be used when the component-specific level is unavailable or
// cannot be queried for whatever reason.
//
// The following define can only be used by kernel-mode callers. It is redefined
// suitably for user-mode callers if nturtl is included after.
//
#define VRL_GLOBAL_LEVEL (SharedUserData->GlobalValidationRunlevel)

#endif // (NTDDI_VERSION >= NTDDI_WIN8)

#endif // !defined(VRL_GLOBAL_LEVEL)


#if !defined(IS_VALIDATION_ENABLED)

#if (NTDDI_VERSION >= NTDDI_WIN8)

//
// Validation runlevel helper macro: checks if a particular level L enables the
// validation class C.
//
// Returns a non-zero scalar if class C is enabled, and zero otherwise.
//
#define IS_VALIDATION_ENABLED(C,L) ((L) & (C))

//
// Validation classes are broken into:
//      8 predefined validation classes, spanning bits 0 to 7 of the level value
//     24 custom-defined validation classes, spanning bits 8 to 31
//
#define VRL_PREDEFINED_CLASS_BEGIN  (1 << 0)
#define VRL_CUSTOM_CLASS_BEGIN      (1 << 8)

//
// The following are predefined validation classes.
//
#define VRL_CLASS_CONSISTENCY       (VRL_PREDEFINED_CLASS_BEGIN << 0)

//
// Do not ignore kernel breaks when kernel debugging is disabled (debug builds only)
//
#define VRL_ENABLE_KERNEL_BREAKS    (1 << 31)

#endif // (NTDDI_VERSION >= NTDDI_WIN8)

#endif // !defined(IS_VALIDATION_ENABLED)

#if (NTDDI_VERSION >= NTDDI_WIN8)

//
// RtlCheckTokenMembership flags.
//

#define CTMF_INCLUDE_APPCONTAINER   0x00000001UL
#define CTMF_VALID_FLAGS            (CTMF_INCLUDE_APPCONTAINER)

#endif // (NTDDI_VERSION >= NTDDI_WIN8)


#if (NTDDI_VERSION >= NTDDI_WIN8)


//
//  Crc32 and Crc64 routines that use standardized algorithms
//

NTSYSAPI
ULONG
NTAPI
RtlCrc32(
    _In_reads_bytes_(Size) const void *Buffer,
    _In_ size_t Size,
    _In_ ULONG InitialCrc
    );

NTSYSAPI
ULONGLONG
NTAPI
RtlCrc64(
    _In_reads_bytes_(Size) const void *Buffer,
    _In_ size_t Size,
    _In_ ULONGLONG InitialCrc
    );


#endif // (NTDDI_VERSION >= NTDDI_WIN8)


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;

// end_ntminiport

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data,
    IN ULONG DataLength
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data,
    IN ULONG DataLength // number of words
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data,
    IN ULONG DataLength  // number of dwords
    );


//
// Define per processor nonpaged lookaside list descriptor structure.
//

struct _NPAGED_LOOKASIDE_LIST;

typedef struct _PP_LOOKASIDE_LIST {
    struct _GENERAL_LOOKASIDE *P;
    struct _GENERAL_LOOKASIDE *L;
} PP_LOOKASIDE_LIST, *PPP_LOOKASIDE_LIST;

//
// Define the number of small pool lists.
//
// N.B. This value is used in pool.h and is used to allocate single entry
//      lookaside lists in the processor block of each processor.

#define POOL_SMALL_LISTS 32

//
// Thread tags.
//

typedef enum _KTHREAD_TAG {
    KThreadTagNone = 0,
    KThreadTagMediaBuffering,
    KThreadTagMax,
} KTHREAD_TAG, *PKTHREAD_TAG;

// begin_wdm
// begin_ntminiport
// begin_wudfpwdm

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#undef ALIGN_DOWN_BY
#undef ALIGN_UP_BY
#undef ALIGN_DOWN_POINTER_BY
#undef ALIGN_UP_POINTER_BY
#undef ALIGN_DOWN
#undef ALIGN_UP
#undef ALIGN_DOWN_POINTER
#undef ALIGN_UP_POINTER

#define ALIGN_DOWN_BY(length, alignment) \
    ((ULONG_PTR)(length) & ~(alignment - 1))

#define ALIGN_UP_BY(length, alignment) \
    (ALIGN_DOWN_BY(((ULONG_PTR)(length) + alignment - 1), alignment))

#define ALIGN_DOWN_POINTER_BY(address, alignment) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)alignment - 1)))

#define ALIGN_UP_POINTER_BY(address, alignment) \
    (ALIGN_DOWN_POINTER_BY(((ULONG_PTR)(address) + alignment - 1), alignment))

#define ALIGN_DOWN(length, type) \
    ALIGN_DOWN_BY(length, sizeof(type))

#define ALIGN_UP(length, type) \
    ALIGN_UP_BY(length, sizeof(type))

#define ALIGN_DOWN_POINTER(address, type) \
    ALIGN_DOWN_POINTER_BY(address, sizeof(type))

#define ALIGN_UP_POINTER(address, type) \
    ALIGN_UP_POINTER_BY(address, sizeof(type))

// end_wudfpwdm
// end_ntminiport

//
// Calculate the byte offset of a field in a structure of type type.
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field) ((ULONG)&(((type *)0)->field))
#endif

#ifndef FIELD_SIZE
#define FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

#if defined (_WIN64)
#define BitScanReverseSizeT BitScanReverse64
#define BitScanForwardSizeT BitScanForward64
#else
#define BitScanReverseSizeT BitScanReverse
#define BitScanForwardSizeT BitScanForward
#endif

#define POOL_TAGGING 1

#if DBG

#define IF_DEBUG if (TRUE)

#else

#define IF_DEBUG if (FALSE)

#endif

#if DEVL


extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG(FlagName) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else

#define IF_NTOS_DEBUG(FlagName) if(FALSE)

#endif

// begin_ntndis

//
// Define General Lookaside and supporting types here
//

typedef _Enum_is_bitflag_ enum _POOL_TYPE POOL_TYPE;

// begin_wudfpwdm

typedef
_IRQL_requires_same_
_Function_class_(ALLOCATE_FUNCTION)
PVOID
ALLOCATE_FUNCTION (
    _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Tag
    );
typedef ALLOCATE_FUNCTION *PALLOCATE_FUNCTION;

typedef
_IRQL_requires_same_
_Function_class_(FREE_FUNCTION)
VOID
FREE_FUNCTION (
    _In_ __drv_freesMem(Mem) PVOID Buffer
    );
typedef FREE_FUNCTION *PFREE_FUNCTION;

typedef struct _LOOKASIDE_LIST_EX *PLOOKASIDE_LIST_EX;

typedef
_IRQL_requires_same_
_Function_class_(ALLOCATE_FUNCTION_EX)
PVOID
ALLOCATE_FUNCTION_EX (
    _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Tag,
    _Inout_ PLOOKASIDE_LIST_EX Lookaside
    );
typedef ALLOCATE_FUNCTION_EX *PALLOCATE_FUNCTION_EX;

typedef
_IRQL_requires_same_
_Function_class_(FREE_FUNCTION_EX)
VOID
FREE_FUNCTION_EX (
    _In_ __drv_freesMem(Mem) PVOID Buffer,
    _Inout_ PLOOKASIDE_LIST_EX Lookaside
    );
typedef FREE_FUNCTION_EX *PFREE_FUNCTION_EX;

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

#define LOOKASIDE_ALIGN

#else

#define LOOKASIDE_ALIGN DECLSPEC_CACHEALIGN

#endif


//
// The goal here is to end up with two structure types that are identical except
// for the fact that one (GENERAL_LOOKASIDE) is cache aligned, and the other
// (GENERAL_LOOKASIDE_POOL) is merely naturally aligned.
//
// An anonymous structure element would do the trick except that C++ can't handle
// such complex syntax, so we're stuck with this macro technique.
//

#define GENERAL_LOOKASIDE_LAYOUT                \
    union {                                     \
        SLIST_HEADER ListHead;                  \
        SINGLE_LIST_ENTRY SingleListHead;       \
    } DUMMYUNIONNAME;                           \
    USHORT Depth;                               \
    USHORT MaximumDepth;                        \
    ULONG TotalAllocates;                       \
    union {                                     \
        ULONG AllocateMisses;                   \
        ULONG AllocateHits;                     \
    } DUMMYUNIONNAME2;                          \
                                                \
    ULONG TotalFrees;                           \
    union {                                     \
        ULONG FreeMisses;                       \
        ULONG FreeHits;                         \
    } DUMMYUNIONNAME3;                          \
                                                \
    POOL_TYPE Type;                             \
    ULONG Tag;                                  \
    ULONG Size;                                 \
    union {                                     \
        PALLOCATE_FUNCTION_EX AllocateEx;       \
        PALLOCATE_FUNCTION Allocate;            \
    } DUMMYUNIONNAME4;                          \
                                                \
    union {                                     \
        PFREE_FUNCTION_EX FreeEx;               \
        PFREE_FUNCTION Free;                    \
    } DUMMYUNIONNAME5;                          \
                                                \
    LIST_ENTRY ListEntry;                       \
    ULONG LastTotalAllocates;                   \
    union {                                     \
        ULONG LastAllocateMisses;               \
        ULONG LastAllocateHits;                 \
    } DUMMYUNIONNAME6;                          \
    ULONG Future[2];

//
// GENERAL_LOOKASIDE is a cache aligned type, typically shared between
// multiple processors
//

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct LOOKASIDE_ALIGN _GENERAL_LOOKASIDE {
    GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE;

typedef GENERAL_LOOKASIDE *PGENERAL_LOOKASIDE;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

// end_wudfpwdm

// end_ntndis

//
// GENERAL_LOOKASIDE_POOL is the same layout as GENERAL_LOOKASIDE but is
// not cacheblock aligned, for use in cases where access is limited to a
// single processor
//

typedef struct _GENERAL_LOOKASIDE_POOL {
    GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE_POOL, *PGENERAL_LOOKASIDE_POOL;

//
// The above two structures should have identical layouts.  A few spot-checks
// just to make sure.
//

#define LOOKASIDE_CHECK(f)  \
    C_ASSERT(FIELD_OFFSET(GENERAL_LOOKASIDE,f)==FIELD_OFFSET(GENERAL_LOOKASIDE_POOL,f))

LOOKASIDE_CHECK(TotalFrees);
LOOKASIDE_CHECK(Tag);
LOOKASIDE_CHECK(Future);

//
// Kernel definitions that need to be here for forward reference purposes
//

// begin_ntndis
// begin_wudfwdm
//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

// end_wudfwdm
// end_ntndis end_wdm
//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
_Function_class_(KNORMAL_ROUTINE)
_IRQL_requires_max_(PASSIVE_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID
KNORMAL_ROUTINE (
    _In_opt_ PVOID NormalContext,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2
    );
typedef KNORMAL_ROUTINE *PKNORMAL_ROUTINE;

typedef
_Function_class_(KKERNEL_ROUTINE)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(APC_LEVEL)
_IRQL_requires_(APC_LEVEL)
_IRQL_requires_same_
VOID
KKERNEL_ROUTINE (
    _In_ struct _KAPC *Apc,
    _Inout_ PKNORMAL_ROUTINE *NormalRoutine,
    _Inout_ PVOID *NormalContext,
    _Inout_ PVOID *SystemArgument1,
    _Inout_ PVOID *SystemArgument2
    );
typedef KKERNEL_ROUTINE *PKKERNEL_ROUTINE;

typedef
_Function_class_(KRUNDOWN_ROUTINE)
_IRQL_requires_max_(PASSIVE_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID
KRUNDOWN_ROUTINE (
    _In_ struct _KAPC *Apc
    );
typedef KRUNDOWN_ROUTINE *PKRUNDOWN_ROUTINE;

// begin_wdm

typedef
_Function_class_(KSYNCHRONIZE_ROUTINE)
_IRQL_requires_(HIGH_LEVEL) // HIGH_LEVEL is best approximation of DIRQL
_IRQL_requires_same_
BOOLEAN
KSYNCHRONIZE_ROUTINE (
    _In_opt_ PVOID SynchronizeContext
    );
typedef KSYNCHRONIZE_ROUTINE *PKSYNCHRONIZE_ROUTINE;

// end_wdm

//
// Asynchronous Procedure Call (APC) object
//
// N.B. The size of this structure cannot change since it has been exported.
//

#define ASSERT_APC(E) NT_ASSERT((E)->Type == ApcObject)

typedef struct _KAPC {                  // wdm
    UCHAR Type;                         // wdm
    UCHAR SpareByte0;                   // wdm
    UCHAR Size;                         // wdm
    UCHAR SpareByte1;                   // wdm
    ULONG SpareLong0;                   // wdm
    struct _KTHREAD *Thread;            // wdm
    LIST_ENTRY ApcListEntry;            // wdm
    union {
    struct {
        PKKERNEL_ROUTINE KernelRoutine;
        PKRUNDOWN_ROUTINE RundownRoutine;
        PKNORMAL_ROUTINE NormalRoutine;
    };

    PVOID Reserved[3];                  // wdm
    };

    PVOID NormalContext;                // wdm

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;              // wdm
    PVOID SystemArgument2;              // wdm
    CCHAR ApcStateIndex;                // wdm
    KPROCESSOR_MODE ApcMode;            // wdm
    BOOLEAN Inserted;                   // wdm
} KAPC, *PKAPC, *PRKAPC;        // wdm

// begin_wdm

#define KAPC_OFFSET_TO_SPARE_BYTE0 FIELD_OFFSET(KAPC, SpareByte0)
#define KAPC_OFFSET_TO_SPARE_BYTE1 FIELD_OFFSET(KAPC, SpareByte1)
#define KAPC_OFFSET_TO_SPARE_LONG FIELD_OFFSET(KAPC, SpareLong0)
#define KAPC_OFFSET_TO_SYSTEMARGUMENT1 FIELD_OFFSET(KAPC, SystemArgument1)
#define KAPC_OFFSET_TO_SYSTEMARGUMENT2 FIELD_OFFSET(KAPC, SystemArgument2)
#define KAPC_OFFSET_TO_APCSTATEINDEX FIELD_OFFSET(KAPC, ApcStateIndex)
#define KAPC_ACTUAL_LENGTH (FIELD_OFFSET(KAPC, Inserted) + sizeof(BOOLEAN))

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

_Function_class_(KDEFERRED_ROUTINE)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
VOID
KDEFERRED_ROUTINE (
    _In_ struct _KDPC *Dpc,
    _In_opt_ PVOID DeferredContext,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2
    );

typedef KDEFERRED_ROUTINE *PKDEFERRED_ROUTINE;

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at end of target DPC queue.
// MediumHighImportance - Queue DPC at end of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue.
//
// If there is currently a DPC active on the target processor, or a DPC
// interrupt has already been requested on the target processor when a
// DPC is queued, then no further action is necessary. The DPC will be
// executed on the target processor when its queue entry is processed.
//
// If there is not a DPC active on the target processor and a DPC interrupt
// has not been requested on the target processor, then the exact treatment
// of the DPC is dependent on whether the host system is a UP system or an
// MP system.
//
// UP system.
//
// If the DPC is not of low importance, the current DPC queue depth
// is greater than the maximum target depth, or current DPC request rate is
// less the minimum target rate, then a DPC interrupt is requested on the
// host processor and the DPC will be processed when the interrupt occurs.
// Otherwise, no DPC interupt is requested and the DPC execution will be
// delayed until the DPC queue depth is greater that the target depth or the
// minimum DPC rate is less than the target rate.
//
// MP system.
//
// If the DPC is being queued to another processor and the depth of the DPC
// queue on the target processor is greater than the maximum target depth or
// the DPC is of medium high or high importance, then a DPC interrupt is
// requested on the target processor and the DPC will be processed when the
// Interrupt occurs.  Otherwise, the DPC execution will be delayed on the target
// processor until the DPC queue depth on the target processor is greater that
// the maximum target depth or the minimum DPC rate on the target processor is
// less than the target mimimum rate.
//
// If the DPC is being queued to the current processor and the DPC is not of
// low importance, the current DPC queue depth is greater than the maximum
// target depth, or the minimum DPC rate is less than the minimum target rate,
// then a DPC interrupt is request on the current processor and the DPV will
// be processed when the interrupt occurs. Otherwise, no DPC interupt is
// requested and the DPC execution will be delayed until the DPC queue depth
// is greater that the target depth or the minimum DPC rate is less than the
// target rate.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance,
    MediumHighImportance
} KDPC_IMPORTANCE;

//
// Define DPC type indicies.
//

#define DPC_NORMAL 0
#define DPC_THREADED 1

//
// Deferred Procedure Call (DPC) object
//

#define ASSERT_DPC(Object)                                                   \
    NT_ASSERT(((Object)->Type == 0) ||                                       \
              ((Object)->Type == DpcObject) ||                               \
              ((Object)->Type == ThreadedDpcObject))

typedef struct _KDPC {
    union {
        ULONG TargetInfoAsUlong;
        struct {
            UCHAR Type;
            UCHAR Importance;
            volatile USHORT Number;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    SINGLE_LIST_ENTRY DpcListEntry;
    KAFFINITY ProcessorHistory;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    __volatile PVOID DpcData;
} KDPC, *PKDPC, *PRKDPC;

// end_wdm end_ntndis
// begin_nthal

//
// Interprocessor interrupt worker routine function prototype.
//

typedef PVOID PKIPI_CONTEXT;

typedef
_Function_class_(KIPI_WORKER)
_IRQL_requires_same_
VOID
KIPI_WORKER (
    _Inout_ PKIPI_CONTEXT PacketContext,
    _In_opt_ PVOID Parameter1,
    _In_opt_ PVOID Parameter2,
    _In_opt_ PVOID Parameter3
    );

typedef KIPI_WORKER *PKIPI_WORKER;

//
// Define interprocessor interrupt performance counters.
//

typedef struct _KIPI_COUNTS {
    ULONG Freeze;
    ULONG Packet;
    ULONG DPC;
    ULONG APC;
    ULONG FlushSingleTb;
    ULONG FlushMultipleTb;
    ULONG FlushEntireTb;
    ULONG GenericCall;
    ULONG ChangeColor;
    ULONG SweepDcache;
    ULONG SweepIcache;
    ULONG SweepIcacheRange;
    ULONG FlushIoBuffers;
    ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;

// end_nthal

//
// Define request packet structure.
//

typedef struct _KREQUEST_PACKET {
    PVOID CurrentPacket[3];
    PKIPI_WORKER WorkerRoutine;
} KREQUEST_PACKET, *PKREQUEST_PACKET;

//
// Define request mailbox structure.
//

typedef struct _REQUEST_MAILBOX {
    struct _REQUEST_MAILBOX *Next;
    ULONG_PTR RequestSummary;
    KREQUEST_PACKET RequestPacket;
    LONG volatile *NodeTargetCountAddr;
    volatile LONG NodeTargetCount;
} REQUEST_MAILBOX, *PREQUEST_MAILBOX;

C_ASSERT(sizeof(REQUEST_MAILBOX) <= SYSTEM_CACHE_ALIGNMENT_SIZE);

// begin_wdm begin_ntosp begin_ntndis begin_ntminiport
// begin_wudfwdm

#if defined(_X86_)

//
// i386 Specific portions of Mm component.
//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

#elif defined(_AMD64_)

//
// AMD64 Specific portions of Mm component.
//
// Define the page size for the AMD64 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

#elif defined(_ARM64_)

//
// ARM Specific portions of Mm component.
//
// Define the page size for the ARM64 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

#elif defined(_ARM_)

//
// ARM Specific portions of Mm component.
//
// Define the page size for the ARM as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

#endif

// end_wudfwdm
// end_ntminiport

//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.
//
// One simply calculates the base of the array by adding one to the base
// MDL pointer:
//
//      Pages = (PPFN_NUMBER) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//

//
// Use _Inexpressible_ until the definition can be fixed (PAGE_SIZE may not be
// defined at this point).
//

typedef
    _Struct_size_bytes_(_Inexpressible_(sizeof(struct _MDL) +    // 747934
       (ByteOffset + ByteCount + PAGE_SIZE-1) / PAGE_SIZE * sizeof(PFN_NUMBER)))
  struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;

// end_wdm end_ntndis
#if defined(_WIN64)

    USHORT AllocationProcessorNumber;
    USHORT Reserved;

#endif

// begin_wdm begin_ntndis
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;   /* see creators for field size annotations. */
    PVOID StartVa;   /* see creators for validity; could be address 0.  */
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

typedef _Readable_bytes_(_Inexpressible_(polymorphism)) MDL *PMDLX;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_LOCKED_PAGE_TABLES      0x0100
#define MDL_PARENT_MAPPED_SYSTEM_VA MDL_LOCKED_PAGE_TABLES
#define MDL_FREE_EXTRA_PTES         0x0200
#define MDL_DESCRIBES_AWE           0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_PAGE_CONTENTS_INVARIANT 0x4000
#define MDL_ALLOCATED_MUST_SUCCEED  MDL_PAGE_CONTENTS_INVARIANT
#define MDL_INTERNAL                0x8000

#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

// end_ntndis
//
// switch to PREFast or DBG when appropriate
//

#if defined(_PREFAST_)

_IRQL_requires_max_(APC_LEVEL)
void __PREfastPagedCode(void);

void __PREfastPagedCodeLocked(void);
#define PAGED_CODE()        __PREfastPagedCode();
#define PAGED_CODE_LOCKED() __PREfastPagedCodeLocked();

#elif DBG

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define PAGED_ASSERT( exp ) NT_ASSERT( exp )
#else
#define PAGED_ASSERT( exp ) ASSERT( exp )
#endif

#define PAGED_CODE() PAGED_ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

#define PAGED_CODE_LOCKED() NOP_FUNCTION;

#else

#define PAGED_CODE()        NOP_FUNCTION;
#define PAGED_CODE_LOCKED() NOP_FUNCTION;

#endif

//
// Data structure used to represent client security context for a thread.
// This data structure is used to support impersonation.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_CLIENT_CONTEXT {
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_TOKEN ClientToken;
    BOOLEAN DirectlyAccessClientToken;
    BOOLEAN DirectAccessEffectiveOnly;
    BOOLEAN ServerIsRemote;
    TOKEN_CONTROL ClientTokenControl;
    } SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

//
// where
//
//    SecurityQos - is the security quality of service information in effect
//        for this client.  This information is used when directly accessing
//        the client's token.  In this case, the information here over-rides
//        the information in the client's token.  If a copy of the client's
//        token is requested, it must be generated using this information,
//        not the information in the client's token.  In all cases, this
//        information may not provide greater access than the information
//        in the client's token.  In particular, if the client's token is
//        an impersonation token with an impersonation level of
//        "SecurityDelegation", but the information in this field indicates
//        an impersonation level of "SecurityIdentification", then
//        the server may only get a copy of the token with an Identification
//        level of impersonation.
//
//    ClientToken - If the DirectlyAccessClientToken field is FALSE,
//        then this field contains a pointer to a duplicate of the
//        client's token.  Otherwise, this field points directly to
//        the client's token.
//
//    DirectlyAccessClientToken - This boolean flag indicates whether the
//        token pointed to by ClientToken is a copy of the client's token
//        or is a direct reference to the client's token.  A value of TRUE
//        indicates the client's token is directly accessed, FALSE indicates
//        a copy has been made.
//
//    DirectAccessEffectiveOnly - This boolean flag indicates whether the
//        the disabled portions of the token that is currently directly
//        referenced may be enabled.  This field is only valid if the
//        DirectlyAccessClientToken field is TRUE.  In that case, this
//        value supersedes the EffectiveOnly value in the SecurityQos
//        FOR THE CURRENT TOKEN ONLY!  If the client changes to impersonate
//        another client, this value may change.  This value is always
//        minimized by the EffectiveOnly flag in the SecurityQos field.
//
//    ServerIsRemote - If TRUE indicates that the server of the client's
//        request is remote.  This is used for determining the legitimacy
//        of certain levels of impersonation and to determine how to
//        track context.
//
//    ClientTokenControl - If the ServerIsRemote flag is TRUE, and the
//        tracking mode is DYNAMIC, then this field contains a copy of
//        the TOKEN_SOURCE from the client's token to assist in deciding
//        whether the information at the remote server needs to be
//        updated to match the current state of the client's security
//        context.
//
//
//    NOTE: At some point, we may find it worthwhile to keep an array of
//          elements in this data structure, where each element of the
//          array contains {ClientToken, ClientTokenControl} fields.
//          This would allow efficient handling of the case where a client
//          thread was constantly switching between a couple different
//          contexts - presumably impersonating client's of its own.
//
// begin_ntoshvp

#if defined(_NTSYSTEM_)

#define NTKERNELAPI

#else

#define NTKERNELAPI DECLSPEC_IMPORT     // wdm ntddk nthal ntndis ntifs

#endif

// end_ntoshvp

#if defined(_X86_) && !defined(_NTHAL_)

#define _DECL_HAL_KE_IMPORT  DECLSPEC_IMPORT

#elif defined(_X86_)

#define _DECL_HAL_KE_IMPORT

#else

#define _DECL_HAL_KE_IMPORT NTKERNELAPI

#endif

#define NTHALAPI DECLSPEC_IMPORT            
//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

#if defined(_X86_)

#define KENCODED_TIMER_PROCESSOR        1       // Timer processor is encoded in header

#endif

#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

typedef struct _DISPATCHER_HEADER {
    union {
        union {
            volatile LONG Lock;
            LONG LockNV;
        } DUMMYUNIONNAME;

        struct {                            // Events, Semaphores, Gates, etc.
            UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
            UCHAR Signalling;
            UCHAR Size;
            UCHAR Reserved1;
        } DUMMYSTRUCTNAME;

        struct {                            // Timer
            UCHAR TimerType;
            union {
                UCHAR TimerControlFlags;
                struct {
                    UCHAR Absolute : 1;
                    UCHAR Wake : 1;
                    UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
                } DUMMYSTRUCTNAME;
            };

            UCHAR Hand;
            union {
                UCHAR TimerMiscFlags;
                struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

                    UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

                    UCHAR Index : 1;
                    UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

                    UCHAR Inserted : 1;
                    volatile UCHAR Expired : 1;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;
        } DUMMYSTRUCTNAME2;

        struct {                            // Timer2
            UCHAR Timer2Type;
            union {
                UCHAR Timer2Flags;
                struct {
                    UCHAR Timer2Inserted : 1;
                    UCHAR Timer2Expiring : 1;
                    UCHAR Timer2CancelPending : 1;
                    UCHAR Timer2SetPending : 1;
                    UCHAR Timer2Running : 1;
                    UCHAR Timer2Disabled : 1;
                    UCHAR Timer2ReservedFlags : 2;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR Timer2Reserved1;
            UCHAR Timer2Reserved2;
        } DUMMYSTRUCTNAME3;

        struct {                            // Queue
            UCHAR QueueType;
            union {
                UCHAR QueueControlFlags;
                struct {
                    UCHAR Abandoned : 1;
                    UCHAR DisableIncrement : 1;
                    UCHAR QueueReservedControlFlags : 6;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR QueueSize;
            UCHAR QueueReserved;
        } DUMMYSTRUCTNAME4;

        struct {                            // Thread
            UCHAR ThreadType;
            UCHAR ThreadReserved;
            union {
                UCHAR ThreadControlFlags;
                struct {
                    UCHAR CycleProfiling : 1;
                    UCHAR CounterProfiling : 1;
                    UCHAR GroupScheduling : 1;
                    UCHAR AffinitySet : 1;
                    UCHAR Tagged : 1;
                    UCHAR EnergyProfiling: 1;

#if !defined(_X86_)

                    UCHAR ThreadReservedControlFlags : 2;

#else

                    UCHAR Instrumented : 1;
                    UCHAR ThreadReservedControlFlags : 1;

#endif

                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            union {
                UCHAR DebugActive;

#if !defined(_X86_)

                struct {
                    BOOLEAN ActiveDR7 : 1;
                    BOOLEAN Instrumented : 1;
                    BOOLEAN Minimal : 1;
                    BOOLEAN Reserved4 : 3;
                    BOOLEAN UmsScheduled : 1;
                    BOOLEAN UmsPrimary : 1;
                } DUMMYSTRUCTNAME;

#endif

            } DUMMYUNIONNAME2;
        } DUMMYSTRUCTNAME5;

        struct {                         // Mutant
            UCHAR MutantType;
            UCHAR MutantSize;
            BOOLEAN DpcActive;
            UCHAR MutantReserved;
        } DUMMYSTRUCTNAME6;
    } DUMMYUNIONNAME;

    LONG SignalState;                   // Object lock
    LIST_ENTRY WaitListHead;            // Object lock
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

#define DEBUG_ACTIVE_RESERVED_BIT       5   // Offset chosen due to x86 debug mask

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

//
// Gate object
//
// N.B. Gate object services allow the specification of synchronization
//      events. This allows fast mutex to be transparently replaced with
//      gates.
//

typedef struct _KGATE {
    DISPATCHER_HEADER Header;
} KGATE, *PKGATE;

//
// Timer object
//
// N.B. The period field must be the last member of this structure.
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;

#if !defined(KENCODED_TIMER_PROCESSOR)

    ULONG Processor;

#endif

    ULONG Period;
} KTIMER, *PKTIMER, *PRKTIMER;

#define KTIMER_ACTUAL_LENGTH                                                \
    (FIELD_OFFSET(KTIMER, Period) + sizeof(LONG))

// begin_wudfpwdm

typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;

// end_wudfpwdm
// end_ntndis

typedef struct _FAST_MUTEX {
    LONG Count;
    PVOID Owner;
    ULONG Contention;
    KEVENT Event;
    ULONG OldIrql;
} FAST_MUTEX, *PFAST_MUTEX, KGUARDED_MUTEX, *PKGUARDED_MUTEX;


#if defined(_X86_)
//
// Image header machine architecture
//

#define IMAGE_FILE_MACHINE_NATIVE   0x014c


//
// Sanitize segCS and eFlags based on a processor mode.
//
// If kernel mode,
//      force CPL == 0
//
// If user mode,
//      force CPL == 3
//

#define SANITIZE_SEG(segCS, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((segCS) & 0xfffc)) : \
        ((0x00000003L) | ((segCS) & 0xffff))))

//
// If kernel mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Interrupt, AlignCheck.
//
// If user mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, AlignCheck.
//      force Interrupts on.
//


#define SANITIZE_FLAGS(eFlags, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((eFlags) & 0x003f0fd7)) : \
        ((EFLAGS_INTERRUPT_MASK) | ((eFlags) & EFLAGS_USER_SANITIZE))))

//
// Masks for Dr7 and sanitize macros for various Dr registers.
//

#define DR6_LEGAL   0x0000e00f

#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,
                                // Local enable for Dr0-Dr4,
                                // Le for "perfect" trapping

//
// Bits to used track the state of the various debug registers
//

#define DR7_OVERRIDE_V 0x04

#define DR_MASK(Bit) (((UCHAR)(1UL << (Bit))))


#define DR_REG_MASK (DR_MASK(0) | DR_MASK(1) | DR_MASK(2) | DR_MASK(3) | DR_MASK(6))
#define DR_RESERVED_BITS (DR_MASK (DEBUG_ACTIVE_RESERVED_BIT))
C_ASSERT ((DR_RESERVED_BITS & DR_REG_MASK) == 0);
#define DR_VALID_MASK (DR_REG_MASK | DR_MASK (7) | DR_MASK (DR7_OVERRIDE_V) | DR_RESERVED_BITS)

#define DR7_MASK_SHIFT 16   // Shift to translate the valid mask to a spare region in Dr7
                            // The region occupied is the LEN & R/W region for Dr0

#define DR7_OVERRIDE_MASK ((0x0FUL) << DR7_MASK_SHIFT)  // This corresponds to a break on R/W of 4
                                                        // bytes from the address indicated by DR0
#define DR7_RESERVED_MASK 0x0000DC00    // Bits 10-12, 14-15 are reserved
#define DR7_ACTIVE  0x00000055          // If any of these bits are set, a Dr is active

C_ASSERT (sizeof(BOOLEAN) == sizeof(UCHAR));
C_ASSERT ((((ULONG)DR_VALID_MASK) & ~((ULONG)((UCHAR)0xFF))) == 0);
C_ASSERT ((DR7_ACTIVE & DR7_OVERRIDE_MASK) == 0);
C_ASSERT ((DR7_RESERVED_MASK & DR7_OVERRIDE_MASK) == 0);
C_ASSERT ((DR7_OVERRIDE_MASK & DR7_LEGAL) == DR7_OVERRIDE_MASK);
C_ASSERT ((DR7_RESERVED_MASK & DR7_LEGAL) == 0);

#define SANITIZE_DR6(Dr6, mode) (((Dr6) & DR6_LEGAL))

#define SANITIZE_DR7(Dr7, mode) (((Dr7) & DR7_LEGAL))

#define SANITIZE_DRADDR(DrReg, mode) (          \
    (mode) == KernelMode ?                      \
        (DrReg) :                               \
        (((PVOID)DrReg <= MM_HIGHEST_USER_ADDRESS) ?   \
            (DrReg) :                           \
            (0)                                 \
        )                                       \
    )

//
// Define macro to clear reserved bits from MXCSR so that we don't
// GP fault when doing an FRSTOR
//

extern ULONG KiMxCsrMask;

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & KiMxCsrMask)

//
// Nonvolatile context pointers
//
// bryanwi 21 feb 90 - This is bogus.  The 386 doesn't have
//                     enough nonvolatile context to make this
//                     structure worthwhile.  Can't declare a
//                     field to be void, so declare a Junk structure
//                     instead.

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    ULONG   Junk;
} KNONVOLATILE_CONTEXT_POINTERS,  *PKNONVOLATILE_CONTEXT_POINTERS;

//
// This structure describes the stack layout of a kernel stack segment,
// beginning at the address indicated by the last valid stack pointer.
// It is used by the debugger and internal stack walking code to trace
// across multiple stack segments.
//

typedef struct _KSTACK_SWITCH_FRAME {
    ULONG Edi;
    ULONG Esi;
    ULONG Ebx;
    ULONG Ebp;
} KSTACK_SWITCH_FRAME, *PKSTACK_SWITCH_FRAME;

//
// The legacy frame saved by KiCallUserMode is defined here to allow
// the kernel debugger to trace the entire kernel stack
// when usermode callouts are pending.
//

typedef struct _KCALLOUT_FRAME {
    ULONG   InStk;          // saved initial stack address
    ULONG   TrFr;           // saved callback trap frame
    ULONG   CbStk;          // saved callback stack address
    ULONG   Edi;            // saved nonvolatile registers
    ULONG   Esi;            //
    ULONG   Ebx;            //
    ULONG   Ebp;            //
    ULONG   Ret;            // saved return address
    ULONG   OutBf;          // address to store output buffer
    ULONG   OutLn;          // address to store output length
} KCALLOUT_FRAME;

typedef KCALLOUT_FRAME *PKCALLOUT_FRAME;


//
//  Switch Frame
//
//  386 doesn't have an "exception frame", and doesn't normally make
//  any use of nonvolatile context register structures.
//
//  However, swapcontext in ctxswap.c and KeInitializeThread in
//  thredini.c need to share common stack structure used at thread
//  startup and switch time.
//
//  This is that structure.
//

typedef struct _KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   ApcBypassDisable;
    ULONG   RetAddr;
} KSWITCHFRAME, *PKSWITCHFRAME;


//
// Various 387 defines
//

#define I386_80387_NP_VECTOR    0x07    // trap 7 when hardware not present

typedef struct _PROCESS_IO_PORT_HANDLER_INFORMATION {
    BOOLEAN Install;            // true if handlers to be installed
    ULONG NumEntries;
    ULONG Context;
    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
} PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;


//
//    Vdm Objects and Io handling structure
//

typedef struct _VDM_IO_HANDLER_FUNCTIONS {
    PDRIVER_IO_PORT_ULONG  UlongIo;
    PDRIVER_IO_PORT_ULONG_STRING UlongStringIo;
    PDRIVER_IO_PORT_USHORT UshortIo[2];
    PDRIVER_IO_PORT_USHORT_STRING UshortStringIo[2];
    PDRIVER_IO_PORT_UCHAR UcharIo[4];
    PDRIVER_IO_PORT_UCHAR_STRING UcharStringIo[4];
} VDM_IO_HANDLER_FUNCTIONS, *PVDM_IO_HANDLER_FUNCTIONS;

typedef struct _VDM_IO_HANDLER {
    struct _VDM_IO_HANDLER *Next;
    ULONG PortNumber;
    VDM_IO_HANDLER_FUNCTIONS IoFunctions[2];
} VDM_IO_HANDLER, *PVDM_IO_HANDLER;

#endif // defined(_X86_)
// begin_ntoshvp

#if defined(_X86_) // irqls
// end_ntoshvp
// end_ntddk end_nthal

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 32

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level
#define CMCI_LEVEL 5                // CMCI handler level

#define PROFILE_LEVEL 27            // timer used for profiling.
#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86
#define CLOCK2_LEVEL 28             // Interval clock 2 level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level

#define CLOCK_LEVEL                 (CLOCK2_LEVEL)

// end_irqls
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(HIGH_LEVEL)
_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfLowerIrql (
    _In_ _IRQL_restores_ _Notliteral_ KIRQL NewIrql
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_raises_(NewIrql)
_IRQL_saves_
_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfRaiseIrql (
    _In_ KIRQL NewIrql
    );
#endif

#define KeLowerIrql(a) KfLowerIrql(a)
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

// end_wdm
// begin_ntddk begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );
#endif

// end_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_saves_
_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );
#endif

// end_ntddk
// begin_nthal

// synchronization level - MP system
#define SYNCH_LEVEL (IPI_LEVEL-2)

#define MODE_MASK    1      

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
    _In_ _Notliteral_ volatile UCHAR *Register
    );

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
    _In_ _Notliteral_ volatile USHORT *Register
    );

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
    _In_ _Notliteral_ volatile ULONG *Register
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
    _In_ _Notliteral_ volatile UCHAR *Register,
    _Out_writes_all_(Count) PUCHAR  Buffer,
    _In_ ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
    _In_ _Notliteral_ volatile USHORT *Register,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
    _In_ _Notliteral_ volatile ULONG *Register,
    _Out_writes_all_(Count) PULONG  Buffer,
    _In_ ULONG   Count
    );


NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
    _In_ _Notliteral_ volatile UCHAR *Register,
    _In_ UCHAR   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
    _In_ _Notliteral_ volatile USHORT *Register,
    _In_ USHORT  Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
    _In_ _Notliteral_ volatile ULONG *Register,
    _In_ ULONG   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
    _In_ _Notliteral_ volatile UCHAR *Register,
    _In_reads_(Count) PUCHAR  Buffer,
    _In_ ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
    _In_ _Notliteral_ volatile USHORT *Register,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
    _In_ _Notliteral_ volatile ULONG *Register,
    _In_reads_(Count) PULONG  Buffer,
    _In_ ULONG   Count
    );

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
    _In_ _Notliteral_ PUCHAR  Port
    );

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
    _In_ _Notliteral_ PUSHORT Port
    );

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
    _In_ _Notliteral_ PULONG  Port
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
    _In_ _Notliteral_ PUCHAR  Port,
    _Out_writes_all_(Count) PUCHAR  Buffer,
    _In_ ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
    _In_ _Notliteral_ PUSHORT Port,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
    _In_ _Notliteral_ PULONG  Port,
    _Out_writes_all_(Count) PULONG  Buffer,
    _In_ ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
    _In_ _Notliteral_ PUCHAR  Port,
    _In_ UCHAR   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
    _In_ _Notliteral_ PUSHORT Port,
    _In_ USHORT  Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
    _In_ _Notliteral_ PULONG  Port,
    _In_ ULONG   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
    _In_ _Notliteral_ PUCHAR  Port,
    _In_reads_(Count) PUCHAR  Buffer,
    _In_ ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
    _In_ _Notliteral_ PUSHORT Port,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
    _In_ _Notliteral_ PULONG  Port,
    _In_reads_(Count) PULONG  Buffer,
    _In_ ULONG   Count
    );

// end_ntndis
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

VOID
KeFlushIoBuffers (
    _In_ PMDL Mdl,
    _In_ BOOLEAN ReadOperation,
    _In_ BOOLEAN DmaOperation
    );

#else

#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

#endif


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount) { \
    KSYSTEM_TIME volatile *_TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    for (;;) {                                                              \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        YieldProcessor();                                                   \
    }                                                                       \
}

// end_wdm

#else

VOID
NTAPI
KeQueryTickCount (
    _Out_ PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)


//
// 386 hardware structures
//

//
// A Page Table Entry on an X86 processor has the following definition.
//
// N.B. Only PAE mode is supported by Windows on X86 processors.
//

typedef struct _HARDWARE_PTE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 26;
            ULONGLONG reserved1 : 26;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// GDT Entry
//

typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;

#define TYPE_CODE   0x1a  // 11010 = Code, Readable, NOT Conforming, Accessed
#define TYPE_DATA   0x12  // 10010 = Data, ReadWrite, NOT Expanddown, Accessed
#define TYPE_TSS    0x09  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04


#define IDT_NMI_VECTOR       2
#define IDT_DFH_VECTOR       8
#define NMI_TSS_DESC_OFFSET  0x58
#define DF_TSS_DESC_OFFSET   0x50


//
// Entry of Interrupt Descriptor Table (IDTENTRY)
//

typedef struct _KIDTENTRY {
   USHORT Offset;
   USHORT Selector;
   USHORT Access;
   USHORT ExtendedOffset;
} KIDTENTRY;

typedef KIDTENTRY *PKIDTENTRY;


//
// TSS (Task switch segment) NT only uses to control stack switches.
//
//  The only fields we actually care about are Esp0, Ss0, the IoMapBase
//  and the IoAccessMaps themselves.
//
//
//  N.B.    Size of TSS must be <= 0xDFFF
//

//
// The interrupt direction bitmap is used on Pentium to allow
// the processor to emulate V86 mode software interrupts for us.
// There is one for each IOPM.  It is located by subtracting
// 32 from the IOPM base in the Tss.
//
#define INT_DIRECTION_MAP_SIZE   32
typedef UCHAR   KINT_DIRECTION_MAP[INT_DIRECTION_MAP_SIZE];

#define IOPM_COUNT      1           // Number of i/o access maps that
                                    // exist (in addition to
                                    // IO_ACCESS_MAP_NONE)

#define IO_ACCESS_MAP_NONE 0

#define IOPM_SIZE           8192    // Size of map callers can set.

#define PIOPM_SIZE          8196    // Size of structure we must allocate
                                    // to hold it.

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

typedef struct _KiIoAccessMap {
    KINT_DIRECTION_MAP DirectionMap;
    UCHAR IoMap[PIOPM_SIZE];
} KIIO_ACCESS_MAP;


typedef struct _KTSS {

    USHORT  Backlink;
    USHORT  Reserved0;

    ULONG   Esp0;
    USHORT  Ss0;
    USHORT  Reserved1;

    ULONG   NotUsed1[4];

    ULONG   CR3;
    ULONG   Eip;
    ULONG   EFlags;
    ULONG   Eax;
    ULONG   Ecx;
    ULONG   Edx;
    ULONG   Ebx;
    ULONG   Esp;
    ULONG   Ebp;
    ULONG   Esi;
    ULONG   Edi;


    USHORT  Es;
    USHORT  Reserved2;

    USHORT  Cs;
    USHORT  Reserved3;

    USHORT  Ss;
    USHORT  Reserved4;

    USHORT  Ds;
    USHORT  Reserved5;

    USHORT  Fs;
    USHORT  Reserved6;

    USHORT  Gs;
    USHORT  Reserved7;

    USHORT  LDT;
    USHORT  Reserved8;

    USHORT  Flags;

    USHORT  IoMapBase;

    KIIO_ACCESS_MAP IoMaps[IOPM_COUNT];

    //
    // This is the Software interrupt direction bitmap associated with
    // IO_ACCESS_MAP_NONE
    //
    KINT_DIRECTION_MAP IntDirectionMap;
} KTSS, *PKTSS;


#define KiComputeIopmOffset(MapNumber)          \
    (MapNumber == IO_ACCESS_MAP_NONE) ?         \
        (USHORT)(sizeof(KTSS)) :                    \
        (USHORT)(FIELD_OFFSET(KTSS, IoMaps[MapNumber-1].IoMap))

// begin_windbgkd

//
// Special Registers for i386
//

#ifdef _X86_

typedef struct _DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

#include <pshpack4.h>

typedef struct _KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG64 Xcr0;
    ULONG ExceptionList;
    ULONG Reserved[3];
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

#include <poppack.h>

//
// Processor State frame: Before a processor freezes itself, it
// dumps the processor state to the processor state frame for
// debugger to examine.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _X86_

// end_windbgkd

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

//
// Define processor vendors.
//

//
// CPU_VIA is an alias to the legacy CPU_CENTAUR.  This allows x86
// code to parallel amd64 code.  CPU_CENTAUR is left for compat reasons,
// but CPU_VIA is the preferred identifier.
//

typedef enum {
    CPU_NONE,                // 0
    CPU_INTEL,               // 1
    CPU_AMD,                 // 2
    CPU_CYRIX,               // 3
    CPU_TRANSMETA,           // 4
    CPU_VIA,                 // 5
    CPU_CENTAUR = CPU_VIA,   // 5 (alias for CPU_VIA)
    CPU_RISE,                // 6
    CPU_UNKNOWN              // 7
} CPU_VENDORS;

#define MAXIMUM_CACHES 5

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;

    UCHAR LegacyNumber;
    UCHAR NestingLevel;
    USHORT BuildType;

    CCHAR CpuType;
    CCHAR CpuID;
    union {
        USHORT CpuStep;
        struct {
            UCHAR CpuStepping;
            UCHAR CpuModel;
        };
    };

    struct _KPROCESSOR_STATE ProcessorState;

    struct _KNODE *ParentNode;
    PSCHAR PriorityState;
    ULONG KernelReserved[14];
    ULONG HalReserved[16];
    ULONG CFlushSize;

//
// Processor thread and core information.
//

    UCHAR CoresPerPhysicalProcessor;
    UCHAR LogicalProcessorsPerCore;
    UCHAR CpuVendor;
    UCHAR PrcbPad0[1];
    ULONG MHz;


//
// Processor group and number information.
//

    UCHAR GroupIndex;
    UCHAR Group;
    UCHAR PrcbPad05[2];
    KAFFINITY GroupSetMember;
    ULONG Number;

//
// Processor tick information.
//

    BOOLEAN ClockOwner;
    union {
        UCHAR PendingTickFlags;

        struct {
            UCHAR PendingTick:1;
            UCHAR PendingBackupTick:1;
        };
    };

//
// Per processor lock queue entries.
//
// N.B. The following padding is such that the first lock entry falls in the
//      last eight bytes of a cache line.
//

    UCHAR PrcbPad10[6 + 64];
    KSPIN_LOCK_QUEUE LockQueue[LockQueueMaximumLock];

// End of the architecturally defined section of the PRCB.

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;


//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Certain fields in the TIB are not used in kernel mode. These include the
// stack limit, subsystem TIB, fiber data, arbitrary user pointer, and the
// self address of then PCR itself (another field has been added for that
// purpose). Therefore, these fields are overlaid with other data to get
// better cache locality.
//

    union {
        NT_TIB  NtTib;
        struct {
            struct _EXCEPTION_REGISTRATION_RECORD *Used_ExceptionList;
            PVOID Used_StackBase;
            ULONG MxCsr;
            PVOID TssCopy;
            ULONG ContextSwitches;
            KAFFINITY SetMemberCopy;
            PVOID Used_Self;
        };
    };

    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;                       // do not use 3 bytes after this as
                                        // HALs assume they are zero.
    ULONG   IRR;
    ULONG   IrrActive;
    ULONG   IDR;
    PVOID   KdVersionBlock;

    struct _KIDTENTRY *IDT;
    struct _KGDTENTRY *GDT;
    struct _KTSS      *TSS;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    KAFFINITY SetMember;
    ULONG   StallScaleFactor;
    UCHAR   SpareUnused;
    UCHAR   Number;


} KPCR, *PKPCR;


//
// bits defined in Eflags
//

#define EFLAGS_CF_MASK        0x00000001L
#define EFLAGS_PF_MASK        0x00000004L
#define EFLAGS_AF_MASK        0x00000010L
#define EFLAGS_ZF_MASK        0x00000040L
#define EFLAGS_SF_MASK        0x00000080L
#define EFLAGS_TF             0x00000100L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_OF_MASK        0x00000800L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_NT             0x00004000L
#define EFLAGS_RF             0x00010000L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_ID_MASK        0x00200000L

#define EFLAGS_USER_SANITIZE  0x003f4dd7L


#define INTERRUPT_FRAME    0
#define EXCEPTION_FRAME    1
#define SYSCALL_FRAME      2

#define TRAP_FRAME_TYPE(TrapFrame)  (TrapFrame->FrameType)

//
// Trap frame
//
//  NOTE - We deal only with 32bit registers, so the assembler equivalents
//         are always the extended forms.
//
//  NOTE - Unless you want to run like slow molasses everywhere in the
//         the system, this structure must be of DWORD length, DWORD
//         aligned, and its elements must all be DWORD aligned.
//
//  NOTE WELL   -
//
//      The i386 does not build stack frames in a consistent format, the
//      frames vary depending on whether or not a privilege transition
//      was involved.
//
//      In order to make NtContinue work for both user mode and kernel
//      mode callers, we must force a canonical stack.
//
//      If we're called from kernel mode, this structure is 8 bytes longer
//      than the actual frame!
//
//  WARNING:
//
//      KTRAP_FRAME_LENGTH needs to be 16byte integral (at present.)
//

typedef struct _KTRAP_FRAME {


//
// The following 3 fields are placed to make debugger backtraces work through
// a trap frame.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that wants ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    USHORT  TempSegCs;
    UCHAR   Logging;
    UCHAR   FrameType;
    ULONG   TempEsp;

//
//  Debug registers.
//

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

//
//  Segment registers
//

    ULONG   SegGs;
    ULONG   SegEs;
    ULONG   SegDs;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    UCHAR   PreviousPreviousMode;
    UCHAR   EntropyQueueDpc;                // decision whether to queue an entropy DPC
    UCHAR   Reserved[2];

    ULONG   MxCsr;                          // saved SSE control register

    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  FS is TIB/PCR pointer, is here to make save sequence easy
//

    ULONG   SegFs;

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.

    ULONG   V86Es;          // these will be present for all transitions from
    ULONG   V86Ds;          // V86 mode
    ULONG   V86Fs;
    ULONG   V86Gs;
} KTRAP_FRAME;


typedef KTRAP_FRAME *PKTRAP_FRAME;
typedef KTRAP_FRAME *PKEXCEPTION_FRAME;

#define KTRAP_FRAME_LENGTH  (sizeof(KTRAP_FRAME))
#define KTRAP_FRAME_ALIGN   (sizeof(ULONG))
#define KTRAP_FRAME_ROUND   (KTRAP_FRAME_ALIGN-1)

//
//  Bits forced to 0 in SegCs if Esp has been edited.
//
//  N.B. This bitmask must contain the mode mask so that usermode cannot
//       spoof the special FRAME_EDITED sentinel
//

#define FRAME_EDITED        (0xfff8 | MODE_MASK)

//
// Define the structure used to hold volatile XMM state during a trap.
// It is defined separately from the trap frame since it is 16-byte aligned.
//

typedef struct _KXMM_FRAME {
    M128A Xmm[8];
} KXMM_FRAME, *PKXMM_FRAME;


//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Spare0;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// Structure of AMD cache information returned by CPUID instruction
//

typedef union _AMD_L1_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR LineSize;
        UCHAR LinesPerTag;
        UCHAR Associativity;
        UCHAR Size;
    };
} AMD_L1_CACHE_INFO, *PAMD_L1_CACHE_INFO;

typedef union _AMD_L2_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR  LineSize;
        UCHAR  LinesPerTag   : 4;
        UCHAR  Associativity : 4;
        USHORT Size;
    };
} AMD_L2_CACHE_INFO, *PAMD_L2_CACHE_INFO;

typedef union _AMD_L3_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR  LineSize;
        UCHAR  LinesPerTag   : 4;
        UCHAR  Associativity : 4;
        USHORT Reserved : 2;
        USHORT Size : 14;
    };
} AMD_L3_CACHE_INFO, *PAMD_L3_CACHE_INFO;

//
// Structure of Intel deterministic cache information returned by
// CPUID instruction
//

typedef enum _INTEL_CACHE_TYPE {
    IntelCacheNull,
    IntelCacheData,
    IntelCacheInstruction,
    IntelCacheUnified,
    IntelCacheRam,
    IntelCacheTrace
} INTEL_CACHE_TYPE;

typedef union INTEL_CACHE_INFO_EAX {
    ULONG Ulong;
    struct {
        INTEL_CACHE_TYPE Type : 5;
        ULONG Level : 3;
        ULONG SelfInitializing : 1;
        ULONG FullyAssociative : 1;
        ULONG Reserved : 4;
        ULONG ThreadsSharing : 12;
        ULONG ProcessorCores : 6;
    };
} INTEL_CACHE_INFO_EAX, *PINTEL_CACHE_INFO_EAX;

typedef union INTEL_CACHE_INFO_EBX {
    ULONG Ulong;
    struct {
        ULONG LineSize      : 12;
        ULONG Partitions    : 10;
        ULONG Associativity : 10;
    };
} INTEL_CACHE_INFO_EBX, *PINTEL_CACHE_INFO_EBX;


//
// i386 Specific portions of Mm component.
//

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT 21
#define PPI_SHIFT 30

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12


//
// Define the number of PTEs and PDEs per page.
//

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512

//
// Define the highest user address and user probe address.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

#if defined(_LOCAL_COPY_USER_PROBE_ADDRESS_)

#define MM_USER_PROBE_ADDRESS _LOCAL_COPY_USER_PROBE_ADDRESS_

#if defined(__CONVERGED_WIN32K_DRIVER__)
extern DLLBASEEXPORT ULONG _LOCAL_COPY_USER_PROBE_ADDRESS_;
#else
extern ULONG _LOCAL_COPY_USER_PROBE_ADDRESS_;
#endif

#else

#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

#define MM_KSEG0_BASE       MM_SYSTEM_RANGE_START
#define MM_SYSTEM_SPACE_END 0xFFFFFFFF

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

// end_ntddk
// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_wdm
// begin_nthal

//
// 4MB at the top of VA space is reserved for the HAL's use.
//

#define HAL_VA_START 0xFFC00000
#define HAL_VA_SIZE  (4 * 1024 * 1024)


//
// Define virtual base and alternate virtual base of kernel.
//

#define KSEG0_BASE 0x80000000
#define ALTERNATE_BASE (0xe1000000 - 16 * 1024 * 1024)

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT 21
#define PPI_SHIFT 30

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define page directory and page base addresses.
//

#define PDE_BASE 0xC0600000
#define PTE_TOP  0xC07FFFFF
#define PDE_TOP  0xC0603FFF
#define PTE_BASE 0xC0000000


//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

//
// Convert various portable ExInterlock APIs into their architectural
// equivalents.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend,Lock) \
        Exfi386InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend,Lock) \
        Exfi386InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target,Value,Lock) \
        Exfi386InterlockedExchangeUlong(Target,Value)

#define ExInterlockedAddUlong           ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList

// end_wdm
// begin_ntddk

//
// Prototypes for architectural specific versions of Exi386 Api
//

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedIncrementLong (
    _Inout_ _Interlocked_operand_ LONG volatile *Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedDecrementLong (
    _Inout_ _Interlocked_operand_ LONG volatile *Addend
    );

NTKERNELAPI
ULONG
FASTCALL
Exfi386InterlockedExchangeUlong (
    _Inout_ _Interlocked_operand_ ULONG volatile *Target,
    _In_ ULONG Value
    );


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

// end_wdm

#pragma warning(push)


//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE
PKPRCB
NTAPI
KeGetCurrentPrcb (VOID)
{

    PKPRCB Prcb;

    Prcb = (PKPRCB) (ULONG_PTR) __readfsdword (FIELD_OFFSET (KPCR, Prcb));
    __assume(Prcb != NULL);
    return Prcb;
}

// begin_wdm

//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_saves_
NTHALAPI
KIRQL
NTAPI
KeGetCurrentIrql(
    VOID
    );

// end_wdm

//
// Structure to aid in booting secondary processors
//

#pragma pack(push,2)

typedef struct _FAR_JMP_16 {
    UCHAR  OpCode;  // = 0xe9
    USHORT Offset;
} FAR_JMP_16;

#pragma pack(pop)

#define PROCESSOR_START_FLAG_FORCE_ENABLE_NX 0x1

typedef struct _PROCESSOR_START_BLOCK *PPROCESSOR_START_BLOCK;
typedef struct _PROCESSOR_START_BLOCK {

    //
    // The block starts with a jmp instruction to the end of the block
    //

    FAR_JMP_16 Jmp;

    //
    // Completion flag is set to non-zero when the target processor has
    // started
    //

    ULONG CompletionFlag;

    //
    // Flags governing startup.
    //

    ULONG Flags;

    //
    // Physical address of the 64-bit top-level identity-mapped page table.
    //

    ULONG64 TiledMemoryMap;

    //
    // Linear address of this structure
    //

    PPROCESSOR_START_BLOCK SelfMap;

    //
    // Initial processor state for the processor to be started
    //

    KPROCESSOR_STATE ProcessorState;

} PROCESSOR_START_BLOCK;

// end_nthal
// begin_ntddk

//
// Get the current processor number
//

FORCEINLINE
ULONG
NTAPI
KeGetCurrentProcessorNumber(VOID)
{
    return (ULONG) __readfsbyte (FIELD_OFFSET (KPCR, Number));
}

// end_ntddk

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN7)

FORCEINLINE
ULONG
NTAPI
KeGetCurrentProcessorIndex (
    VOID
    )

{
    return (ULONG)__readfsbyte(0x51);
}

#endif


#pragma warning(pop)

// begin_wdm
#endif // !defined(MIDL_PASS) && defined(_M_IX86)


#ifdef __cplusplus
extern "C" {
#endif

//
// Define function to flush a cache line.
//

#define CacheLineFlush(Address) _mm_clflush(Address)

VOID
_mm_clflush (
    VOID const *Address
    );

#pragma intrinsic(_mm_clflush)

//
// Define function to invalidate a page.
//

#define InvalidatePage(Page) __invlpg(Page)

VOID
__invlpg (
    _In_ PVOID Page
    );

#define WritebackInvalidate() __wbinvd()

VOID
__wbinvd (
    VOID
    );

#pragma intrinsic(__invlpg)
#pragma intrinsic(__wbinvd)

//
// Define functions to read and write CR3.
//

#define ReadCR3() __readcr3()

ULONG
__readcr3 (
    VOID
    );

#define WriteCR3(Data) __writecr3(Data)

VOID
__writecr3 (
    _In_ UINT32 Data
    );

#pragma intrinsic(__readcr3)
#pragma intrinsic(__writecr3)

//
// Define function to get eflags.
//

UINT32
__readeflags (
    VOID
    );

#define ReadEflags() __readeflags()

#pragma intrinsic(__readeflags)

VOID
_ReadWriteBarrier(
    VOID
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(_ReadWriteBarrier)

#pragma prefast(push)
#pragma prefast(disable : 6001 28113, "The barrier variable is accessed only to create a side effect.")

FORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )
{
    LONG Barrier;

    InterlockedOr(&Barrier, 0);
    return;
}

#pragma prefast(pop)

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()


_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_When_(return>=0, _Kernel_float_saved_)
_At_(*FloatSave, _When_(return>=0, _Kernel_acquires_resource_(FloatState)))
NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    _Out_ PKFLOATING_SAVE FloatSave
    );

_Success_(1)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Kernel_float_restored_
_At_(*FloatSave, _Kernel_requires_resource_held_(FloatState) _Kernel_releases_resource_(FloatState))
NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    _In_ PKFLOATING_SAVE FloatSave
    );

// end_wdm
// begin_nthal

NTKERNELAPI
VOID
NTAPI
KeProfileInterruptWithSource (
    _In_ struct _KTRAP_FRAME *TrapFrame,
    _In_ KPROFILE_SOURCE ProfileSource
    );

// begin_ntddk begin_wdm begin_ntndis
// begin_ntoshvp

#endif // defined(_X86_)

// end_ntoshvp

#if defined (_X86_)                             
#define KF_MMX                      0x0000000000000100ui64  
#define KF_XMMI                     0x0000000000002000ui64  
#define KF_3DNOW                    0x0000000000004000ui64  
#define KF_XMMI64                   0x0000000000010000ui64  
#define KF_SSE3                     0x0000000000080000ui64  
#define KF_HDC                      0x0000000400000000ui64  
#endif                                          
#ifdef _X86_
VOID
NTAPI
Ke386SetLdtProcess (
    _In_ struct _KPROCESS  *Process,
    _In_ PLDT_ENTRY  Ldt,
    _In_ ULONG       Limit
    );

VOID
NTAPI
Ke386SetDescriptorProcess (
    _In_ struct _KPROCESS  *Process,
    _In_ ULONG       Offset,
    _In_ LDT_ENTRY   LdtEntry
    );

VOID
NTAPI
Ke386GetGdtEntryThread (
    _In_ struct _KTHREAD *Thread,
    _In_ ULONG Offset,
    _Out_ PKGDTENTRY Descriptor
    );

BOOLEAN
NTAPI
Ke386SetIoAccessMap (
    _In_range_(<, IOPM_COUNT) ULONG MapNumber,
    _In_reads_bytes_(IOPM_SIZE) PKIO_ACCESS_MAP IoAccessMap
    );

BOOLEAN
NTAPI
Ke386QueryIoAccessMap (
    _In_range_(<, IOPM_COUNT) ULONG MapNumber,
    _Out_writes_bytes_(IOPM_SIZE) PKIO_ACCESS_MAP IoAccessMap
    );

BOOLEAN
NTAPI
Ke386IoSetAccessProcess (
    _In_ struct _KPROCESS    *Process,
    _In_range_(<, IOPM_COUNT) ULONG  MapNumber
    );

VOID
NTAPI
KiEditIopmDpc (
    _In_ struct _KDPC *Dpc,
    _In_opt_ PVOID DeferredContext,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2
    );

BOOLEAN
NTAPI
Ki386GetSelectorParameters(
    _In_ USHORT Selector,
    _Out_ PULONG Flags,
    _Out_ PULONG Base,
    _Out_ PULONG Limit
    );

ULONG
Ki386DispatchOpcodeV86 (
    _In_ PKTRAP_FRAME TrapFrame
    );

ULONG
Ki386DispatchOpcode (
    _In_ PKTRAP_FRAME TrapFrame
    );

NTSTATUS
NTAPI
Ke386SetVdmInterruptHandler (
    _In_ struct _KPROCESS *Process,
    _In_ ULONG Interrupt,
    _In_ USHORT Selector,
    _In_ ULONG  Offset,
    _In_ BOOLEAN Gate32
    );

ULONG
KiGetCpuVendor(
    VOID
    );

#endif //_X86_  // irqls
#define INIT_BOOTDEVICE_LINKNAME L"\\Device\\BootDevice"
#define INIT_SYSTEMROOT_LINKNAME L"\\SystemRoot"
#define INIT_SYSTEMROOT_DLLPATH  "\\SystemRoot\\System32"
#define INIT_SYSTEMROOT_BINPATH  "\\SystemRoot\\System32"
extern const ULONG NtBuildNumber;

#if defined(_M_AMD64)

VOID
KeCompactServiceTable (
    _Inout_ PVOID Table,
    _In_ PVOID Arguments,
    _In_ ULONG limit,
    _In_ BOOLEAN Win32k
    );

VOID
KiLockServiceTable (
    _Inout_ PVOID Table,
    _In_ PVOID Arguments,
    _In_ ULONG limit,
    _In_ BOOLEAN Win32k
    );

VOID
KePersistMemory (
    _In_ PVOID VirtualAddress,
    _In_ SIZE_T NumberOfBytes
    );

//
// Image header machine architecture
//

#define IMAGE_FILE_MACHINE_NATIVE   0x8664

#endif

// begin_ntminiport

#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define intrinsic function to do in's and out's.
//

#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__inbyte (
    _In_ USHORT Port
    );

USHORT
__inword (
    _In_ USHORT Port
    );

ULONG
__indword (
    _In_ USHORT Port
    );

VOID
__outbyte (
    _In_ USHORT Port,
    _In_ UCHAR Data
    );

VOID
__outword (
    _In_ USHORT Port,
    _In_ USHORT Data
    );

VOID
__outdword (
    _In_ USHORT Port,
    _In_ ULONG Data
    );

VOID
__inbytestring (
    _In_ USHORT Port,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    );

VOID
__inwordstring (
    _In_ USHORT Port,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    );

VOID
__indwordstring (
    _In_ USHORT Port,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    );

VOID
__outbytestring (
    _In_ USHORT Port,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    );

VOID
__outwordstring (
    _In_ USHORT Port,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    );

VOID
__outdwordstring (
    _In_ USHORT Port,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    );

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)
#pragma intrinsic(__inbytestring)
#pragma intrinsic(__inwordstring)
#pragma intrinsic(__indwordstring)
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outwordstring)
#pragma intrinsic(__outdwordstring)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)
// end_ntminiport

#if defined(_AMD64_) // ntddk nthal irqls
//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;
typedef LONG64 SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG64 PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 19

//
// Indicate that the AMD64 compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1

//
// Define constants for bits in CR0.
//

#define CR0_PE 0x00000001               // protection enable
#define CR0_MP 0x00000002               // math present
#define CR0_EM 0x00000004               // emulate math coprocessor
#define CR0_TS 0x00000008               // task switched
#define CR0_ET 0x00000010               // extension type (80387)
#define CR0_NE 0x00000020               // numeric error
#define CR0_WP 0x00010000               // write protect
#define CR0_AM 0x00040000               // alignment mask
#define CR0_NW 0x20000000               // not write-through
#define CR0_CD 0x40000000               // cache disable
#define CR0_PG 0x80000000               // paging

//
// Define functions to read and write CR0.
//

#ifdef __cplusplus
extern "C" {
#endif

#define ReadCR0() __readcr0()

ULONG64
__readcr0 (
    VOID
    );

#define WriteCR0(Data) __writecr0(Data)

VOID
__writecr0 (
    _In_ ULONG64 Data
    );

#pragma intrinsic(__readcr0)
#pragma intrinsic(__writecr0)

//
// Define functions to read and write CR3.
//

#define ReadCR3() __readcr3()

ULONG64
__readcr3 (
    VOID
    );

#define WriteCR3(Data) __writecr3(Data)

VOID
__writecr3 (
    _In_ ULONG64 Data
    );

#pragma intrinsic(__readcr3)
#pragma intrinsic(__writecr3)

//
// Define constants for bits in CR4.
//

#define CR4_VME 0x00000001              // V86 mode extensions
#define CR4_PVI 0x00000002              // Protected mode virtual interrupts
#define CR4_TSD 0x00000004              // Time stamp disable
#define CR4_DE  0x00000008              // Debugging Extensions
#define CR4_PSE 0x00000010              // Page size extensions
#define CR4_PAE 0x00000020              // Physical address extensions
#define CR4_MCE 0x00000040              // Machine check enable
#define CR4_PGE 0x00000080              // Page global enable
#define CR4_PCE 0x00000100              // Performance monitor counter enable
#define CR4_FXSR 0x00000200             // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400         // XMMI used by OS
#define CR4_VMXE 0x00002000             // VMX enable
#define CR4_RDWRFSGSBASE 0x00010000     // RDWR FSGS Base enable = bit 16
#define CR4_XSAVE 0x00040000            // XSAVE/XRSTOR enable
#define CR4_SMEP 0x00100000             // SMEP enable
#define CR4_SMAP 0x00200000             // SMAP enable

//
// Define functions to read and write CR4.
//

#define ReadCR4() __readcr4()

ULONG64
__readcr4 (
    VOID
    );

#define WriteCR4(Data) __writecr4(Data)

VOID
__writecr4 (
    _In_ ULONG64 Data
    );

#pragma intrinsic(__readcr4)
#pragma intrinsic(__writecr4)

#define ReadXCR0() __xgetbv(0)
#define WriteXCR0(Mask) __xsetbv(0, Mask)

ULONG64
__xgetbv (
    _In_ ULONG Index
    );

VOID
__xsetbv(
    _In_ ULONG Index,
    _In_ ULONG64 Mask
    );

#pragma intrinsic(__xgetbv)
#pragma intrinsic(__xsetbv)

//
// Define functions to read and write debug registers.
//

#define ReadDR0() __readdr(0)
#define ReadDR1() __readdr(1)
#define ReadDR2() __readdr(2)
#define ReadDR3() __readdr(3)
#define ReadDR6() __readdr(6)
#define ReadDR7() __readdr(7)

unsigned __int64
__readdr (
    _In_ unsigned int Register
    );

#pragma intrinsic(__readdr)

#define WriteDR0(v) __writedr(0, v)
#define WriteDR1(v) __writedr(1, v)
#define WriteDR2(v) __writedr(2, v)
#define WriteDR3(v) __writedr(3, v)
#define WriteDR6(v) __writedr(6, v)
#define WriteDR7(v) __writedr(7, v)

void
__writedr (
    _In_ unsigned int Register,
    _In_ unsigned __int64 Value
    );

#pragma intrinsic(__writedr)

#ifdef __cplusplus
}
#endif

// end_nthal

// begin_irqls
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0                 // Passive release level
#define LOW_LEVEL 0                     // Lowest interrupt level
#define APC_LEVEL 1                     // APC interrupt level
#define DISPATCH_LEVEL 2                // Dispatcher level
#define CMCI_LEVEL 5                    // CMCI handler level

#define CLOCK_LEVEL 13                  // Interval clock level
#define IPI_LEVEL 14                    // Interprocessor interrupt level
#define DRS_LEVEL 14                    // Deferred Recovery Service level
#define POWER_LEVEL 14                  // Power failure level
#define PROFILE_LEVEL 15                // timer used for profiling.
#define HIGH_LEVEL 15                   // Highest interrupt level

// end_irqls

// begin_wdm
//
// Define functions to read and write CR8.
//
// CR8 is the APIC TPR register.
//

#ifdef __cplusplus
extern "C" {
#endif

#define ReadCR8() __readcr8()

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_saves_
ULONG64
__readcr8 (
    VOID
    );

#define WriteCR8(Data) __writecr8(Data)

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_raises_(Data)
VOID
__writecr8 (
    _In_ ULONG64 Data
    );

#pragma intrinsic(__readcr8)
#pragma intrinsic(__writecr8)

#ifdef __cplusplus
}
#endif

#define SYNCH_LEVEL (IPI_LEVEL-2)       
#define MODE_MASK 1                                                 

// begin_ntminiport

#if defined(_AMD64_) && !defined(DSF_DRIVER)

//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//

#ifdef __cplusplus
extern "C" {
#endif

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
ULONG64
READ_REGISTER_ULONG64 (
    _In_ _Notliteral_ volatile ULONG64 *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    _In_reads_(Count) _Notliteral_ volatile UCHAR *Register,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsb(Buffer, (PUCHAR)Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    _In_reads_(Count) _Notliteral_ volatile USHORT *Register,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsw(Buffer, (PUSHORT)Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    _In_reads_(Count) _Notliteral_ volatile ULONG *Register,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsd(Buffer, (PULONG)Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG64 (
    _In_reads_(Count) _Notliteral_ volatile ULONG64 *Register,
    _Out_writes_all_(Count) PULONG64 Buffer,
    _In_ ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsq(Buffer, (PULONG64)Register, Count);
    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register,
    _In_ UCHAR Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register,
    _In_ USHORT Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register,
    _In_ ULONG Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG64 (
    _In_ _Notliteral_ volatile ULONG64 *Register,
    _In_ ULONG64 Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    _Out_writes_(Count) _Notliteral_ volatile UCHAR *Register,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{

    __movsb((PUCHAR)Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    _Out_writes_(Count) _Notliteral_ volatile USHORT *Register,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{

    __movsw((PUSHORT)Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    _Out_writes_(Count) _Notliteral_ volatile ULONG *Register,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{

    __movsd((PULONG)Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG64 (
    _Out_writes_(Count) _Notliteral_ volatile ULONG64 *Register,
    _In_reads_(Count) PULONG64 Buffer,
    _In_ ULONG Count
    )
{

    __movsq((PULONG64)Register, Buffer, Count);
    FastFence();
    return;
}

// end_wudfpwdm

__forceinline
UCHAR
READ_PORT_UCHAR (
    _In_ _Notliteral_ PUCHAR Port
    )

{
    UCHAR Result;

    _ReadWriteBarrier();
    Result = __inbyte((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}

__forceinline
USHORT
READ_PORT_USHORT (
    _In_ _Notliteral_ PUSHORT Port
    )

{
    USHORT Result;

    _ReadWriteBarrier();
    Result = __inword((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}

__forceinline
ULONG
READ_PORT_ULONG (
    _In_ _Notliteral_ PULONG Port
    )

{
    ULONG Result;

    _ReadWriteBarrier();
    Result = __indword((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}


__forceinline
VOID
READ_PORT_BUFFER_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )

{
    _ReadWriteBarrier();
    __inbytestring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )

{
    _ReadWriteBarrier();
    __inwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    )

{
    _ReadWriteBarrier();
    __indwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _In_ UCHAR Value
    )

{
    _ReadWriteBarrier();
    __outbyte((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _In_ USHORT Value
    )

{
    _ReadWriteBarrier();
    __outword((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _In_ ULONG Value
    )

{
    _ReadWriteBarrier();
    __outdword((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )

{
    _ReadWriteBarrier();
    __outbytestring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )

{
    _ReadWriteBarrier();
    __outwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    )

{
    _ReadWriteBarrier();
    __outdwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

// begin_wudfpwdm

#ifdef __cplusplus
}
#endif

#endif

// end_ntminiport end_wudfpwdm

// end_ntndis
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

VOID
KeFlushIoBuffers (
    _In_ PMDL Mdl,
    _In_ BOOLEAN ReadOperation,
    _In_ BOOLEAN DmaOperation
    );

#else

#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

#endif


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

//
// AMD64 hardware structures
//
// A Page Table Entry on an AMD64 has the following definition.
//

#define _HARDWARE_PTE_WORKING_SET_BITS  11

typedef struct _HARDWARE_PTE {
    ULONG64 Valid : 1;
    ULONG64 Write : 1;                // UP version
    ULONG64 Owner : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 LargePage : 1;
    ULONG64 Global : 1;
    ULONG64 CopyOnWrite : 1;          // software field
    ULONG64 Prototype : 1;            // software field
    ULONG64 reserved0 : 1;            // software field
    ULONG64 PageFrameNumber : 36;
    ULONG64 reserved1 : 16 - (_HARDWARE_PTE_WORKING_SET_BITS+1);
    ULONG64 SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
    ULONG64 NoExecute : 1;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \
     *((PULONG64)(dirbase)) = (((ULONG64)(pfn)) << PAGE_SHIFT)

//
// Define Global Descriptor Table (GDT) entry structure and constants.
//
// Define descriptor type codes.
//
#define TYPE_LDT 0x02                     // 00010 = system ldt
#define TYPE_CODE 0x1B                  // 11011 = code, read only, accessed
#define TYPE_DATA 0x13                  // 10011 = data, read and write, accessed
#define TYPE_TSS64 0x09                 // 01001 = task state segment

//
// Define descriptor privilege levels for user and system.
//

#define DPL_USER 3
#define DPL_SYSTEM 0

//
// Define limit granularity.
//

#define GRANULARITY_BYTE 0
#define GRANULARITY_PAGE 1

//
// Define processor number packing constants.
//
// The compatibility processor number is encoded in the FS segment descriptor.
//
// Bits 19:14 of the segment limit encode the compatible processor number.
// Bits 13:10 are set to ones to ensure that segment limit is at least 15360.
// Bits 9:0 of the segment limit encode the extended processor number.
//

#define KGDT_LEGACY_LIMIT_SHIFT 14
#define KGDT_LIMIT_ENCODE_MASK (0xf << 10)

#define SELECTOR_TABLE_INDEX 0x04

typedef union _KGDTENTRY64 {
    struct {
        USHORT LimitLow;
        USHORT BaseLow;
        union {
            struct {
                UCHAR BaseMiddle;
                UCHAR Flags1;
                UCHAR Flags2;
                UCHAR BaseHigh;
            } Bytes;

            struct {
                ULONG BaseMiddle : 8;
                ULONG Type : 5;
                ULONG Dpl : 2;
                ULONG Present : 1;
                ULONG LimitHigh : 4;
                ULONG System : 1;
                ULONG LongMode : 1;
                ULONG DefaultBig : 1;
                ULONG Granularity : 1;
                ULONG BaseHigh : 8;
            } Bits;
        };

        ULONG BaseUpper;
        ULONG MustBeZero;
    };

    struct {
        LONG64 DataLow;
        LONG64 DataHigh;
    };

} KGDTENTRY64, *PKGDTENTRY64;

//
// Define Local Descriptor Table (LDT) entry structure and constants.
//

typedef struct _KLDTENTRY {
    USHORT LimitLow;
    USHORT BaseLow;
    union {
        struct {
            UCHAR BaseMid;
            UCHAR Flags1;
            UCHAR Flags2;
            UCHAR BaseHi;
        } Bytes;

        struct {
            ULONG BaseMid : 8;
            ULONG Type : 5;
            ULONG Dpl : 2;
            ULONG Pres : 1;
            ULONG LimitHi : 4;
            ULONG Sys : 1;
            ULONG Reserved_0 : 1;
            ULONG Default_Big : 1;
            ULONG Granularity : 1;
            ULONG BaseHi : 8;
        } Bits;
    } HighWord;
} KLDTENTRY, *PKLDTENTRY;

C_ASSERT((sizeof(KLDTENTRY) % sizeof(PVOID)) == 0);

#define KLDT_MAX_LENGTH (8192)
#define KLDT_MAX_SIZE (sizeof(KLDTENTRY) * KLDT_MAX_LENGTH)

//
// Define Interrupt Descriptor Table (IDT) entry structure and constants.
//

typedef union _KIDTENTRY64 {
   struct {
       USHORT OffsetLow;
       USHORT Selector;
       USHORT IstIndex : 3;
       USHORT Reserved0 : 5;
       USHORT Type : 5;
       USHORT Dpl : 2;
       USHORT Present : 1;
       USHORT OffsetMiddle;
       ULONG OffsetHigh;
       ULONG Reserved1;
   };

   ULONG64 Alignment;
} KIDTENTRY64, *PKIDTENTRY64;

//
// Define two union definitions used for parsing addresses into the
// component fields required by a GDT.
//

typedef union _KGDT_BASE {
    struct {
        USHORT BaseLow;
        UCHAR BaseMiddle;
        UCHAR BaseHigh;
        ULONG BaseUpper;
    };

    ULONG64 Base;
} KGDT_BASE, *PKGDT_BASE;

C_ASSERT(sizeof(KGDT_BASE) == sizeof(ULONG64));

typedef union _KGDT_LIMIT {
    struct {
        USHORT LimitLow;
        USHORT LimitHigh : 4;
        USHORT MustBeZero : 12;
    };

    ULONG Limit;
} KGDT_LIMIT, *PKGDT_LIMIT;

C_ASSERT(sizeof(KGDT_LIMIT) == sizeof(ULONG));

//
// Define Task State Segment (TSS) structure and constants.
//
// Task switches are not supported by the AMD64, but a task state segment
// must be present to define the kernel stack pointer and I/O map base.
//
// N.B. This structure is misaligned as per the AMD64 specification.
//
// N.B. The size of TSS must be <= 0xDFFF.
//

#pragma pack(push, 4)
typedef struct _KTSS64 {
    ULONG Reserved0;
    ULONG64 Rsp0;
    ULONG64 Rsp1;
    ULONG64 Rsp2;

    //
    // Element 0 of the Ist is reserved.
    //

    ULONG64 Ist[8];
    ULONG64 Reserved1;
    USHORT Reserved2;
    USHORT IoMapBase;
} KTSS64, *PKTSS64;
#pragma pack(pop)

C_ASSERT((sizeof(KTSS64) % sizeof(PVOID)) == 0);

#define TSS_IST_RESERVED 0
#define TSS_IST_PANIC 1
#define TSS_IST_MCA 2
#define TSS_IST_NMI 3

#define IO_ACCESS_MAP_NONE FALSE

#define KiComputeIopmOffset(Enable)  (sizeof(KTSS64))

// begin_windbgkd

#if defined(_AMD64_)

//
// Define pseudo descriptor structures for both 64- and 32-bit mode.
//

typedef struct _KDESCRIPTOR {
    USHORT Pad[3];
    USHORT Limit;
    PVOID Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KDESCRIPTOR32 {
    USHORT Pad[3];
    USHORT Limit;
    ULONG Base;
} KDESCRIPTOR32, *PKDESCRIPTOR32;

//
// Define special kernel registers and the initial MXCSR value.
//

typedef struct _KSPECIAL_REGISTERS {
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG MxCsr;
    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;
    ULONG64 Cr8;
    ULONG64 MsrGsBase;
    ULONG64 MsrGsSwap;
    ULONG64 MsrStar;
    ULONG64 MsrLStar;
    ULONG64 MsrCStar;
    ULONG64 MsrSyscallMask;
    ULONG64 Xcr0;
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Define processor state structure.
//

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    CONTEXT ContextFrame;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _AMD64_

// end_windbgkd

//
// Define processor vendors.
//

typedef enum {
    CPU_UNKNOWN,
    CPU_AMD,
    CPU_INTEL,
    CPU_VIA
} CPU_VENDORS;

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1

#define PRCB_BUILD_DEBUG 0x1
#define PRCB_BUILD_UNIPROCESSOR 0x2

#define MAXIMUM_CACHES 5

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    ULONG MxCsr;
    UCHAR LegacyNumber;
    UCHAR ReservedMustBeZero;
    BOOLEAN InterruptRequest;
    BOOLEAN IdleHalt;
    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    UCHAR NestingLevel;
    BOOLEAN ClockOwner;
    union {
        UCHAR PendingTickFlags;
        struct {
            UCHAR PendingTick : 1;
            UCHAR PendingBackupTick : 1;
        };
    };

    UCHAR IdleState;
    ULONG Number;
    ULONG64 RspBase;
    KSPIN_LOCK PrcbLock;
    PSCHAR PriorityState;
    KPROCESSOR_STATE ProcessorState;
    CCHAR CpuType;
    CCHAR CpuID;
    union {
        USHORT CpuStep;
        struct {
            UCHAR CpuStepping;
            UCHAR CpuModel;
        };
    };

    ULONG MHz;
    ULONG64 HalReserved[8];
    USHORT MinorVersion;
    USHORT MajorVersion;
    UCHAR BuildType;
    UCHAR CpuVendor;
    UCHAR CoresPerPhysicalProcessor;
    UCHAR LogicalProcessorsPerCore;

//
// Constant scheduling data. 64-byte aligned.
//

    struct _KNODE *ParentNode;
    KAFFINITY GroupSetMember;
    UCHAR Group;
    UCHAR GroupIndex;
    UCHAR PrcbPad05[2];
    ULONG InitialApicId;
    ULONG ScbOffset;
    ULONG ApicMask;
    PVOID AcpiReserved;
    ULONG CFlushSize;
    ULONG PrcbPad10;

//
// End of the architecturally defined section of the PRCB.
//

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

C_ASSERT(FIELD_OFFSET(KPRCB, HalReserved) == 0x5F8);  // Do not move field
C_ASSERT(FIELD_OFFSET(KPRCB, AcpiReserved) == 0x660); // Do not move field


//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Certain fields in the TIB are not used in kernel mode. These include the
// exception list, stack base, stack limit, subsystem TIB, fiber data, and
// the arbitrary user pointer. Therefore, these fields are overlaid with
// other data to get better cache locality.
//
// N.B. The offset to the PRCB in the PCR is fixed for all time.
//

    union {
        NT_TIB NtTib;
        struct {
            union _KGDTENTRY64 *GdtBase;
            struct _KTSS64 *TssBase;
            ULONG64 UserRsp;
            struct _KPCR *Self;
            struct _KPRCB *CurrentPrcb;
            PKSPIN_LOCK_QUEUE LockArray;
            PVOID Used_Self;
        };
    };

    union _KIDTENTRY64 *IdtBase;
    ULONG64 Unused[2];
    KIRQL Irql;
    UCHAR SecondLevelCacheAssociativity;
    UCHAR ObsoleteNumber;
    UCHAR Fill0;
    ULONG Unused0[3];
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG StallScaleFactor;
    PVOID Unused1[3];

    ULONG KernelReserved[15];
    ULONG SecondLevelCacheSize;
    ULONG HalReserved[16];
    ULONG Unused2;
    PVOID KdVersionBlock;
    PVOID Unused3;
    ULONG PcrAlign1[24];

// end_ntddk

    KPRCB Prcb;

//
// End of the architecturally defined section of the PCR.
//

} KPCR, *PKPCR;

//
// Define legacy floating status word bit masks.
//

#define FSW_INVALID_OPERATION 0x1
#define FSW_DENORMAL 0x2
#define FSW_ZERO_DIVIDE 0x4
#define FSW_OVERFLOW 0x8
#define FSW_UNDERFLOW 0x10
#define FSW_PRECISION 0x20
#define FSW_STACK_FAULT 0x40
#define FSW_ERROR_SUMMARY 0x80
#define FSW_CONDITION_CODE_0 0x100
#define FSW_CONDITION_CODE_1 0x200
#define FSW_CONDITION_CODE_2 0x400
#define FSW_CONDITION_CODE_3 0x4000

#define FSW_ERROR_MASK (FSW_INVALID_OPERATION | FSW_DENORMAL |              \
                        FSW_ZERO_DIVIDE | FSW_OVERFLOW | FSW_UNDERFLOW |    \
                        FSW_PRECISION)

//
// Define MxCsr floating control/mode/status word bit masks.
//
// No flush to zero, round to nearest, and all exception masked.
//

#define XSW_INVALID_OPERATION 0x1
#define XSW_DENORMAL 0x2
#define XSW_ZERO_DIVIDE 0x4
#define XSW_OVERFLOW 0x8
#define XSW_UNDERFLOW 0x10
#define XSW_PRECISION 0x20

#define XSW_ERROR_MASK (XSW_INVALID_OPERATION |  XSW_DENORMAL |             \
                        XSW_ZERO_DIVIDE | XSW_OVERFLOW | XSW_UNDERFLOW |    \
                        XSW_PRECISION)

#define XSW_ERROR_SHIFT 7

#define XCW_DAZ 0x40
#define XCW_INVALID_OPERATION 0x80
#define XCW_DENORMAL 0x100
#define XCW_ZERO_DIVIDE 0x200
#define XCW_OVERFLOW 0x400
#define XCW_UNDERFLOW 0x800
#define XCW_PRECISION 0x1000
#define XCW_ROUND_CONTROL 0x6000
#define XCW_FLUSH_ZERO 0x8000

//
// Define EFLAG bit masks and shift offsets.
//

#define EFLAGS_CF_MASK 0x00000001       // carry flag
#define EFLAGS_PF_MASK 0x00000004       // parity flag
#define EFLAGS_AF_MASK 0x00000010       // auxiliary carry flag
#define EFLAGS_ZF_MASK 0x00000040       // zero flag
#define EFLAGS_SF_MASK 0x00000080       // sign flag
#define EFLAGS_TF_MASK 0x00000100       // trap flag
#define EFLAGS_IF_MASK 0x00000200       // interrupt flag
#define EFLAGS_DF_MASK 0x00000400       // direction flag
#define EFLAGS_OF_MASK 0x00000800       // overflow flag
#define EFLAGS_IOPL_MASK 0x00003000     // I/O privilege level
#define EFLAGS_NT_MASK 0x00004000       // nested task
#define EFLAGS_RF_MASK 0x00010000       // resume flag
#define EFLAGS_VM_MASK 0x00020000       // virtual 8086 mode
#define EFLAGS_AC_MASK 0x00040000       // alignment check
#define EFLAGS_VIF_MASK 0x00080000      // virtual interrupt flag
#define EFLAGS_VIP_MASK 0x00100000      // virtual interrupt pending
#define EFLAGS_ID_MASK 0x00200000       // identification flag

#define EFLAGS_TF_SHIFT 8               // trap
#define EFLAGS_IF_SHIFT 9               // interrupt enable

#define EFLAGS_SYSCALL_CLEAR (EFLAGS_IF_MASK | EFLAGS_DF_MASK |              \
                              EFLAGS_TF_MASK | EFLAGS_NT_MASK)

// end_nthal

//
// Structure of AMD cache information returned by CPUID instruction
//

typedef union _AMD_L1_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR LineSize;
        UCHAR LinesPerTag;
        UCHAR Associativity;
        UCHAR Size;
    };
} AMD_L1_CACHE_INFO, *PAMD_L1_CACHE_INFO;

typedef union _AMD_L2_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR  LineSize;
        UCHAR  LinesPerTag   : 4;
        UCHAR  Associativity : 4;
        USHORT Size;
    };
} AMD_L2_CACHE_INFO, *PAMD_L2_CACHE_INFO;

typedef union _AMD_L3_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR  LineSize;
        UCHAR  LinesPerTag   : 4;
        UCHAR  Associativity : 4;
        USHORT Reserved : 2;
        USHORT Size : 14;
    };
} AMD_L3_CACHE_INFO, *PAMD_L3_CACHE_INFO;

//
// Structure of Via cache information returned by CPUID instruction
//

typedef union _VIA_L1_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR LineSize;
        UCHAR LinesPerTag;
        UCHAR Associativity;
        UCHAR Size;
    };
} VIA_L1_CACHE_INFO, *PVIA_L1_CACHE_INFO;

typedef union _VIA_L2_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR LineSize;
        UCHAR LinesPerTag   : 4;
        UCHAR Associativity : 4;
        USHORT Size;
    };
} VIA_L2_CACHE_INFO, *PVIA_L2_CACHE_INFO;

//
// Structure of Intel deterministic cache information returned by
// CPUID instruction
//

typedef enum _INTEL_CACHE_TYPE {
    IntelCacheNull,
    IntelCacheData,
    IntelCacheInstruction,
    IntelCacheUnified,
    IntelCacheRam,
    IntelCacheTrace
} INTEL_CACHE_TYPE;

typedef union INTEL_CACHE_INFO_EAX {
    ULONG Ulong;
    struct {
        INTEL_CACHE_TYPE Type : 5;
        ULONG Level : 3;
        ULONG SelfInitializing : 1;
        ULONG FullyAssociative : 1;
        ULONG Reserved : 4;
        ULONG ThreadsSharing : 12;
        ULONG ProcessorCores : 6;
    };
} INTEL_CACHE_INFO_EAX, *PINTEL_CACHE_INFO_EAX;

typedef union INTEL_CACHE_INFO_EBX {
    ULONG Ulong;
    struct {
        ULONG LineSize      : 12;
        ULONG Partitions    : 10;
        ULONG Associativity : 10;
    };
} INTEL_CACHE_INFO_EBX, *PINTEL_CACHE_INFO_EBX;

//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all nonvolatile registers. The volatile registers will already
//  have been saved in a trap frame.
//
// N.B. The exception frame has a built in exception record capable of
//      storing information for four parameter values. This exception
//      record is used exclusively within the trap handling code.
//

typedef struct _KEXCEPTION_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;
    ULONG64 Spare1;

//
// Saved nonvolatile floating registers.
//

    M128A Xmm6;
    M128A Xmm7;
    M128A Xmm8;
    M128A Xmm9;
    M128A Xmm10;
    M128A Xmm11;
    M128A Xmm12;
    M128A Xmm13;
    M128A Xmm14;
    M128A Xmm15;

//
// Kernel callout frame variables.
//

    ULONG64 TrapFrame;
    ULONG64 OutputBuffer;
    ULONG64 OutputLength;
    ULONG64 Spare2;

//
// Saved MXCSR when a thread is interrupted in kernel mode via a dispatch
// interrupt.
//

    ULONG64 MxCsr;

//
// Saved nonvolatile register - not always saved.
//

    ULONG64 Rbp;

//
// Saved nonvolatile registers.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;
    ULONG64 R12;
    ULONG64 R13;
    ULONG64 R14;
    ULONG64 R15;

//
// EFLAGS and return address.
//

    ULONG64 Return;
} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

// end_ntddk
// begin_nthal

#define KEXCEPTION_FRAME_LENGTH sizeof(KEXCEPTION_FRAME)

C_ASSERT((sizeof(KEXCEPTION_FRAME) & STACK_ROUND) == 0);
C_ASSERT(FIELD_OFFSET(KEXCEPTION_FRAME, Return) == KEXCEPTION_FRAME_LENGTH - 8);

#define EXCEPTION_RECORD_LENGTH ((sizeof(EXCEPTION_RECORD) + STACK_ROUND) & ~STACK_ROUND)

//
// Machine Frame
//
// This frame is established by code that trampolines to user mode (e.g. user
// APC, user callback, dispatch user exception, etc.). The purpose of this
// frame is to allow unwinding through these callbacks if an exception occurs.
//
// N.B. This frame is identical to the frame that is pushed for a trap without
//      an error code and is identical to the hardware part of a trap frame.
//

typedef struct _MACHINE_FRAME {
    ULONG64 Rip;
    USHORT SegCs;
    USHORT Fill1[3];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3[3];
} MACHINE_FRAME, *PMACHINE_FRAME;

#define MACHINE_FRAME_LENGTH sizeof(MACHINE_FRAME)

C_ASSERT((sizeof(MACHINE_FRAME) & STACK_ROUND) == 8);

//
// Switch Frame
//
// This frame is established by the code that switches context from one
// thread to the next and is used by the thread initialization code to
// construct a stack that will start the execution of a thread in the
// thread start up code.
//

typedef struct _KSWITCH_FRAME {
    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5Home;
    KIRQL ApcBypass;
    UCHAR Fill1[7];
    ULONG64 Rbp;
    ULONG64 Return;
} KSWITCH_FRAME, *PKSWITCH_FRAME;

#define KSWITCH_FRAME_LENGTH sizeof(KSWITCH_FRAME)

C_ASSERT((sizeof(KSWITCH_FRAME) & STACK_ROUND) == 0);

//
// Start system thread frame.
//
// This frame is established by the AMD64 specific thread initialization
// code. It is used to store the initial context for starting a system
// thread.
//

typedef struct _KSTART_FRAME {
    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 Reserved;
    ULONG64 Return;
} KSTART_FRAME, *PKSTART_FRAME;

#define KSTART_FRAME_LENGTH sizeof(KSTART_FRAME)

C_ASSERT((sizeof(KSTART_FRAME) & STACK_ROUND) == 0);

// end_nthal
// begin_ntddk
//
// Trap frame
//
// This frame is established when handling a trap. It provides a place to
// save all volatile registers. The nonvolatile registers are saved in an
// exception frame or through the normal C calling conventions for saved
// registers.
//

typedef struct _KTRAP_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Previous processor mode (system services only) and previous IRQL
// (interrupts only).
//

    KPROCESSOR_MODE PreviousMode;
    KIRQL PreviousIrql;

//
// Page fault load/store indicator.
//

    UCHAR FaultIndicator;

//
// Exception active indicator.
//
//    0 - interrupt frame.
//    1 - exception frame.
//    2 - service frame.
//

    UCHAR ExceptionActive;

//
// Floating point state.
//

    ULONG MxCsr;

//
//  Volatile registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;

//
// Gsbase is only used if the previous mode was kernel.
//
// GsSwap is only used if the previous mode was user.
//

    union {
        ULONG64 GsBase;
        ULONG64 GsSwap;
    };

//
// Volatile floating registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    M128A Xmm0;
    M128A Xmm1;
    M128A Xmm2;
    M128A Xmm3;
    M128A Xmm4;
    M128A Xmm5;

//
// First parameter, page fault address, context record address if user APC
// bypass, or time stamp value.
//

    union {
        ULONG64 FaultAddress;
        ULONG64 ContextRecord;
        ULONG64 TimeStampCKCL;
    };

//
//  Debug registers.
//

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

//
// Special debug registers.
//

    struct {
        ULONG64 DebugControl;
        ULONG64 LastBranchToRip;
        ULONG64 LastBranchFromRip;
        ULONG64 LastExceptionToRip;
        ULONG64 LastExceptionFromRip;
    };

//
//  Segment registers
//

    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;

//
// Previous trap frame address.
//

    ULONG64 TrapFrame;

//
// Saved nonvolatile registers RBX, RDI and RSI. These registers are only
// saved in system service trap frames.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;

//
// Saved nonvolatile register RBP. This register is used as a frame
// pointer during trap processing and is saved in all trap frames.
//

    ULONG64 Rbp;

//
// Information pushed by hardware.
//
// N.B. The error code is not always pushed by hardware. For those cases
//      where it is not pushed by hardware a dummy error code is allocated
//      on the stack.
//

    union {
        ULONG64 ErrorCode;
        ULONG64 ExceptionFrame;
        ULONG64 TimeStampKlog;
    };

    ULONG64 Rip;
    USHORT SegCs;
    UCHAR Fill0;
    UCHAR Logging;
    USHORT Fill1[2];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3;
    ULONG Fill4;
} KTRAP_FRAME, *PKTRAP_FRAME;

typedef struct _KUMS_CONTEXT_HEADER {
    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    PVOID StackTop;
    ULONG64 StackSize;
    ULONG64 RspOffset;
    ULONG64 Rip;
    PXMM_SAVE_AREA32 FltSave;
#define KUMS_UCH_VOLATILE_BIT (0)
#define KUMS_UCH_VOLATILE_MASK (1ULL << KUMS_UCH_VOLATILE_BIT)
    union {
        struct {
            ULONG64 Volatile : 1;
            ULONG64 Reserved : 63;
        };
        ULONG64 Flags;
    };
    PKTRAP_FRAME TrapFrame;
    PKEXCEPTION_FRAME ExceptionFrame;
    struct _KTHREAD *SourceThread;
    ULONG64 Return;
} KUMS_CONTEXT_HEADER, *PKUMS_CONTEXT_HEADER;

// end_ntddk

//
// Define TrapFrame->ExceptionActive constants.
//

#define KEXCEPTION_ACTIVE_INTERRUPT_FRAME 0
#define KEXCEPTION_ACTIVE_EXCEPTION_FRAME 1
#define KEXCEPTION_ACTIVE_SERVICE_FRAME   2

// begin_nthal

#define KTRAP_FRAME_LENGTH sizeof(KTRAP_FRAME)

C_ASSERT((sizeof(KTRAP_FRAME) & STACK_ROUND) == 0);

//
// Ensure that KTRAP_FRAME isn't padded by the compiler.
//

C_ASSERT(RTL_SIZEOF_THROUGH_FIELD(KTRAP_FRAME, Fill4) == sizeof(KTRAP_FRAME));

#define KUMS_CONTEXT_HEADER_LENGTH sizeof(KUMS_CONTEXT_HEADER)

C_ASSERT((sizeof(KUMS_CONTEXT_HEADER) & STACK_ROUND) == 0);
//
// Profile, update run time, and update system time interrupt routines.
//

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    _In_ PKTRAP_FRAME TrapFrame,
    _In_ KPROFILE_SOURCE ProfileSource
    );

// end_nthal

//
// The frame saved by the call out to user mode code is defined here to allow
// the kernel debugger to trace the entire kernel stack when user mode callouts
// are active.
//
// N.B. The kernel callout frame is the same as an exception frame.
//

typedef KEXCEPTION_FRAME KCALLOUT_FRAME;
typedef PKEXCEPTION_FRAME PKCALLOUT_FRAME;

typedef struct _UCALLOUT_FRAME {
    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    MACHINE_FRAME MachineFrame;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;

C_ASSERT((sizeof(UCALLOUT_FRAME) & STACK_ROUND) == 8);

// begin_wdm
//
// Dummy nonvolatile floating state structure.
//

typedef struct _KFLOATING_SAVE {
    ULONG Dummy;
} KFLOATING_SAVE, *PKFLOATING_SAVE;


//
// AMD64 Specific portions of Mm component.
//

#define PXE_BASE          0xFFFFF6FB7DBED000UI64
#define PXE_SELFMAP       0xFFFFF6FB7DBEDF68UI64
#define PPE_BASE          0xFFFFF6FB7DA00000UI64
#define PDE_BASE          0xFFFFF6FB40000000UI64
#define PTE_BASE          0xFFFFF68000000000UI64

#define PXE_TOP           0xFFFFF6FB7DBEDFFFUI64
#define PPE_TOP           0xFFFFF6FB7DBFFFFFUI64
#define PDE_TOP           0xFFFFF6FB7FFFFFFFUI64
#define PTE_TOP           0xFFFFF6FFFFFFFFFFUI64

#define PDE_KTBASE_AMD64  PPE_BASE

#define PTI_SHIFT 12
#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PXI_SHIFT 39

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512

#define PTI_MASK_AMD64 (PTE_PER_PAGE - 1)
#define PDI_MASK_AMD64 (PDE_PER_PAGE - 1)
#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

// begin_ntddk

//
// Define the last branch control MSR address.
//

extern NTKERNELAPI ULONG KeLastBranchMSR;

//
// Define the highest user address and user probe address.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG64 MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// Allow non-kernel components to capture the user probe address and use a
// local copy for efficiency.
//

#if defined(_LOCAL_COPY_USER_PROBE_ADDRESS_)

#define MM_USER_PROBE_ADDRESS _LOCAL_COPY_USER_PROBE_ADDRESS_

#if defined(__CONVERGED_WIN32K_DRIVER__)
extern DLLBASEEXPORT ULONG64 _LOCAL_COPY_USER_PROBE_ADDRESS_;
#else
extern ULONG64 _LOCAL_COPY_USER_PROBE_ADDRESS_;
#endif

#else

#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)(LONG_PTR)0x10000

// end_ntddk
// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_wdm

//
// Define sanitize EFLAGS inlined function.
//
// If kernel mode, then
//      caller can specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Interrupt, Direction, Overflow, and identification.
//
// If user mode, then
//      caller can specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Interrupt, Direction, Overflow, identification, but Interrupt
//      will always be forced on.
//

#define EFLAGS_SANITIZE 0x00210fd5L

__forceinline
ULONG
SANITIZE_EFLAGS(ULONG eFlags, MODE mode)
{
    return ((mode) == KernelMode ?
                ((eFlags) & EFLAGS_SANITIZE) :
                (((eFlags) & EFLAGS_SANITIZE) | EFLAGS_IF_MASK));
}

//
// Define sanitize debug register macros.
//
// Define control register settable bits and active mask.
//

#define DR7_LEGAL 0xffff0355
#define DR7_ACTIVE 0x0355
#define DR7_TRACE_BRANCH 0x200
#define DR7_LAST_BRANCH 0x100

//
// Define macro to sanitize the debug control register.
//

#define SANITIZE_DR7(Dr7, mode) ((Dr7) & DR7_LEGAL)

//
// Define inlined function to santitize debug address registers.
//

__forceinline
ULONGLONG
SANITIZE_DRADDR(ULONGLONG DrReg, MODE mode)
{
    return ((mode) == KernelMode ?
                 (DrReg) :
                 (((PVOID)(DrReg) <= MM_HIGHEST_USER_ADDRESS) ? (DrReg) : 0));
}

//
// Define macro to clear reserved bits from MXCSR.
//

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & KiMxCsrMask)

//
// Define macro to clear reserved bits for legacy FP control word.
//

#define SANITIZE_FCW(_fcw_) ((_fcw_) & 0x1f3f)


//
// Intrinsic functions
//

#if defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)

//
// The following routines are provided for backward compatibility with old
// code. They are no longer the preferred way to accomplish these functions.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

#define ExInterlockedDecrementLong(Addend, Lock)                            \
    _ExInterlockedDecrementLong(Addend)

_Post_satisfies_(return >= 0 && return <= 2)
__forceinline
LONG
_ExInterlockedDecrementLong (
    _Inout_ _Interlocked_operand_ PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedDecrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedIncrementLong(Addend, Lock)                            \
    _ExInterlockedIncrementLong(Addend)

_Post_satisfies_(return >= 0 && return <= 2)
__forceinline
LONG
_ExInterlockedIncrementLong (
    _Inout_ _Interlocked_operand_ PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedIncrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedExchangeUlong(Target, Value, Lock)                     \
    _ExInterlockedExchangeUlong(Target, Value)

__forceinline
ULONG
_ExInterlockedExchangeUlong (
    _Inout_ _Interlocked_operand_ PULONG Target,
    _In_ ULONG Value
    )

{

    return (ULONG)InterlockedExchange((PLONG)Target, (LONG)Value);
}

#endif // defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)


#if !defined(MIDL_PASS) && defined(_M_AMD64)

//
// AMD646 function prototype definitions
//

// end_nthal
//
// Get address of current processor block.
//

__forceinline
PKPCR
KeGetPcr (
    VOID
    )

{
    return (PKPCR)__readgsqword(FIELD_OFFSET(KPCR, Self));
}

// end_ntddk begin_nthal
//
// Get address of current processor block.
//

CFORCEINLINE
PKPRCB
KeGetCurrentPrcb (
    VOID
    )

{
    PKPRCB Prcb;

    Prcb = (PKPRCB)(PVOID)__readgsqword(FIELD_OFFSET(KPCR, CurrentPrcb));
    __assume(Prcb != NULL);
    return Prcb;
}

// end_nthal
// begin_ntddk

#if (NTDDI_VERSION < NTDDI_WIN7) || !defined(NT_PROCESSOR_GROUPS)

//
// Get the current legacy processor number
//

__forceinline
ULONG
KeGetCurrentProcessorNumber (
    VOID
    )

{

    return (ULONG)__readgsbyte(0x184);
}

#endif

// end_ntddk

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN7)

__forceinline
ULONG
KeGetCurrentProcessorIndex (
    VOID
    )

{

    return __readgsdword(0x1a4);
}

#endif

// end_wdm
// begin_nthal

NTKERNELAPI
PKPRCB
KeQueryPrcbAddress (
    _In_ ULONG Number
    );


#endif // !defined(MIDL_PASS) && defined(_M_AMD64)


#if !defined(_CROSS_PLATFORM_)

CFORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )

/*++

Routine Description:

    This function orders memory accesses as seen by other processors.

Arguments:

    None.

Return Value:

    None.

--*/

{

    FastFence();
    return;
}

//++
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function instructs the compiler not to reorder loads and stores
//    across the function invocation.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

#else

#define KeMemoryBarrier()
#define KeMemoryBarrierWithoutFence()

#endif


_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_When_(return>=0, _Kernel_float_saved_)
_At_(*FloatSave, _When_(return>=0, _Kernel_acquires_resource_(FloatState)))
__forceinline
NTSTATUS
KeSaveFloatingPointState (
    _Out_ PKFLOATING_SAVE FloatSave
    )

#pragma warning (suppress:28104 28161 6001 6101) // PFD can't recognize the implementation
{

    UNREFERENCED_PARAMETER(FloatSave);

    return STATUS_SUCCESS;
}

_Success_(1)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Kernel_float_restored_
_At_(*FloatSave, _Kernel_requires_resource_held_(FloatState) _Kernel_releases_resource_(FloatState))
__forceinline
NTSTATUS
KeRestoreFloatingPointState (
    _In_ PKFLOATING_SAVE FloatSave
    )

#pragma warning (suppress:28103 28162) // PFD can't recognize the implementation
{

    UNREFERENCED_PARAMETER(FloatSave);

    return STATUS_SUCCESS;
}


#endif // defined(_AMD64_)


//
// Platform specific kernel fucntions to raise and lower IRQL.
//


#if defined(_AMD64_) && !defined(MIDL_PASS)
// end_ntddk

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_saves_
CFORCEINLINE
KIRQL
KeGetCurrentIrql (
    VOID
    )

/*++

Routine Description:

    This function return the current IRQL.

Arguments:

    None.

Return Value:

    The current IRQL is returned as the function value.

--*/

{

    return (KIRQL)ReadCR8();
}

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

#if ((NTDDI_VERSION >= NTDDI_WIN8) && \
     (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_) || defined(_BLDR_)))

_IRQL_requires_max_(HIGH_LEVEL)
NTKERNELAPI
VOID
KeLowerIrql (
    _In_ _Notliteral_ _IRQL_restores_ KIRQL NewIrql
   );

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_raises_(NewIrql)
_IRQL_saves_
NTKERNELAPI
KIRQL
KfRaiseIrql (
    _In_ KIRQL NewIrql
    );

#else

_IRQL_requires_max_(HIGH_LEVEL)
CFORCEINLINE
VOID
KzLowerIrql (
    _In_ _Notliteral_ _IRQL_restores_ KIRQL NewIrql
   )

/*++

Routine Description:

    This function lowers the IRQL to the specified value.

Arguments:

    NewIrql  - Supplies the new IRQL value.

Return Value:

    None.

--*/

{

    NT_ASSERT(KeGetCurrentIrql() >= NewIrql);

    WriteCR8(NewIrql);
    return;
}

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_raises_(NewIrql)
_IRQL_saves_
CFORCEINLINE
KIRQL
KzRaiseIrql (
    _In_ KIRQL NewIrql
    )

/*++

Routine Description:

    This function raises the current IRQL to the specified value and returns
    the previous IRQL.

Arguments:

    NewIrql (cl) - Supplies the new IRQL value.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    NT_ASSERT(OldIrql <= NewIrql);

    WriteCR8(NewIrql);
    return OldIrql;
}

#define KeLowerIrql KzLowerIrql
#define KfRaiseIrql KzRaiseIrql

#endif


_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
__forceinline
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to DPC_LEVEL and returns the
    previous IRQL.

Arguments:

    None.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(DISPATCH_LEVEL);
}

_IRQL_saves_
_IRQL_raises_(12)
__forceinline
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to SYNCH_LEVEL and returns the
    previous IRQL.

Arguments:

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(12);
}

// begin_wdm
#endif // defined(_AMD64_) && !defined(MIDL_PASS)


#if defined (_AMD64_)                                   
#define KF_MMX                      0x0000000000000100ui64  
#define KF_XMMI                     0x0000000000002000ui64  
#define KF_3DNOW                    0x0000000000004000ui64  
#define KF_XMMI64                   0x0000000000010000ui64  
#define KF_SSE3                     0x0000000000080000ui64  
#define KF_HDC                      0x0000008000000000ui64  
#endif                                                  
// begin_ntminiport

#if defined(_M_ARM) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#endif // defined(_M_ARM) && !defined(RC_INVOKED) && !defined(MIDL_PASS)
// end_ntminiport

#if defined(_ARM_) // ntddk nthal irqls

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;
typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Maximum number of event counters in performance monitoring unit.
//

#define MAX_EVENT_COUNTERS 31

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 32

//
// Indicate that the ARM compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1

//


//
// CPSR mode constants
//

#define CPSRM_USER 0x10
#define CPSRM_FIQ  0x11
#define CPSRM_INT  0x12
#define CPSRM_SVC  0x13
#define CPSRM_ABT  0x17
#define CPSRM_UDF  0x1B
#define CPSRM_SYS  0x1F

#define CPSRM_MASK 0x1F

//
// CSPR enable/disables
//

#define CPSRC_ABORT 0x100
#define CPSRC_INT   0x80
#define CPSRC_THUMB 0x20

//
// CSPR flags
//

#define CPSRF_N 0x80000000
#define CPSRF_Z 0x40000000
#define CPSRF_C 0x20000000
#define CPSRF_V 0x10000000
#define CPSRF_Q 0x08000000

//
// CPSR IT flags mask
//

#define CPSR_IT_MASK 0x0600fc00

//
// FPSCR flags
//

#define FPSCRF_N  0x80000000
#define FPSCRF_Z  0x40000000
#define FPSCRF_C  0x20000000
#define FPSCRF_V  0x10000000
#define FPSCRF_QC 0x08000000

//
// FPSCR modes
//

#define FPSCRM_AHP        0x04000000
#define FPSCRM_DN         0x02000000
#define FPSCRM_FZ         0x01000000

#define FPSCRM_RMODE_MASK 0x00c00000
#define FPSCRM_RMODE_RN   0x00000000
#define FPSCRM_RMODE_RP   0x00400000
#define FPSCRM_RMODE_RM   0x00800000
#define FPSCRM_RMODE_RZ   0x00c00000

#define FPSCRM_DEPRECATED 0x00370000

//
// FPSCR exceptions
//

#define FPSCR_IDE 0x00008000
#define FPSCR_IXE 0x00001000
#define FPSCR_UFE 0x00000800
#define FPSCR_OFE 0x00000400
#define FPSCR_DZE 0x00000200
#define FPSCR_IOE 0x00000100

#define FPSCR_IDC 0x00000080
#define FPSCR_IXC 0x00000010
#define FPSCR_UFC 0x00000008
#define FPSCR_OFC 0x00000004
#define FPSCR_DZC 0x00000002
#define FPSCR_IOC 0x00000001

//
// ARM CP15 register access macros
//

//
// ARMv7 CP15 System Control Coprocessor Registers
//
//                             coprocessor name
//                             |   coprocessor opcode (0-7)
//                             |   |   coprocessor register for operand
//                             |   |   |   src/dest coprocessor register
//                             |   |   |   |  coprocessor-specific opcode
//                             |   |   |   |  |

//
// ID and feature registers
//

#define CP15_MIDR              15, 0,  0,  0, 0         // Main ID Register
#define CP15_CTR               15, 0,  0,  0, 1         // Cache Type Register
#define CP15_TCMTR             15, 0,  0,  0, 2         // TCM Type Register
#define CP15_TLBTR             15, 0,  0,  0, 3         // TLB Type Register
#define CP15_MPIDR             15, 0,  0,  0, 5         // Multiprocessor Affinity Register
#define CP15_PFR0              15, 0,  0,  1, 0         // Processor Feature Register 0
#define CP15_PFR1              15, 0,  0,  1, 1         // Processor Feature Register 1
#define CP15_DFR0              15, 0,  0,  1, 2         // Debug Feature Register 0
#define CP15_AFR0              15, 0,  0,  1, 3         // Auxiliary Feature Register 0
#define CP15_MMFR0             15, 0,  0,  1, 4         // Memory Model Feature Register 0
#define CP15_MMFR1             15, 0,  0,  1, 5         // Memory Model Feature Register 1
#define CP15_MMFR2             15, 0,  0,  1, 6         // Memory Model Feature Register 2
#define CP15_MMFR3             15, 0,  0,  1, 7         // Memory Model Feature Register 3
#define CP15_ISAR0             15, 0,  0,  2, 0         // Instruction Set Attribute Register 0
#define CP15_ISAR1             15, 0,  0,  2, 1         // Instruction Set Attribute Register 1
#define CP15_ISAR2             15, 0,  0,  2, 2         // Instruction Set Attribute Register 2
#define CP15_ISAR3             15, 0,  0,  2, 3         // Instruction Set Attribute Register 3
#define CP15_ISAR4             15, 0,  0,  2, 4         // Instruction Set Attribute Register 4
#define CP15_ISAR5             15, 0,  0,  2, 5         // Instruction Set Attribute Register 5
#define CP15_ISAR6             15, 0,  0,  2, 6
#define CP15_ISAR7             15, 0,  0,  2, 7

//
// System control registers
//

#define CP15_SCTLR             15, 0,  1,  0, 0         // System Control Register
#define CP15_ACTLR             15, 0,  1,  0, 1         // Auxiliary Control Register
#define CP15_CPACR             15, 0,  1,  0, 2         // Coprocessor Access Control Register
#define CP15_SCR               15, 0,  1,  1, 0         // Secure Configuration Register
#define CP15_SDER              15, 0,  1,  1, 1         // Secure Debug Enable Register
#define CP15_NSACR             15, 0,  1,  1, 2         // Non-Secure Access Control Register

//
// Memory protection and control registers
//

#define CP15_TTBR0             15, 0,  2,  0, 0         // Translation Table Base Register 0
#define CP15_TTBR1             15, 0,  2,  0, 1         // Translation Table Base Register 1
#define CP15_TTBCR             15, 0,  2,  0, 2         // Translation Table Base Control Register
#define CP15_DACR              15, 0,  3,  0, 0         // Domain Access Control Register
#define CP15_DFSR              15, 0,  5,  0, 0         // Data Fault Status Register
#define CP15_IFSR              15, 0,  5,  0, 1         // Instruction Fault Status Register
#define CP15_DFAR              15, 0,  6,  0, 0         // Data Fault Address Register
#define CP15_IFAR              15, 0,  6,  0, 2         // Instruction Fault Address Register

//
// ARM Cache Operations
//

#define CP15_ICIALLUIS         15, 0,  7,  1, 0         // Invalidate all instruction caches to PoU Inner Shareable
#define CP15_BPIALLIS          15, 0,  7,  1, 6         // Invalidate entire branch predictor array Inner Shareable
#define CP15_ICIALLU           15, 0,  7,  5, 0         // Invalidate all instruction caches to PoU
#define CP15_ICIMVAU           15, 0,  7,  5, 1         // Invalidate all instruction caches by MVA to PoU
#define CP15_BPIALL            15, 0,  7,  5, 6         // Invalidate entire branch predictor array
#define CP15_BPIMVA            15, 0,  7,  5, 7         // Invalidate MVA from branch predictor array
#define CP15_DCIMVAC           15, 0,  7,  6, 1         // Invalidate data cache line by MVA to PoC
#define CP15_DCISW             15, 0,  7,  6, 2         // Invalidate data cache line by set/way
#define CP15_DCCMVAC           15, 0,  7, 10, 1         // Clean data cache line by MVA to PoC
#define CP15_DCCSW             15, 0,  7, 10, 2         // Clean data cache line by set/way
#define CP15_DCCMVAU           15, 0,  7, 11, 1         // Clean data cache line by MVA to PoU
#define CP15_DCCIMVAC          15, 0,  7, 14, 1         // Clean and invalidate data cache line by MVA to PoC
#define CP15_DCCISW            15, 0,  7, 14, 2         // Clean and invalidate data cache line by set/way

//
// ARM Translation Operations
//

#define CP15_PAR               15, 0,  7,  4, 0         // Physical Address Register (Translation Result)
#define CP15_ATS1CPR           15, 0,  7,  8, 0         // PL1 stage 1 read translation, current state
#define CP15_ATS1CPW           15, 0,  7,  8, 1         // PL1 stage 1 write translation, current state
#define CP15_ATS1CUR           15, 0,  7,  8, 2         // Unprivileged stage 1 read translation, current state
#define CP15_ATS1CUW           15, 0,  7,  8, 3         // Unprivileged stage 1 write translation, current state

//
// Memory Barriers
//

#define CP15_ISB               15, 0,  7,  5, 4         // Instruction Synchronization Barrier operation
#define CP15_DSB               15, 0,  7, 10, 4         // Data Synchronization Barrier operation
#define CP15_DMB               15, 0,  7, 10, 5         // Data Memory Barrier operation

//
// TLB maintenance operations
//

#define CP15_TLBIALLIS         15, 0,  8,  3, 0         // Invalidate entire TLB Inner Shareable
#define CP15_TLBIMVAIS         15, 0,  8,  3, 1         // Invalidate unified TLB entry by MVA Inner Shareable
#define CP15_TLBIASIDIS        15, 0,  8,  3, 2         // Invalidate unified TLB by ASID match Inner Shareable
#define CP15_TLBIMVAAIS        15, 0,  8,  3, 3         // Invalidate unified TLB entry by MVA all ASID Inner Shareable
#define CP15_TLBIALL           15, 0,  8,  7, 0         // Invalidate unified TLB
#define CP15_TLBIMVA           15, 0,  8,  7, 1         // Invalidate unified TLB entry by MVA
#define CP15_TLBIASID          15, 0,  8,  7, 2         // Invalidate unified TLB by ASID match
#define CP15_TLBIMVAA          15, 0,  8,  7, 3         // Invalidate unified TLB entries by MVA all ASID

//
// Performance counter registers
//

#define CP15_PMCR              15, 0,  9, 12, 0         // Performance Monitor Control Register
#define CP15_PMCNTENSET        15, 0,  9, 12, 1         // Count Enable Set Register
#define CP15_PMCNTENCLR        15, 0,  9, 12, 2         // Count Enable Clear Register
#define CP15_PMOVSR            15, 0,  9, 12, 3         // Overflow Flag Status Register
#define CP15_PSWINC            15, 0,  9, 12, 4         // Software Increment Register
#define CP15_PMSELR            15, 0,  9, 12, 5         // Event Counter Selection Register
#define CP15_PMCCNTR           15, 0,  9, 13, 0         // Cycle Count Register
#define CP15_PMXEVTYPER        15, 0,  9, 13, 1         // Event Type Select Register
#define CP15_PMXEVCNTR         15, 0,  9, 13, 2         // Event Count Register
#define CP15_PMUSERENR         15, 0,  9, 14, 0         // User Enable Register
#define CP15_PMINTENSET        15, 0,  9, 14, 1         // Interrupt Enable Set Register
#define CP15_PMINTENCLR        15, 0,  9, 14, 2         // Interrupt Enable Clear Register

//
// Memory remap registers
//

#define CP15_PRRR              15, 0, 10,  2, 0         // Primary Region Remap Register
#define CP15_NMRR              15, 0, 10,  2, 1         // Normal Memory Remap Register

//
// Security extensions registers
//

#define CP15_VBAR              15, 0, 12,  0, 0         // Vector Base Address Register
#define CP15_MVBAR             15, 0, 12,  0, 1         // Monitor Vector Base Address Register
#define CP15_ISR               15, 0, 12,  1, 0         // Interrupt Status Register

//
// Process, context and thread ID registers
//

#define CP15_CONTEXTIDR        15, 0, 13,  0, 1         // Context ID Register
#define CP15_TPIDRURW          15, 0, 13,  0, 2         // Software Thread ID Register, User Read/Write
#define CP15_TPIDRURO          15, 0, 13,  0, 3         // Software Thread ID Register, User Read Only
#define CP15_TPIDRPRW          15, 0, 13,  0, 4         // Software Thread ID Register, Privileged Only

//
// Cache information registers
//

#define CP15_CCSIDR            15, 1,  0,  0, 0         // Cache Size ID Register
#define CP15_CLIDR             15, 1,  0,  0, 1         // Cache Level ID Register
#define CP15_AIDR              15, 1,  0,  0, 7         // Auxiliary ID Register
#define CP15_CSSELR            15, 2,  0,  0, 0         // Cache Size Selection Register

//
// Generic Timer registers
//

#define CP15_CNTVCT            15, 1, 14                // Virtual counter

//
// CP14 debugging registers
//

#define CP14_DBGDIDR           14, 0,  0,  0, 0         //   0: Debug ID Register
#define CP14_DBGDSCRint        14, 0,  0,  1, 0         //   1: Debug Status and Control Register (internal view)
#define CP14_DBGDTRRXint       14, 0,  0,  5, 0         //   5: Host to Target Data Transfer Register (internal view)
#define CP14_DBGDTRTXint       CP14_DBGDTRRXint         //   5: Target to Host Data Transfer Register (internal view)
#define CP14_DBGWFAR           14, 0,  0,  6, 0         //   6: Watchpoint Fault Address Register
#define CP14_DBGVCR            14, 0,  0,  7, 0         //   7: Vector Catch Register
#define CP14_DBGECR            14, 0,  0,  9, 0         //   9: Event Catch Register
#define CP14_DBGDSCCR          14, 0,  0, 10, 0         //  10: Debug State Cache Control Register
#define CP14_DBGDSMCR          14, 0,  0, 11, 0         //  11: Debug State MMU Control Register
#define CP14_DBGDTRRX          14, 0,  0,  0, 2         //  32: Host to Target Data Transfer Register
#define CP14_DBGPCSR           14, 0,  0,  1, 2         //  33: Program Counter Sampling Register
#define CP14_DBGITR            CP14_DBGPCSR             //  33: Instruction Transfer Register
#define CP14_DBGDSCR           14, 0,  0,  2, 2         //  34: Debug Status and Control Register (external view)
#define CP14_DBGDTRTX          14, 0,  0,  3, 2         //  35: Target to Host Data Transfer Register
#define CP14_DBGDRCR           14, 0,  0,  4, 2         //  36: Debug Run Control Register
#define CP14_DBGCIDSR          14, 0,  0,  9, 2         //  41: Context ID Sampling Register
#define CP14_DBGBVR0           14, 0,  0,  0, 4         //  64: Breakpoint Value Register 0
#define CP14_DBGBVR1           14, 0,  0,  1, 4         //  65: Breakpoint Value Register 1
#define CP14_DBGBVR2           14, 0,  0,  2, 4         //  66: Breakpoint Value Register 2
#define CP14_DBGBVR3           14, 0,  0,  3, 4         //  67: Breakpoint Value Register 3
#define CP14_DBGBVR4           14, 0,  0,  4, 4         //  68: Breakpoint Value Register 4
#define CP14_DBGBVR5           14, 0,  0,  5, 4         //  69: Breakpoint Value Register 5
#define CP14_DBGBVR6           14, 0,  0,  6, 4         //  70: Breakpoint Value Register 6
#define CP14_DBGBVR7           14, 0,  0,  7, 4         //  71: Breakpoint Value Register 7
#define CP14_DBGBVR8           14, 0,  0,  8, 4         //  72: Breakpoint Value Register 8
#define CP14_DBGBVR9           14, 0,  0,  9, 4         //  73: Breakpoint Value Register 9
#define CP14_DBGBVR10          14, 0,  0, 10, 4         //  74: Breakpoint Value Register 10
#define CP14_DBGBVR11          14, 0,  0, 11, 4         //  75: Breakpoint Value Register 11
#define CP14_DBGBVR12          14, 0,  0, 12, 4         //  76: Breakpoint Value Register 12
#define CP14_DBGBVR13          14, 0,  0, 13, 4         //  77: Breakpoint Value Register 13
#define CP14_DBGBVR14          14, 0,  0, 14, 4         //  78: Breakpoint Value Register 14
#define CP14_DBGBVR15          14, 0,  0, 15, 4         //  79: Breakpoint Value Register 15
#define CP14_DBGBCR0           14, 0,  0,  0, 5         //  80: Breakpoint Control Register 0
#define CP14_DBGBCR1           14, 0,  0,  1, 5         //  81: Breakpoint Control Register 1
#define CP14_DBGBCR2           14, 0,  0,  2, 5         //  82: Breakpoint Control Register 2
#define CP14_DBGBCR3           14, 0,  0,  3, 5         //  83: Breakpoint Control Register 3
#define CP14_DBGBCR4           14, 0,  0,  4, 5         //  84: Breakpoint Control Register 4
#define CP14_DBGBCR5           14, 0,  0,  5, 5         //  85: Breakpoint Control Register 5
#define CP14_DBGBCR6           14, 0,  0,  6, 5         //  86: Breakpoint Control Register 6
#define CP14_DBGBCR7           14, 0,  0,  7, 5         //  87: Breakpoint Control Register 7
#define CP14_DBGBCR8           14, 0,  0,  8, 5         //  88: Breakpoint Control Register 8
#define CP14_DBGBCR9           14, 0,  0,  9, 5         //  89: Breakpoint Control Register 9
#define CP14_DBGBCR10          14, 0,  0, 10, 5         //  90: Breakpoint Control Register 10
#define CP14_DBGBCR11          14, 0,  0, 11, 5         //  91: Breakpoint Control Register 11
#define CP14_DBGBCR12          14, 0,  0, 12, 5         //  92: Breakpoint Control Register 12
#define CP14_DBGBCR13          14, 0,  0, 13, 5         //  93: Breakpoint Control Register 13
#define CP14_DBGBCR14          14, 0,  0, 14, 5         //  94: Breakpoint Control Register 14
#define CP14_DBGBCR15          14, 0,  0, 15, 5         //  95: Breakpoint Control Register 15
#define CP14_DBGWVR0           14, 0,  0,  0, 6         //  96: Watchpoint Value Register 0
#define CP14_DBGWVR1           14, 0,  0,  1, 6         //  97: Watchpoint Value Register 1
#define CP14_DBGWVR2           14, 0,  0,  2, 6         //  98: Watchpoint Value Register 2
#define CP14_DBGWVR3           14, 0,  0,  3, 6         //  99: Watchpoint Value Register 3
#define CP14_DBGWVR4           14, 0,  0,  4, 6         // 100: Watchpoint Value Register 4
#define CP14_DBGWVR5           14, 0,  0,  5, 6         // 101: Watchpoint Value Register 5
#define CP14_DBGWVR6           14, 0,  0,  6, 6         // 102 Watchpoint Value Register 6
#define CP14_DBGWVR7           14, 0,  0,  7, 6         // 103: Watchpoint Value Register 7
#define CP14_DBGWVR8           14, 0,  0,  8, 6         // 104: Watchpoint Value Register 8
#define CP14_DBGWVR9           14, 0,  0,  9, 6         // 105: Watchpoint Value Register 9
#define CP14_DBGWVR10          14, 0,  0, 10, 6         // 106: Watchpoint Value Register 10
#define CP14_DBGWVR11          14, 0,  0, 11, 6         // 107: Watchpoint Value Register 11
#define CP14_DBGWVR12          14, 0,  0, 12, 6         // 108: Watchpoint Value Register 12
#define CP14_DBGWVR13          14, 0,  0, 13, 6         // 109: Watchpoint Value Register 13
#define CP14_DBGWVR14          14, 0,  0, 14, 6         // 110: Watchpoint Value Register 14
#define CP14_DBGWVR15          14, 0,  0, 15, 6         // 111: Watchpoint Value Register 15
#define CP14_DBGWCR0           14, 0,  0,  0, 7         // 112: Watchpoint Control Register 0
#define CP14_DBGWCR1           14, 0,  0,  1, 7         // 113: Watchpoint Control Register 1
#define CP14_DBGWCR2           14, 0,  0,  2, 7         // 114: Watchpoint Control Register 2
#define CP14_DBGWCR3           14, 0,  0,  3, 7         // 115: Watchpoint Control Register 3
#define CP14_DBGWCR4           14, 0,  0,  4, 7         // 116: Watchpoint Control Register 4
#define CP14_DBGWCR5           14, 0,  0,  5, 7         // 117: Watchpoint Control Register 5
#define CP14_DBGWCR6           14, 0,  0,  6, 7         // 118: Watchpoint Control Register 6
#define CP14_DBGWCR7           14, 0,  0,  7, 7         // 119: Watchpoint Control Register 7
#define CP14_DBGWCR8           14, 0,  0,  8, 7         // 120: Watchpoint Control Register 8
#define CP14_DBGWCR9           14, 0,  0,  9, 7         // 121: Watchpoint Control Register 9
#define CP14_DBGWCR10          14, 0,  0, 10, 7         // 122: Watchpoint Control Register 10
#define CP14_DBGWCR11          14, 0,  0, 11, 7         // 123: Watchpoint Control Register 11
#define CP14_DBGWCR12          14, 0,  0, 12, 7         // 124: Watchpoint Control Register 12
#define CP14_DBGWCR13          14, 0,  0, 13, 7         // 125: Watchpoint Control Register 13
#define CP14_DBGWCR14          14, 0,  0, 14, 7         // 126: Watchpoint Control Register 14
#define CP14_DBGWCR15          14, 0,  0, 15, 7         // 127: Watchpoint Control Register 15
#define CP14_DBGOSLAR          14, 0,  1,  0, 4         // 192: OS Lock Access Register
#define CP14_DBGOSLSR          14, 0,  1,  1, 4         // 193: OS Lock Status Register
#define CP14_DBGOSDLR          14, 0,  1,  3, 4         // 195: OS Double Lock Register
#define CP14_DBGPRSR           14, 0,  1,  5, 4         // 197: Device Power-dow and Reset Status Registers
#define CP14_DBGAUTHSTATUS     14, 0,  7, 14, 6         // 1006: Authentication Status
#define CP14_DBGDEVID2         14, 0,  7,  0, 7         // 1008: Debug Device ID Register 2
#define CP14_DBGDEVID1         14, 0,  7,  1, 7         // 1008: Debug Device ID Register 1
#define CP14_DBGDEVID          14, 0,  7,  2, 7         // 1008: Debug Device ID Register

#define CP14_DBGOSLSR_LOCK_IMP 0x1
#define CP14_DBGOSLSR_LOCKED   0x2

#define CP14_DBGPRSR_STICKYPD  0x2

#define CP14_DBGAUTHSTATUS_NSE  0x01                    // Non-secure invasive debug enabled
#define CP14_DBGAUTHSTATUS_NSI  0x02                    // Non-secure invasive debug features implemented
#define CP14_DBGAUTHSTATUS_NSNE 0x04                    // Non-secure non-invasive debug enabled
#define CP14_DBGAUTHSTATUS_NSNI 0x08                    // Non-secure non-invasive debug features implemented

//
// VFP-registers (normally accessed via vmsr/vmrs but map to mrc/mcr)
//

#define CPVFP_FPSID            10, 7,  0,  0, 0         // Floating-point System ID register
#define CPVFP_FPSCR            10, 7,  1,  0, 0         // Floating-point Status and Control Register
#define CPVFP_MVFR2            10, 7,  5,  0, 0         // Media and VFP Feature Register 2
#define CPVFP_MVFR1            10, 7,  6,  0, 0         // Media and VFP Feature Register 1
#define CPVFP_MVFR0            10, 7,  7,  0, 0         // Media and VFP Feature Register 0
#define CPVFP_FPEXC            10, 7,  8,  0, 0         // Floating-Point Exception Register
#define CPVFP_FPINST           10, 7,  9,  0, 0         // Floating-Point Instruction Register
#define CPVFP_FPINST2          10, 7, 10,  0, 0         // Floating-Point Instruction Register 2

//
// ARM Feature ID Codes
//
// These nibble-offsets define which nibble in a control register
// is used to determine the existance of a feature.
//

#define PFR1_SECURITY          1
#define PFR1_SECURITY_TZONE    1

#define DFR0_MMAP_DEBUG        2
#define DFR0_MMAP_DEBUG_V7     4

#define DFR0_CP14_DEBUG        0
#define DFR0_CP14_DEBUG_V7     4


#define ISAR0_BITCOUNT         1
#define ISAR0_BITCOUNT_CLZ     1

#define ISAR0_BITFIELD         2
#define ISAR0_BITFIELD_BFC_ETC 1

#define ISAR0_CMPBRANCH        3
#define ISAR0_CLZ              1

#define ISAR0_DIVIDE           6
#define ISAR0_DIVIDE_DIV       1

#define ISAR1_EXCEPT           1
#define ISAR1_EXCEPT_LDM_STM   1

#define ISAR1_EXCEPT_AR        2
#define ISAR1_EXCEPT_AR_SRS    1

#define ISAR1_EXTEND           3
#define ISAR1_EXTEND_BASIC     1
#define ISAR1_EXTEND_16        2

#define ISAR1_IFTHEN           4
#define ISAR1_IFTHEN_IT        1

#define ISAR1_IMMEDIATE        5
#define ISAR1_IMMEDIATE_MOVT   1

#define ISAR1_INTERWORK        6
#define ISAR1_INTERWORK_BX     1
#define ISAR1_INTERWORK_BLX    2
#define ISAR1_INTERWORK_THUMB2 3

#define ISAR2_LOADSTORE        0
#define ISAR2_LOADSTORE_LDRD   1
#define ISAR2_LOADSTORE_ACQREL 2

#define ISAR2_MEMHINT          1
#define ISAR2_MEMHINT_PLD      1
#define ISAR2_MEMHINT_PLD2     2
#define ISAR2_MEMHINT_PLI      3
#define ISAR2_MEMHINT_PLDW     4

#define ISAR2_MULT             3
#define ISAR2_MULT_MLA         1
#define ISAR2_MULT_MLS         2

#define ISAR2_MULTS            4
#define ISAR2_MULTS_SMULL      1
#define ISAR2_MULTS_SMLABB     2
#define ISAR2_MULTS_SMLAD      3

#define ISAR2_MULTU            5
#define ISAR2_UMULL            1
#define ISAR2_UMAAL            2

#define ISAR2_PSR_AR           6
#define ISAR2_PSR_AR_MRS_MSR   1

#define ISAR2_REVERSAL         7
#define ISAR2_REVERSAL_REV     1
#define ISAR2_REVERSAL_RBIT    2

#define ISAR3_SATURATE         0
#define ISAR3_SATURATE_QADD    1

#define ISAR3_SIMD             1
#define ISAR3_SIMD_SSAT        1
#define ISAR3_SIMD_PKHBT       3

#define ISAR3_SVC              2
#define ISAR3_SVC_SVC          1

#define ISAR3_SYNCHPRIM        3
#define ISAR3_SYNCHPRIM_LDREX  1
#define ISAR3_SYNCHPRIM_LDREXD 2

#define ISAR3_TABBRANCH        4
#define ISAR3_TABBRANCH_TBB    1

#define ISAR3_THUMBCOPY        5
#define ISAR3_THUMBCOPY_MOV    1

#define ISAR3_TRUENOP          6
#define ISAR3_TRUENOP_NOP      1

#define ISAR4_UNPRIV           0
#define ISAR4_UNPRIV_LDRT      1
#define ISAR4_UNPRIV_LDRHT     2

#define ISAR4_WITHSHIFTS       1
#define ISAR4_WITHSHIFTS_LDSTR 1
#define ISAR4_WITHSHIFTS_CONST 3
#define ISAR4_WITHSHIFTS_REG   4

#define ISAR4_WRITEBACK        2
#define ISAR4_WRITEBACK_FULL   1

#define ISAR4_SMC              3
#define ISAR4_SMC_SMC          1

#define ISAR4_BARRIER          4
#define ISAR4_BARRIER_DMB      1

#define ISAR4_SYNCHPRIM_FRAC   5
#define ISAR4_SYNCHPRIM_FRAC_CLREX 3

#define ISAR5_SEVL             0
#define ISAR5_SEVL_IMP         1

#define ISAR5_AES              1
#define ISAR5_AES_AESE         1
#define ISAR5_AES_PMULL        2

#define ISAR5_SHA1             2
#define ISAR5_SHA1_SHA1C       1

#define ISAR5_SHA2             3
#define ISAR5_SHA2_SHA256H     1

#define ISAR5_CRC32            4
#define ISAR5_CRC32_IMP        1


#define MMFR0_VMSA             0
#define MMFR0_VMSA_V7PXN       4
#define MMFR0_VMSA_LPAE        5

#define MMFR0_L1SHARED         2
#define MMFR0_L1SHARED_L1      1

#define MMFR1_L1HVRD           4
#define MMFR1_L1HVRD_REQ       2

#define MMFR1_L1UNIFIED        5
#define MMFR1_L1UNIFIED_REQ    2

#define MMFR2_UTLB             4
#define MMFR2_UTLB_VA_ALL      3

#define MMFR3_BCAST            3
#define MMFR3_BCAST_ALL        2

#define MMFR3_HPW              5
#define MMFR3_HPW_COHERENT     1

#define MMFR3_L1HIER_CACHE     0

#define READ_ARM_FEATURE(_FeatureRegister, _Index) \
        (((ULONG)_MoveFromCoprocessor(_FeatureRegister) >> ((_Index) * 4)) & 0xF)

//
// ARM Vector/Floatingpoint feature fields
// Use READ_ARM_FEATURE, above
// See Section B53.2 in ARM architectural reference manual
//

#define MVFR0_VFPRND            7
#define MVFR0_VFPRND_ALL        1

#define MVFR0_VFPVEC            6
#define MVFR0_VFPVEC_SUPPORTED  1

#define MVFR0_FSQRT             5
#define MVFR0_FSQRT_SUPPORTED   1

#define MVFR0_FDIV              4
#define MVFR0_FDIV_SUPPORTED    1

#define MVFR0_FPEX              3
#define MVFR0_FPEX_SUPPORTED    1

#define MVFR0_VDPREC            2
#define MVFR0_VDPREC_V3         2

#define MVFR0_VSPREC            1
#define MVFR0_VSPREC_V3         2

#define MVFR0_AREGS             0
#define MVFR0_AREGS_16          1
#define MVFR0_AREGS_32          2

#define MVFR1_ASFMAC            7
#define MVFR1_ASFMAC_SUPPORTED  1

#define MVFR1_VHPREC            6
#define MVFR1_VHPREC_SUPPORTED  1

#define MVFR1_AHPREC            5
#define MVFR1_AHPREC_SUPPORTED  1

#define MVFR1_ASPREC            4
#define MVFR1_ASPREC_SUPPORTED  1

#define MVFR1_AINT              3
#define MVFR1_AINT_SUPPORTED    1

#define MVFR1_ALDSTR            2
#define MVFR1_ALDSTR_SUPPORTED  1

#define MVFR1_VDNAN             1
#define MVFR1_VDNAN_SUPPORTED   1

#define MVFR1_VFTZ              0
#define MVFR1_VFTZ_SUPPORTED    1

#define MVFR2_FPMISC            1
#define MVFR2_FPMISC_FPSEL      1
#define MVFR2_FPMISC_ROUNDING   2
#define MVFR2_FPMISC_RINT       3
#define MVFR2_FPMISC_MINMAX     4

#define MVFR2_SIMDMISC          0
#define MVFR2_SIMDMISC_ROUNDING 1
#define MVFR2_SIMDMISC_RINT     2
#define MVFR2_SIMDMISC_MINMAX   3


//
// VFP sub-architecture is really bits 16-22 (0x007F0000), however, bit 22
// is used to indicate if the subarchitecture was designed by ARM, so all we
// really need to look at are bits 16-21
//
// VFPv3 indicates "The entire floating-point implementation is in
// hardware, and no software support code is required."
//

#define CPVFP_FPSID_SW                  0x00800000      // Software-only floating-point

#define CPVFP_FPEXC_EX                  0x80000000      // Extra state required for context save
#define CPVFP_FPEXC_EN                  0x40000000      // VFP/Advanced SIMD enable
#define CPVFP_FPEXC_DEX                 0x20000000      // synchronous exception flag
#define CPVFP_FPEXC_FP2V                0x10000000      // FPINST2 is valid

#define CP15_CPACR_D32DIS               0x80000000      // Disable d16-d31 (support optional)
#define CP15_CPACR_ASEDIS               0x40000000      // Disable Advanced SIMD (support optional)
#define CP15_CPACR_VFP_MASK             0x00f00000      // Mask for enabling/disabling VFP/NEON access

#define CP15_NSACR_NSASEDIS             0x00008000      // Disable non-secure Advanced SIMD functionality
#define CP15_NSACR_NSD32DIS             0x00004000      // Disable non-secure use of d16-d31
#define CP15_NSACR_VFP_USERMODE         0x00000c00      // Enable CP10/CP11 in user mode


//
// Coprocessor registers for ARMv7 cache hierarchy information
//

#define ARM_MPIDR_MPEXT                0x80000000
#define ARM_MPIDR_UP                   0x40000000
#define ARM_MPIDR_MT                   0x01000000

//
// Constants for flags in CP15 Register 1 e.g. the system control register.
//
                                                    // ARMv7 ARMv7VE ARMv8
#define CP15_SCTLR_M                    0x00000001  //   x      x      x
#define CP15_SCTLR_A                    0x00000002  //   x      x      x
#define CP15_SCTLR_C                    0x00000004  //   x      x      x
                                     // 0x00000008  //   1      1      1
                                     // 0x00000010  //   1      1      1
#define CP15_SCTLR_CP15BEN              0x00000020  //   x      x      x  (was _D)
#define CP15_SCTLR_THEE                 0x00000040  //   1      1      x
#define CP15_SCTLR_ITD                  0x00000080  //   0      0      x
#define CP15_SCTLR_SED                  0x00000100  //   0      0      x
                                     // 0x00000200  //   0      0      0
#define CP15_SCTLR_SW                   0x00000400  //   x      x      0  (was _F)
#define CP15_SCTLR_Z                    0x00000800  //   x      x      1
#define CP15_SCTLR_I                    0x00001000  //   x      x      x
#define CP15_SCTLR_V                    0x00002000  //   x      x      x
#define CP15_SCTLR_RR                   0x00004000  //   x      x      0
                                     // 0x00008000  //   0      0      0
#define CP15_SCTLR_nTWI                 0x00010000  //   1      1      x
#define CP15_SCTLR_HA                   0x00020000  //   x      x      0
#define CP15_SCTLR_nTWE                 0x00040000  //   1      1      x
#define CP15_SCTLR_WXN                  0x00080000  //   0      x      x
#define CP15_SCTLR_UWXN                 0x00100000  //   0      x      x
#define CP15_SCTLR_FI                   0x00200000  //   x      x      0
                                     // 0x00400000  //   1      1      1
                                     // 0x00800000  //   1      1      1
#define CP15_SCTLR_VE                   0x01000000  //   x      x      0
#define CP15_SCTLR_EE                   0x02000000  //   x      x      x
                                     // 0x04000000  //   0      0      0
#define CP15_SCTLR_NMFI                 0x08000000  //   x      0      0
#define CP15_SCTLR_TRE                  0x10000000  //   x      x      x
#define CP15_SCTLR_AFE                  0x20000000  //   x      x      x
#define CP15_SCTLR_TE                   0x40000000  //   x      x      x
                                     // 0x80000000  //   0      0      0

#define CP15_RES1_MASK                  0x00c00018

//
// Task base register definitions and masks
// (configured so that hardware page table walks are cached)
//

//
// Without MP extensions
//

#define CP15_TTBRx_PD_MASK              0xffffc000

#define CP15_TTBRx_INNER_CACHED         0x01
#define CP15_TTBRx_INNER_SHARED         0x02
#define CP15_TTBRx_ECC                  0x04
#define CP15_TTBRx_OUTER_CACHED         0x08
#define CP15_TTBRx_OUTER_UNSHARED       0x20

#define CP15_TTBRx_VALID_NOMP_MASK      0x3f

#define CP15_TTBRx_VALID_MASK           0x1f

//
// With MP extensions
//

#define CP15_TTBRx_MPEXT_INNER_NC       0x00
#define CP15_TTBRx_MPEXT_INNER_WBWA     0x40
#define CP15_TTBRx_MPEXT_INNER_WT       0x01
#define CP15_TTBRx_MPEXT_INNER_WB       0x41

#define CP15_TTBRx_MPEXT_OUTER_NC       0x00
#define CP15_TTBRx_MPEXT_OUTER_WBWA     0x08
#define CP15_TTBRx_MPEXT_OUTER_WT       0x10
#define CP15_TTBRx_MPEXT_OUTER_WB       0x18

#define CP15_TTBRx_MPEXT_INNER_CACHED   CP15_TTBRx_MPEXT_INNER_WBWA
#define CP15_TTBRx_MPEXT_OUTER_CACHED   CP15_TTBRx_MPEXT_OUTER_WBWA

#define CP15_TTBRx_VALID_MPEXT_MASK     0x7f

//
// Fault status syndrome masks
//

#define CP15_xFSR_FS_LOW                0x0000000f
#define CP15_xFSR_FS_HIGH               0x00000400
#define CP15_DFSR_WnR                   0x00000800

//
// Performance counter register bits
//

#define CP15_PMCR_DP                    0x00000020
#define CP15_PMCR_X                     0x00000010
#define CP15_PMCR_CLKCNT_DIV            0x00000008
#define CP15_PMCR_CLKCNT_RST            0x00000004
#define CP15_PMCR_CNT_RST               0x00000002
#define CP15_PMCR_ENABLE                0x00000001

#define CP15_PMCNTEN_PMCCNT             0x80000000

//
// Performance counter user-enable register bits
//

#define CP15_PMUSERENR_EN               0x00000001

//
// Context/ASID register definitions
//
//   bits 0-7 bits contain the ASID
//   bits 31-8 contain the context id used for trace/breakpoint matching
//

#define CP15_CONTEXTIDR_ASID_MASK       0x000000ff
#define CP15_CONTEXTIDR_CONTEXT_MASK    0xffffff00

CFORCEINLINE
VOID
_SyncPte (
    VOID
    )
{
    //
    // If the PTE that was changed was already in the valid state, then
    // DSB and ISB memory barriers must be issued as per the ARM ARM B3.10.5
    // specification.
    //
    // If the PTE was invalid and is being made valid then the DSB
    // and ISB is also required.  The ISB is needed to guarantee as
    // per the ARM ARM revC section B3.10.1 that the translation
    // table walk (caused by a subsequent explicit load or store)
    // will see the updated translation.  Typically this is not necessary
    // because the fault handler would be invoked & see the PTE is valid
    // and hence dismiss the fault (and the exception return implies an
    // implicit ISB).  But if the created PTE was being used
    // for a nonpaged mapping and the caller did not expect to fault (ie
    // is at raised IRQL or holds working set synchronization, etc) then
    // we cannot defer this to the fault handler hence we always issue
    // the ISB explicitly here.
    //
    // Of course if the PTE was being changed from one invalid state to
    // another, no call to this function is issued at all.
    //

    _DataSynchronizationBarrier();

    _InstructionSynchronizationBarrier();
}

//
// The hardware fault status registers DFSR and IFSR contain fields
// that can describe up to 64 different fault sources/causes.  To
// address the large number and the inconvenient encoding, we map
// these sources to an internal software fault status representation.
//

#define SWFS_WRITE                      0x01
#define SWFS_EXECUTE                    0x08
#define SWFS_PAGE_FAULT                 0x10
#define SWFS_ALIGN_FAULT                0x20
#define SWFS_HWERR_FAULT                0x40
#define SWFS_DEBUG_FAULT                0x80

//
// Remap register settings.  Goal is to remap C, B, TEX bits to get
// cached, uncached, and write combined functionality as well as 3 OS
// managed bits.
//
// This is achieved as follows:
//     TEX[2:1] are available as OS managed bits when remap is enabled
//     TEX[0] must be 0.
//     S is made into an OS managed bit as it is remapped.
//     Another OS managed bit could be extracted

//
// Primary remap region register is configured for the uniprocessor
// configuration so that normal memory is considered inner unshared and
// device memory is considered shared (write combining behavior).
// Strongly ordered memory is always considered shared.
//
// The memory types are encoded as follows:
//         C=0, B=0        Cached normal memory
//         C=0, B=1        Strongly ordered device memory (uncached)
//         C=1, B=0        UNUSED
//         C=1, B=1        Non-Cacheable normal memory (similar to WC)
//

#define CP15_PRRR_MEMTYPE_STRONG        0
#define CP15_PRRR_MEMTYPE_DEVICE        1
#define CP15_PRRR_MEMTYPE_NORMAL        2

#define CP15_PRRR_NOS7                  0x80000000
#define CP15_PRRR_NOS6                  0x40000000
#define CP15_PRRR_NOS5                  0x20000000
#define CP15_PRRR_NOS4                  0x10000000
#define CP15_PRRR_NOS3                  0x08000000
#define CP15_PRRR_NOS2                  0x04000000
#define CP15_PRRR_NOS1                  0x02000000
#define CP15_PRRR_NOS0                  0x01000000
#define CP15_PRRR_NS1                   0x00080000
#define CP15_PRRR_NS0                   0x00040000
#define CP15_PRRR_DS1                   0x00020000
#define CP15_PRRR_DS0                   0x00010000

//
// Currently all platforms only support inner sharing.  Outer sharing might
// apply to coherency between clusters or I/O coherent systems.
//

#define CP15_CR10_PRRR_UNSHARED \
         ((CP15_PRRR_MEMTYPE_NORMAL << 0) | (CP15_PRRR_MEMTYPE_NORMAL << 8) | \
          (CP15_PRRR_MEMTYPE_STRONG << 2) | (CP15_PRRR_MEMTYPE_STRONG << 10) | \
          (CP15_PRRR_MEMTYPE_NORMAL << 4) | (CP15_PRRR_MEMTYPE_NORMAL << 12) | \
          (CP15_PRRR_MEMTYPE_NORMAL << 6) | (CP15_PRRR_MEMTYPE_NORMAL << 14) | \
          CP15_PRRR_DS0 | CP15_PRRR_DS1 | \
          CP15_PRRR_NOS0 | CP15_PRRR_NOS1 | CP15_PRRR_NOS2 | CP15_PRRR_NOS3 | \
          CP15_PRRR_NOS4 | CP15_PRRR_NOS5 | CP15_PRRR_NOS6 | CP15_PRRR_NOS7)

//
// In a multiprocessor configuration, the remap registers must be
// programmed such that all normal memory is 'inner shared' and thus cache
// coherency is maintained.
//

#define CP15_CR10_PRRR_SHARED (CP15_CR10_PRRR_UNSHARED | CP15_PRRR_NS0 | CP15_PRRR_NS1)

//
// If the remap register in combination with the TEX[0],C,B bits maps
// to normal memory, then the NMRR register determines the inner/outer
// caching attributes.
//
// The mappings for normal memory are write back, allocate on write at
// the inner and outer levels except for the TEX[0],C,B=0,1,0
// combination which is write through inner and write back outer.
//

#define CP15_NMRR_CACHE_NC              0
#define CP15_NMRR_CACHE_WBWA            1
#define CP15_NMRR_CACHE_WTNA            2

#define CP15_NMRR_DEFAULT \
        (ULONG) ((CP15_NMRR_CACHE_WBWA << 0) | \
                 (CP15_NMRR_CACHE_WBWA << 2) | \
                 (CP15_NMRR_CACHE_WTNA << 4) | \
                 (CP15_NMRR_CACHE_NC   << 6) | \
                 (CP15_NMRR_CACHE_WBWA << 8) | \
                 (CP15_NMRR_CACHE_WBWA << 10) | \
                 (CP15_NMRR_CACHE_WTNA << 12) | \
                 (CP15_NMRR_CACHE_NC   << 14) | \
                 (CP15_NMRR_CACHE_WBWA << 16) | \
                 (CP15_NMRR_CACHE_WBWA << 18) | \
                 (CP15_NMRR_CACHE_WBWA << 20) | \
                 (CP15_NMRR_CACHE_NC   << 22) | \
                 (CP15_NMRR_CACHE_WBWA << 24) | \
                 (CP15_NMRR_CACHE_WBWA << 26) | \
                 (CP15_NMRR_CACHE_WBWA << 28) | \
                 (CP15_NMRR_CACHE_NC   << 30))

//
// Debug register bits.
//

#define CP14_DBGBCR_MISMATCH_BIT        0x00400000
#define CP14_DBGBCR_SECURITY_BITS       0x0000c000
#define   CP14_DBGBCR_ANY_SECURE        0x00000000
#define   CP14_DBGBCR_NONSECURE_ONLY    0x00004000
#define   CP14_DBGBCR_SECURE_ONLY       0x00008000
#define CP14_DBGBCR_PRIVILEGE_BITS      0x00000006
#define   CP14_DBGBCR_USER_SYS_SUPER    0x00000000
#define   CP14_DBGBCR_PRIVILEGED_ONLY   0x00000002
#define   CP14_DBGBCR_USER_ONLY         0x00000004
#define   CP14_DBGBCR_ANY_PRIVILEGE     0x00000006
#define CP14_DBGBCR_ENABLE_BIT          0x00000001

#define CP14_DBGDSCR_MOE_MASK           0x0000003c
#define CP14_DBGDSCR_MOE_SHIFT          2
#define CP14_DBGDSCR_MOE_HALT           0x00000000
#define CP14_DBGDSCR_MOE_BP             0x00000001
#define CP14_DBGDSCR_MOE_WPASYNC        0x00000002
#define CP14_DBGDSCR_MOE_BKPT           0x00000003
#define CP14_DBGDSCR_MOE_EXTERNAL       0x00000004
#define CP14_DBGDSCR_MOE_VECTOR         0x00000005
#define CP14_DBGDSCR_MOE_WPSYNC         0x0000000a

#define CP14_DBGDSCR_UDCCdis            0x00001000
#define CP14_DBGDSCR_RXfull             0x40000000
#define CP14_DBGDSCR_TXfull             0x20000000


#ifdef __cplusplus
extern "C" {
#endif

//
// Define function to read CPSR/SPSR
//

int
_ReadStatusReg (
    int Cpsr
    );

#pragma intrinsic(_ReadStatusReg)

#ifdef __cplusplus
}
#endif

// end_nthal

// begin_irqls
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0                 // Passive release level
#define LOW_LEVEL 0                     // Lowest interrupt level
#define APC_LEVEL 1                     // APC interrupt level
#define DISPATCH_LEVEL 2                // Dispatcher level

#define CLOCK_LEVEL 13                  // Interval clock level
#define IPI_LEVEL 14                    // Interprocessor interrupt level
#define DRS_LEVEL 14                    // Deferred Recovery Service level
#define POWER_LEVEL 14                  // Power failure level
#define PROFILE_LEVEL 15                // timer used for profiling.
#define HIGH_LEVEL 15                   // Highest interrupt level

// end_irqls

// begin_wdm
//
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#define SYNCH_LEVEL (IPI_LEVEL-2)       

#if defined(_ARM_)

//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//
//  N.B. This implementation assumes that the memory mapped registers
//       have been mapped using the OS concept of uncached memory
//       which is implemented using the ARMv7 strongly ordered memory
//       type.  In addition, the register access is bracketed by a
//       compiler barrier to ensure that the compiler does not
//       re-order the I/O accesses with other accesses and a data
//       synchronization barrier to ensure that any side effects of
//       the access have started (but not necessairly completed).
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT
//  space.  The ARM architecture doesn't have a seperate I/O space.
//  These operations bugcheck so as to identify incorrect code.
//

#ifdef __cplusplus
extern "C" {
#endif

__forceinline
UCHAR
READ_REGISTER_NOFENCE_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register
    )
{

    return ReadUCharNoFence(Register);
}

__forceinline
USHORT
READ_REGISTER_NOFENCE_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register
    )
{

    return ReadUShortNoFence(Register);
}

__forceinline
ULONG
READ_REGISTER_NOFENCE_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register
    )
{

    return ReadULongNoFence(Register);
}

__forceinline
VOID
READ_REGISTER_NOFENCE_BUFFER_UCHAR (
    _In_reads_(Count) _Notliteral_ volatile UCHAR *Register,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{

    volatile UCHAR *registerBuffer =  Register;
    PUCHAR readBuffer = Buffer;
    ULONG readCount;

    for (readCount = Count; readCount--; readBuffer++, registerBuffer++) {
        *readBuffer = ReadUCharNoFence(registerBuffer);
    }


    return;
}

__forceinline
VOID
READ_REGISTER_NOFENCE_BUFFER_USHORT (
    _In_reads_(Count) _Notliteral_ volatile USHORT *Register,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{
    volatile USHORT *registerBuffer =  Register;
    PUSHORT readBuffer = Buffer;
    ULONG readCount;

    for (readCount = Count; readCount--; readBuffer++, registerBuffer++) {
        *readBuffer = ReadUShortNoFence(registerBuffer);
    }

    return;
}

__forceinline
VOID
READ_REGISTER_NOFENCE_BUFFER_ULONG (
    _In_reads_(Count) _Notliteral_ volatile ULONG *Register,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{
    volatile ULONG *registerBuffer =  Register;
    PULONG readBuffer = Buffer;
    ULONG readCount;

    for (readCount = Count; readCount--; readBuffer++, registerBuffer++) {
        *readBuffer = ReadULongNoFence(registerBuffer);
    }
    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register,
    _In_ UCHAR Value
    )
{

    WriteUCharNoFence(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register,
    _In_ USHORT Value
    )
{

    WriteUShortNoFence(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register,
    _In_ ULONG Value
    )
{

    WriteULongNoFence(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_BUFFER_UCHAR (
    _Out_writes_(Count) _Notliteral_ volatile UCHAR *Register,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{

    volatile UCHAR *registerBuffer = Register;
    PUCHAR writeBuffer = Buffer;
    ULONG writeCount;

    for (writeCount = Count; writeCount--; writeBuffer++, registerBuffer++) {
        WriteUCharNoFence(registerBuffer, *writeBuffer);
    }

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_BUFFER_USHORT (
    _Out_writes_(Count) _Notliteral_ volatile USHORT *Register,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{

    volatile USHORT *registerBuffer = Register;
    PUSHORT writeBuffer = Buffer;
    ULONG writeCount;

    for (writeCount = Count; writeCount--; writeBuffer++, registerBuffer++) {
        WriteUShortNoFence(registerBuffer, *writeBuffer);
    }

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_BUFFER_ULONG (
    _Out_writes_(Count) _Notliteral_ volatile ULONG *Register,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{

    volatile ULONG *registerBuffer = Register;
    PULONG writeBuffer = Buffer;
    ULONG writeCount;

    for (writeCount = Count; writeCount--; writeBuffer++, registerBuffer++) {
        WriteULongNoFence(registerBuffer, *writeBuffer);
    }

    return;
}

__forceinline
VOID
REGISTER_FENCE (
    VOID
    )
{

    _DataSynchronizationBarrier();
}

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register
    )
{
    UCHAR Value;

    _DataSynchronizationBarrier();
    Value = READ_REGISTER_NOFENCE_UCHAR(Register);

    return Value;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register
    )
{
    USHORT Value;

    _DataSynchronizationBarrier();
    Value = READ_REGISTER_NOFENCE_USHORT(Register);

    return Value;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register
    )
{
    ULONG Value;

    _DataSynchronizationBarrier();
    Value = READ_REGISTER_NOFENCE_ULONG(Register);

    return Value;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    _In_reads_(Count) _Notliteral_ volatile UCHAR *Register,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{
    _DataSynchronizationBarrier();
    READ_REGISTER_NOFENCE_BUFFER_UCHAR(Register, Buffer, Count);

    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    _In_reads_(Count) _Notliteral_ volatile USHORT *Register,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    READ_REGISTER_NOFENCE_BUFFER_USHORT(Register, Buffer, Count);

    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    _In_reads_(Count) _Notliteral_ volatile ULONG *Register,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    READ_REGISTER_NOFENCE_BUFFER_ULONG(Register, Buffer, Count);

    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register,
    _In_ UCHAR Value
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_UCHAR(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register,
    _In_ USHORT Value
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_USHORT(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register,
    _In_ ULONG Value
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_ULONG(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    _Out_writes_(Count) _Notliteral_ volatile UCHAR *Register,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_BUFFER_UCHAR(Register, Buffer, Count);

    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    _Out_writes_(Count) _Notliteral_ volatile USHORT *Register,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_BUFFER_USHORT(Register, Buffer, Count);

    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    _Out_writes_(Count) _Notliteral_ volatile ULONG *Register,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_BUFFER_ULONG(Register, Buffer, Count);

    return;
}



// end_wudfpwdm

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    _In_ _Notliteral_ PUCHAR Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    _In_ _Notliteral_ PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    _In_ _Notliteral_ PULONG Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _In_ UCHAR Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _In_ USHORT Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _In_ ULONG Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    );

// begin_wudfpwdm

#ifdef __cplusplus
}
#endif

#endif

// end_ntndis end_wudfpwdm
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


VOID
KeFlushIoBuffers(
    _In_ PMDL  Mdl,
    _In_ BOOLEAN  ReadOperation,
    _In_ BOOLEAN  DmaOperation
    );

VOID
KeFlushIoRectangle (
    _In_ PMDL Mdl,
    _In_ PVOID Start,
    _In_ ULONG Width,
    _In_ ULONG Height,
    _In_ ULONG Stride,
    _In_ BOOLEAN ReadOperation
    );


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount) { \
    KSYSTEM_TIME volatile *_TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    for (;;) {                                                              \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        YieldProcessor();                                                   \
    }                                                                       \
}

// end_wdm

#else

VOID
NTAPI
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)



//
// ARM hardware structures
//
// The following bit arrangements and semantics assume a ARMv7 style MMU
// configured for the NT profile which is defined here as:
//    Subpages disabled (CP15 Reg1 XP=1)
//
// A Page Table Entry on an ARM has the following definition.
//

typedef struct _HARDWARE_PTE {
    ULONG Valid : 2;            // Bit 0 is NX only if bit 1 is true
    ULONG CacheType : 2;
    ULONG Accessed : 1;
    ULONG Owner : 1;
    ULONG TypeExtension : 1;    // always zero
    ULONG Writable : 1;         // OS managed
    ULONG CopyOnWrite : 1;      // OS managed
    ULONG ReadOnly : 1;         // Inverse of Dirty
    ULONG LargePage : 1;        // OS managed
    ULONG NonGlobal : 1;
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// N.B. The combination of ExecuteNever set and the Valid bit not
// being set represents a different second level page descriptor not
// used by NT.  This combination must be avoided as it is not an
// invalid page.
//

//
// A Page Directory Entry on the ARM has the following definition.
// Note this is (unfortunately) different from the ARM Page Table
// Entry format.
//
// We are using the coarse page table descriptor format
// here for our page directory entries and the small page second level
// descriptor for our page table entries.
//

typedef struct _HARDWARE_PDE {
    ULONG Valid : 2;        // 1 == valid "coarse" 4k pde.  0 == invalid.
                            // 2 == section (large).
                            // 3 == fine pde (not used by Mm)

    ULONG ImplementationDefined : 3;
    ULONG Domain : 4;       // 0 == kernel, 1 == user, other 14 unused
    ULONG MustBeZero : 1;   // as per the ARM spec
    ULONG PageFrameNumberLower : 2;
    ULONG PageFrameNumber : 20;
} HARDWARE_PDE, *PHARDWARE_PDE;

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \
     *((PULONG)(dirbase)) = (((ULONG)(pfn)) << PAGE_SHIFT)

// begin_windbgkd

#if defined(_ARM_)

//
// Define special kernel registers
//

typedef struct _KSPECIAL_REGISTERS {

    ULONG Reserved[7];
    ULONG Cp15_Cr13_UsrRW;
    ULONG Cp15_Cr13_UsrRO;
    ULONG Cp15_Cr13_SvcRW;

    //
    // H/w [break/watch]point support.
    //

    ULONG KernelBvr[ARM_MAX_BREAKPOINTS];
    ULONG KernelBcr[ARM_MAX_BREAKPOINTS];
    ULONG KernelWvr[ARM_MAX_WATCHPOINTS];
    ULONG KernelWcr[ARM_MAX_WATCHPOINTS];

    //
    // Floating point control state.
    //

    ULONG Fpexc;
    ULONG Fpinst;
    ULONG Fpinst2;

    //
    // Banked general purpose registers.
    //

    ULONG UserSp;
    ULONG UserLr;

    ULONG AbortSp;
    ULONG AbortLr;
    ULONG AbortSpsr;

    ULONG UdfSp;
    ULONG UdfLr;
    ULONG UdfSpsr;

    ULONG IrqSp;
    ULONG IrqLr;
    ULONG IrqSpsr;
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Define remaining architectural state
//

typedef struct _KARM_ARCH_STATE
{
    ULONG Cp15_Cr0_CpuId;
    ULONG Cp15_Cr1_Control;
    ULONG Cp15_Cr1_AuxControl;
    ULONG Cp15_Cr1_Cpacr;
    ULONG Cp15_Cr2_TtbControl;
    ULONG Cp15_Cr2_Ttb0;
    ULONG Cp15_Cr2_Ttb1;
    ULONG Cp15_Cr3_Dacr;
    ULONG Cp15_Cr5_Dfsr;
    ULONG Cp15_Cr5_Ifsr;
    ULONG Cp15_Cr6_Dfar;
    ULONG Cp15_Cr6_Ifar;
    ULONG Cp15_Cr9_PmControl;
    ULONG Cp15_Cr9_PmCountEnableSet;
    ULONG Cp15_Cr9_PmCycleCounter;
    ULONG Cp15_Cr9_PmEventCounter[MAX_EVENT_COUNTERS];
    ULONG Cp15_Cr9_PmEventType[MAX_EVENT_COUNTERS];
    ULONG Cp15_Cr9_PmInterruptSelect;
    ULONG Cp15_Cr9_PmOverflowStatus;
    ULONG Cp15_Cr9_PmSelect;
    ULONG Cp15_Cr9_PmUserEnable;
    ULONG Cp15_Cr10_PrimaryMemoryRemap;
    ULONG Cp15_Cr10_NormalMemoryRemap;
    ULONG Cp15_Cr12_VBARns;
    ULONG Cp15_Cr13_ContextId;
} KARM_ARCH_STATE, *PKARM_ARCH_STATE;

//
// Define processor state structure.
//

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    KARM_ARCH_STATE ArchState;
    CONTEXT ContextFrame;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _ARM_

// end_windbgkd

//
// Mini-stacks used for exception handling
//

typedef struct __declspec(align(16)) _KARM_MINI_STACK {
    ULONG Pc;
    ULONG Cpsr;
    ULONG R4;
    ULONG R5;
    ULONG R6;
    ULONG R7;
    ULONG Reserved[2];
} KARM_MINI_STACK, *PKARM_MINI_STACK;

//
// Define processor vendors.
//

typedef enum {
    CPU_UNKNOWN,
    CPU_ARM,
    CPU_QUALCOMM
} CPU_VENDORS;

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1

#define PRCB_BUILD_DEBUG 0x1
#define PRCB_BUILD_UNIPROCESSOR 0x2

#define MAXIMUM_CACHES 6

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    UCHAR LegacyNumber;
    UCHAR ReservedMustBeZero;
    BOOLEAN IdleHalt;
    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    UCHAR NestingLevel;
    BOOLEAN ClockOwner;
    union {
        UCHAR PendingTickFlags;

        struct {
            UCHAR PendingTick:1;
            UCHAR PendingBackupTick:1;
        };
    };

    UCHAR IdleState;
    ULONG Number;
    KSPIN_LOCK PrcbLock;
    PSCHAR PriorityState;
    KPROCESSOR_STATE ProcessorState;
    USHORT ProcessorModel;
    USHORT ProcessorRevision;
    ULONG MHz;
    ULONG64 CycleCounterFrequency;
    ULONG HalReserved[15];
    USHORT MinorVersion;
    USHORT MajorVersion;
    UCHAR BuildType;
    UCHAR CpuVendor;
    UCHAR CoresPerPhysicalProcessor;
    UCHAR LogicalProcessorsPerCore;
    PVOID AcpiReserved;
    KAFFINITY GroupSetMember;
    UCHAR Group;
    UCHAR GroupIndex;

//
// End of the architecturally defined section of the PRCB.
//

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

C_ASSERT(FIELD_OFFSET(KPRCB, HalReserved) == 0x3D0);  // Do not move field
C_ASSERT(FIELD_OFFSET(KPRCB, AcpiReserved) == 0x414); // Do not move field


//
// ARM IDT Entry Structure Definition
//
// ARM does not have a native IDT format and does not vector interrupt
// exceptions.
//

//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Certain fields in the TIB are not used in kernel mode. These include the
// exception list, stack base, stack limit, subsystem TIB, fiber data, and
// the arbitrary user pointer. Therefore, these fields are overlaid with
// other data to get better cache locality.
//
// N.B. The offset to the PRCB in the PCR is fixed for all time.
//

    union {
        NT_TIB NtTib;
        struct {
            ULONG TibPad0[2];
            PVOID Spare1;
            struct _KPCR *Self;
            struct _KPRCB *CurrentPrcb;
            PKSPIN_LOCK_QUEUE LockArray;
            PVOID Used_Self;
        };
    };

    KIRQL CurrentIrql;
    UCHAR SecondLevelCacheAssociativity;
    ULONG Unused0[3];
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG StallScaleFactor;
    PVOID Unused1[3];

    ULONG KernelReserved[15];
    ULONG SecondLevelCacheSize;
    union {
        USHORT SoftwareInterruptPending; // Software Interrupt Pending Flag
        struct {
            UCHAR ApcInterrupt;          // 0x01 if APC int pending
            UCHAR DispatchInterrupt;     // 0x01 if dispatch int pending
        };
    };

    USHORT InterruptPad;
    ULONG HalReserved[32];
    PVOID KdVersionBlock;
    PVOID Unused3;
    ULONG PcrAlign1[8];

// end_ntddk

    PVOID Idt[256];
    PVOID *IdtExt;

    ULONG PcrAlign2[19];

    KPRCB Prcb;

//
// End of the architecturally defined section of the PCR.
//

} KPCR, *PKPCR;


//
// Definitions for CP15 Register 0 e.g. ID and cache information
//

typedef union _ARM_IDCODE {
    ULONG Ulong;
    struct {
        ULONG MinorRevision :  4;
        ULONG Model         : 12;
        ULONG Architecture  :  4;
        ULONG Revision      :  4;
        ULONG Implementer   :  8;
    };
} ARM_IDCODE, *PARM_IDCODE;

C_ASSERT(sizeof(ARM_IDCODE) == 4);

// end_wdm
// begin_nthal

#define CP15_CR0_HARVARD_CACHE (1 << 24)

// Define ARMv7 cache information structure

#define ARM_L1_ICACHE_UNKNOWN 0
#define ARM_L1_ICACHE_VIVT    1
#define ARM_L1_ICACHE_VIPT    2
#define ARM_L1_ICACHE_PIPT    3

typedef union _ARM_CACHE_TYPE {
    ULONG Ulong;
    struct {
        ULONG IMinLine               : 4;
        ULONG Reserved               : 10;
        ULONG IPolicy                : 2;
        ULONG DMinLine               : 4;
        ULONG Reserved2              : 12;
    };
} ARM_CACHE_TYPE, *PARM_CACHE_TYPE;

C_ASSERT(sizeof(ARM_CACHE_TYPE) == 4);

#define ARM_CACHE_NONE        0
#define ARM_CACHE_INSTRUCTION 1
#define ARM_CACHE_DATA        2
#define ARM_CACHE_HARVARD     3
#define ARM_CACHE_UNIFIED     4

typedef union _ARM_CACHE_LEVEL_ID {
    ULONG Ulong;
    struct {
        ULONG Level1 : 3;
        ULONG Level2 : 3;
        ULONG Level3 : 3;
        ULONG Level4 : 3;
        ULONG Level5 : 3;
        ULONG Level6 : 3;
        ULONG Level7 : 3;
        ULONG LoUIS  : 3;
        ULONG LoC    : 3;
        ULONG LoU    : 3;
    };
} ARM_CACHE_LEVEL_INFO;

C_ASSERT(sizeof(ARM_CACHE_LEVEL_INFO) == 4);

#define ARM_CACHE_SELECT_DATA_OR_UNIFIED 0
#define ARM_CACHE_SELECT_INSTRUCTION     1

typedef union _ARM_CACHE_INFO_SELECTOR {
    ULONG Ulong;
    struct {
        ULONG Select : 1;
        ULONG Level  : 3;
    };
} ARM_CACHE_INFO_SELECTOR;

C_ASSERT(sizeof(ARM_CACHE_INFO_SELECTOR) == 4);

typedef union _ARM_CACHE_INFO {
    ULONG Ulong;
    struct {
        ULONG LineSize           : 3;
        ULONG Associativity      : 10;
        ULONG NumberOfSets       : 15;
        ULONG WriteThrough       : 1;
        ULONG WriteBack          : 1;
        ULONG ReadAllocate       : 1;
        ULONG WriteAllocate      : 1;
    };
} ARM_CACHE_INFO;

C_ASSERT(sizeof(ARM_CACHE_INFO) == 4);

// end_nthal
//
// This undefined instruction is used as a breakpoint rather than
// BKPT.  BKPT causes a prefetch abort that can only be diagnosed
// after the possibility of an MMU fault has been resolved.
//

#define THUMB_BREAKPOINT                0xDEFE

//
// This undefined instruction is used for 'debug services' rather than
// SWI due to concerns about nested operations on the SVC stack.
//

#define THUMB_DEBUG_SERVICE             0xDEFD

//
// This undefined instruction is used signal an NT_ASSERT
//

#define THUMB_ASSERT                    0xDEFC

//
// This undefined instruction is used to signal a fast fail (__fastfail)
//

#define THUMB_FASTFAIL                  0xDEFB

//
// This undefined instruction is a fast path for fetching the
// cycle counter from user mode.
//

#define THUMB_READ_CYCLES               0xDEFA

//
// This undefined instruction generates a divide-by-0 exception.
//

#define THUMB_DIVIDE_BY_0               0xDEF9

//
// This undefined instruction returns to 64-bit mode. It is only
// implemented on ARM64 systems.
//

#define THUMB_EXIT_32BIT_MODE           0xDEF8

//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all nonvolatile registers. The volatile registers will already
//  have been saved in a trap frame.
//
// N.B. The exception frame is preceded in the trap handling code by
//      an exception record capable of storing information for four
//      parameter values.
//

typedef struct _KEXCEPTION_FRAME {

    ULONG Param5;

//
// Kernel callout frame variables.
//

    ULONG TrapFrame;
    ULONG OutputBuffer;
    ULONG OutputLength;

//
// Saved nonvolatile registers.
//

    ULONG Pad;
    ULONG R4;
    ULONG R5;
    ULONG R6;
    ULONG R7;
    ULONG R8;
    ULONG R9;
    ULONG R10;
    ULONG R11;

    ULONG Return;

} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

// end_ntddk
// begin_nthal

#define KEXCEPTION_FRAME_LENGTH sizeof(KEXCEPTION_FRAME)

C_ASSERT((sizeof(KEXCEPTION_FRAME) & STACK_ROUND) == 0);
C_ASSERT((FIELD_OFFSET(KEXCEPTION_FRAME, Return) + sizeof(ULONG)) == sizeof(KEXCEPTION_FRAME));

#define EXCEPTION_RECORD_LENGTH ((sizeof(EXCEPTION_RECORD) + STACK_ROUND - 1) & ~STACK_ROUND)

//
// Machine Frame
//
// This frame is established by code that trampolines to user mode (e.g. user
// APC, user callback, dispatch user exception, etc.). The purpose of this
// frame is to allow unwinding through these callbacks if an exception occurs.
//

typedef struct _MACHINE_FRAME {
    ULONG Sp;
    ULONG Pc;
} MACHINE_FRAME, *PMACHINE_FRAME;

#define MACHINE_FRAME_LENGTH sizeof(MACHINE_FRAME)

C_ASSERT((sizeof(MACHINE_FRAME) & STACK_ROUND) == 0);

//
// Switch Frame
//
// This frame is established by the code that switches context from one
// thread to the next and is used by the thread initialization code to
// construct a stack that will start the execution of a thread in the
// thread start up code.
//

typedef struct _KSWITCH_FRAME {
    KIRQL ApcBypass;
    UCHAR Fill[7];
    ULONG R11;
    ULONG Return;
} KSWITCH_FRAME, *PKSWITCH_FRAME;

#define KSWITCH_FRAME_LENGTH sizeof(KSWITCH_FRAME)

C_ASSERT((sizeof(KSWITCH_FRAME) & STACK_ROUND) == 0);

//
// Start system thread frame.
//
// This frame is established by the ARM specific thread initialization
// code. It is used to store the initial context for starting a system
// thread.
//

typedef struct _KSTART_FRAME {
    ULONG R0;
    ULONG R1;
    ULONG R2;
    ULONG Return;
} KSTART_FRAME, *PKSTART_FRAME;

#define KSTART_FRAME_LENGTH sizeof(KSTART_FRAME)

C_ASSERT((sizeof(KSTART_FRAME) & STACK_ROUND) == 0);

// end_nthal
// begin_ntddk
//
// VFP State -- specially organized collection of VFP state that
// is used in context switching. The volatile section is also used
// in trap frame handling and lazy VFP enabling.
//

typedef struct _KARM_VFP_STATE
{
    struct _KARM_VFP_STATE *Link;           // link to next state entry
    ULONG Fpscr;                            // FPSCR register
    ULONG Reserved;                         // reserved for future use
    ULONG Reserved2;                        // reserved for future use
    ULONGLONG VfpD[32];                     // All D registers (0-31)
} KARM_VFP_STATE, *PKARM_VFP_STATE;

//
// Trap frame
//
// This frame is established when handling a trap. It provides a place to
// save all volatile registers. The nonvolatile registers are saved in an
// exception frame or through the normal C calling conventions for saved
// registers.
//
// Code to generate the trap frame is found in ntos\ke\arm\trap.asm.
//

#define KTRAP_FRAME_ARGUMENTS (14 * 4)       // up to 14 in-memory syscall args

typedef struct _KTRAP_FRAME {

//
// Page fault information (page faults only)
// Previous trap frame address (system services only)
//
// Organized this way to allow first couple words to be used
// for scratch space in the general case
//

    ULONG Arg3;                         // page faults only
    ULONG FaultStatus;                  // page faults only
    union {
        ULONG FaultAddress;             // page faults only
        ULONG TrapFrame;                // system services only
    };
    ULONG Reserved;                     // always valid, internal use

//
// Exception active indicator.
//
//    0 - interrupt frame.
//    1 - exception frame.
//    2 - service frame.
//

    UCHAR ExceptionActive;              // always valid
    UCHAR ContextFromKFramesUnwound;    // set if KeContextFromKFrames created this frame
    UCHAR DebugRegistersValid;          // always valid
    union {
        KPROCESSOR_MODE PreviousMode;   // system services only
        KIRQL PreviousIrql;             // interrupts only
    };

//
// The ARM architecture does not have an architectural trap frame.  On
// an exception or interrupt, the processor switches to an
// exception-specific processor mode in which at least the LR and SP
// registers are banked.  Software is responsible for preserving
// registers which reflect the processor state in which the
// exception occurred rather than any intermediate processor modes.
//

//
// Volatile floating point state is dynamically allocated; this
// pointer may be NULL if the FPU was not enabled at the time the
// trap was taken.
//

    PKARM_VFP_STATE VfpState;

//
// Debug registers
//

    ULONG Bvr[ARM_MAX_BREAKPOINTS];
    ULONG Bcr[ARM_MAX_BREAKPOINTS];
    ULONG Wvr[ARM_MAX_WATCHPOINTS];
    ULONG Wcr[ARM_MAX_WATCHPOINTS];

//
// Volatile registers R0-R3, R12, and the SP, LR
//

    ULONG R0;
    ULONG R1;
    ULONG R2;
    ULONG R3;
    ULONG R12;
    ULONG Sp;
    ULONG Lr;

//
// R11/PC for a frame chain, plus the saved CPSR
//

    ULONG R11;
    ULONG Pc;
    ULONG Cpsr;

} KTRAP_FRAME, *PKTRAP_FRAME;

// end_ntddk

//
// Define TrapFrame->ExceptionActive constants.
//

#define KEXCEPTION_ACTIVE_INTERRUPT_FRAME 0
#define KEXCEPTION_ACTIVE_EXCEPTION_FRAME 1
#define KEXCEPTION_ACTIVE_SERVICE_FRAME   2

// begin_nthal

#define KTRAP_FRAME_LENGTH sizeof(KTRAP_FRAME)

C_ASSERT((sizeof(KTRAP_FRAME) & STACK_ROUND) == 0);

//
// The "red zone" on ARM is the amount of stack guaranteed not be
// stepped on when generating exceptions. It must be honored in both
// kernel and user mode. There is code in the system that assumes
// data stored at [sp-4] and [sp-8] will not get trampled.
//

#define ARM_RED_ZONE_BYTES      8

//
// Profile, update run time, and update system time interrupt routines.
//

_IRQL_requires_(IPI_LEVEL);
NTKERNELAPI
BOOLEAN
KiIpiServiceRoutine (
    _In_ PVOID Interrupt,
    _In_ PVOID Context
    );

NTKERNELAPI
NTSTATUS
KiConnectHalInterrupt (
    _Inout_ PVOID Interrupt
    );

NTKERNELAPI
VOID
KiReplayInterrupt (
    _In_ ULONG Vector,
    _In_ KIRQL Irql,
    _In_ KIRQL PreviousIrql,
    _In_ ULONG OpaqueToken
    );

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    _In_ PKTRAP_FRAME TrapFrame,
    _In_ KPROFILE_SOURCE ProfileSource
    );

// end_nthal

//
// The frame saved by the call out to user mode code is defined here
// to allow the kernel debugger to trace the entire kernel stack when
// user mode callouts are active.
//
// N.B. The kernel callout frame is the same as an exception frame.
//

typedef KEXCEPTION_FRAME KCALLOUT_FRAME;
typedef PKEXCEPTION_FRAME PKCALLOUT_FRAME;

typedef struct _UCALLOUT_FRAME {
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    ULONG OriginalLr;
    MACHINE_FRAME MachineFrame;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;

C_ASSERT((sizeof(UCALLOUT_FRAME) & STACK_ROUND) == 0);

// begin_wdm
//
// Dummy nonvolatile floating state structure.
//

typedef struct _KFLOATING_SAVE {
    ULONG Dummy;
} KFLOATING_SAVE, *PKFLOATING_SAVE;


//
// ARM Specific portions of Mm component.
//

#define PDE_BASE 0xC0300000
#define PTE_BASE 0xC0000000

#define PTE_TOP  0xC03FFFFF
#define PDE_TOP  0xC0300FFF

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT 22

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define the number of PTEs and PDEs per page.
//

#define PTE_PER_PAGE (PAGE_SIZE / sizeof(ULONG))
#define PDE_PER_PAGE (PAGE_SIZE / sizeof(ULONG))

//
// Define the highest user address and user probe address.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// Allow non-kernel components to capture the user probe address and use a
// local copy for efficiency.
//

#if defined(_LOCAL_COPY_USER_PROBE_ADDRESS_)

#define MM_USER_PROBE_ADDRESS _LOCAL_COPY_USER_PROBE_ADDRESS_

#if defined(__CONVERGED_WIN32K_DRIVER__)
extern DLLBASEEXPORT ULONG _LOCAL_COPY_USER_PROBE_ADDRESS_;
#else
extern ULONG _LOCAL_COPY_USER_PROBE_ADDRESS_;
#endif

#else

#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

#define MM_KSEG0_BASE       MM_SYSTEM_RANGE_START
#define MM_SYSTEM_SPACE_END 0xFFFFFFFF

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)(LONG_PTR)0x10000

// end_ntddk
// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_wdm

//
// State sanitization support
//
// If kernel mode, then caller can specify:
//      Condition codes (N,Z,C,V,Q,GE[19:16])
//      IT State
//      IRQ Disabled
//      FIQ Disable
// For kernel mode, the following configuration is enforced:
//      Thumb mode
//      SVC mode
//

#define CPSR_KERNEL_SANITIZE 0xFF0FFCE0

//
// If user mode, then caller can specify:
//      Condition codes (N,Z,C,V,Q,GE[19:16])
//      IT State
//      Thumb mode
// For user mode, the following configuration is enforced:
//      USER mode
//      IRQ Enabled
//      FIQ Enabled
//

#define CPSR_USER_SANITIZE   0xFF0FFC20

//
// Define sanitize CPSR macro
//

#define SANITIZE_CPSR(cpsr, mode) (                                      \
    ((mode) == KernelMode ?                                              \
        (((cpsr) & CPSR_KERNEL_SANITIZE) | CPSRM_SVC | CPSRC_THUMB) :    \
        (((cpsr) & CPSR_USER_SANITIZE) | CPSRM_USER)))


//
// Define inlined function to sanitize debug address and control registers.
//

__forceinline
ULONG
SANITIZE_DEBUG_ADDR(ULONG DebugReg, MODE mode)
{
    return ((mode) == KernelMode ?
                 (DebugReg) :
                 (((PVOID)(DebugReg) <= MM_HIGHEST_USER_ADDRESS) ? (DebugReg) : 0));
}

__forceinline
ULONG
SANITIZE_DEBUG_CTRL(ULONG DebugReg, MODE mode)
{
    return ((mode) == KernelMode ?
                 (DebugReg) :
                 (((DebugReg) & ~(CP14_DBGBCR_SECURITY_BITS | CP14_DBGBCR_PRIVILEGE_BITS)) |
                                    (CP14_DBGBCR_ANY_SECURE | CP14_DBGBCR_USER_ONLY)));
}

//
// CPSR value given to first thread on new processors (note interrupts
// and external aborts are disabled).
//

#define INITIAL_KERNEL_CPSR (CPSRM_SVC | CPSRC_THUMB | CPSRC_INT | CPSRC_ABORT)

//
// Value PSR is restored to on return from system call. Done to
// discourage dependence on what happens inside a system call.  In
// fact the banked status registers ensure that status bits don't
// filter back into user mode.
//

#define SYSCALL_PSR         (CPSRM_USER | CPSRC_THUMB)

//
// Define sanitize debug register macros.
//


//
// Intrinsic functions
//

#if defined(_M_ARM) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)

//
// The following routines are provided for backward compatibility with old
// code. They are no longer the preferred way to accomplish these functions.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

#define ExInterlockedDecrementLong(Addend, Lock)                            \
    _ExInterlockedDecrementLong(Addend)

_Post_satisfies_(return >= 0 && return <= 2)
__forceinline
LONG
_ExInterlockedDecrementLong (
    _Inout_ _Interlocked_operand_ PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedDecrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedIncrementLong(Addend, Lock)                            \
    _ExInterlockedIncrementLong(Addend)

_Post_satisfies_(return >= 0 && return <= 2)
__forceinline
LONG
_ExInterlockedIncrementLong (
    _Inout_ _Interlocked_operand_ PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedIncrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedExchangeUlong(Target, Value, Lock)                     \
    _ExInterlockedExchangeUlong(Target, Value)

__forceinline
ULONG
_ExInterlockedExchangeUlong (
    _Inout_ _Interlocked_operand_ PULONG Target,
    _In_ ULONG Value
    )

{

    return (ULONG)InterlockedExchange((PLONG)Target, (LONG)Value);
}

#endif // defined(_M_ARM) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)


#define CP15_PCR_RESERVED_MASK 0xFFF
#define KIPCR() ((ULONG_PTR)(_MoveFromCoprocessor(CP15_TPIDRPRW)) & ~CP15_PCR_RESERVED_MASK)

// end_wdm

#if !defined(MIDL_PASS) && defined(_M_ARM)

//
// ARM function prototype definitions
//

// end_nthal

//
// Get address of current processor block.
//

CFORCEINLINE
PKPCR
KeGetPcr (
    VOID
    )

{
    return (PKPCR)(ULONG_PTR)KIPCR();
}

// end_ntddk begin_nthal
//
// Get address of current processor block.
//

CFORCEINLINE
PKPRCB
KeGetCurrentPrcb (
    VOID
    )
{

    PKPRCB Prcb;

    Prcb = (PKPRCB)(KIPCR() + 0x580);
    __assume(Prcb != NULL);
    return Prcb;
}

// end_nthal
// begin_ntddk

#if (NTDDI_VERSION < NTDDI_WIN7) || !defined(NT_PROCESSOR_GROUPS)

//
// Get the current processor number
//

__forceinline
ULONG
KeGetCurrentProcessorNumber (
    VOID
    )

{

    return *(PUCHAR)(KIPCR() + 0x580);
}

#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN7)

CFORCEINLINE
ULONG
KeGetCurrentProcessorIndex (
    VOID
    )

{

    return *(PULONG)(KIPCR() + 0x594);
}

#endif

// end_wdm
// begin_nthal

NTKERNELAPI
PKPRCB
KeQueryPrcbAddress (
    _In_ ULONG Number
    );


#endif // !defined(MIDL_PASS) && defined(_M_ARM)


#if !defined(_CROSS_PLATFORM_)

CFORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )

/*++

Routine Description:

    This function orders memory accesses as seen by other processors.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _ReadWriteBarrier();
    MemoryBarrier();
}

//++
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function instructs the compiler not to reorder loads and stores
//    across the function invocation.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

//
// Define function to read the value of the time stamp counter.
//
// N.B. On some platforms (e.g., any non-Intel platform like ARM)
// the "timestamp counter" may be backed by QueryPerformanceCounter
// or the like, and may not be as low-latency as one might expect.
//

ULONG64
ReadTimeStampCounter (
    VOID
    );

#else

#define KeMemoryBarrier()
#define KeMemoryBarrierWithoutFence()

#endif


_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_When_(return>=0, _Kernel_float_saved_)
_At_(*FloatSave, _When_(return>=0, _Kernel_acquires_resource_(FloatState)))
__forceinline
NTSTATUS
KeSaveFloatingPointState (
    _Out_ PKFLOATING_SAVE FloatSave
    )

#pragma warning (suppress:28104 28161 6001 6101) // PFD can't recognize the implementation
{

    UNREFERENCED_PARAMETER(FloatSave);

    return STATUS_SUCCESS;
}

_Success_(1)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Kernel_float_restored_
_At_(*FloatSave, _Kernel_requires_resource_held_(FloatState) _Kernel_releases_resource_(FloatState))
__forceinline
NTSTATUS
KeRestoreFloatingPointState (
    _In_ PKFLOATING_SAVE FloatSave
    )

#pragma warning (suppress:28103 28162) // PFD can't recognize the implementation
{

    UNREFERENCED_PARAMETER(FloatSave);

    return STATUS_SUCCESS;
}


#endif // defined(_ARM_)


//
// Platform specific kernel fucntions to raise and lower IRQL.
//


#if defined(_ARM_) && !defined(MIDL_PASS)
// end_ntddk

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_saves_
NTHALAPI
KIRQL
KeGetCurrentIrql (
    VOID
    );

_IRQL_requires_max_(HIGH_LEVEL)
NTHALAPI
VOID
KfLowerIrql (
    _In_ _IRQL_restores_ _Notliteral_ KIRQL NewIrql
    );

#define KeLowerIrql(a) KfLowerIrql(a)
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

NTHALAPI
KIRQL
_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_raises_(NewIrql)
_IRQL_saves_
KfRaiseIrql (
    _In_ KIRQL NewIrql
    );


_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
__forceinline
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to DPC_LEVEL and returns the
    previous IRQL.

Arguments:

    None.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(DISPATCH_LEVEL);
}

_IRQL_saves_
_IRQL_raises_(12)
__forceinline
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to SYNCH_LEVEL and returns the
    previous IRQL.

Arguments:

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(12);
}

// begin_wdm
#endif // defined(_ARM_) && !defined(MIDL_PASS)


#if defined(_M_ARM)

VOID
KeCompactServiceTable (
    _Inout_ PVOID Table,
    _In_ PVOID Arguments,
    _In_ ULONG Limit,
    _In_ BOOLEAN Win32k
    );

VOID
KiLockServiceTable (
    _Inout_ PVOID Table,
    _In_ PVOID Arguments,
    _In_ ULONG limit,
    _In_ BOOLEAN Win32k
    );

//
// Lazy VFP helpers
//

PKARM_VFP_STATE
KiGetVfpStatePointer(
    _In_ PKTRAP_FRAME TrapFrame
    );


//
// Types of VFP management supported:
//
//  ARM_VFP_ALWAYSON: VFP is always enabled; VFP state is always
//      saved/restored on every trap and every context switch.
//
//  ARM_VFP_LAZY_ONEWAY: VFP is disabled by default for each thread
//      until the first VFP access. Prior to the first access,
//      VFP state does not need to be saved/restored during traps
//      and does not need to be swapped in on a context swap, giving
//      better performance. Once a thread touches the VFP, it will
//      continue to save/restore VFP state on each trap and context
//      swap, regardless of whether the thread continues to use VFP.
//
//  ARM_VFP_LAZY_WITH_DEMOTION: same as the previous but perodically
//      threads with active VFP states are demoted back to VFP
//      disabled in an attempt to recover from situations where the
//      VFP was touched briefly but not used afterwards. Demotion
//      can only occur upon returning to user mode with no active
//      callouts.
//

#define ARM_VFP_ALWAYSON                0
#define ARM_VFP_LAZY_ONEWAY             1
// Not yet fully implemented:
#define ARM_VFP_LAZY_WITH_DEMOTION      2

//
// Type of VFP management that is active
//

#define ARM_VFP_MANAGEMENT              ARM_VFP_LAZY_ONEWAY

//
// Statistics about VFP management
//

#define ARM_VFP_ENABLE_STATISTICS       0

#if ARM_VFP_ENABLE_STATISTICS

typedef struct _ARM_VFP_STATS
{
    ULONG64 TrapsEnabled;
    ULONG64 TrapsDisabled;
    ULONG64 ContextSwitchesToEnabled;
    ULONG64 ContextSwitchesToDisabled;
    ULONG64 AttemptedDemotions;
    ULONG64 FailedDemotions;
    ULONG64 MissedDemotions;
    ULONG EnableLogIndex;
    ULONG EnableLog[256];
} ARM_VFP_STATS;

#endif


//
// Trap frame log entry
//

typedef struct _TRAPFRAME_LOG_ENTRY {
    ULONG Thread;
    UCHAR CpuNumber;
    UCHAR TrapType;
    USHORT Padding;
    ULONG R0;
    ULONG R1;
    ULONG R2;
    ULONG R3;
    ULONG R12;
    ULONG Sp;
    ULONG Lr;
    ULONG R11;
    ULONG Pc;
    ULONG Cpsr;
} TRAPFRAME_LOG_ENTRY, *PTRAPFRAME_LOG_ENTRY;

#define TRAP_TYPE_INTERRUPT 1
#define TRAP_TYPE_SYSCALL 2
#define TRAP_TYPE_UNDEFINED 3
#define TRAP_TYPE_DATA_ABORT 4
#define TRAP_TYPE_PREFETCH_ABORT 5
#define TRAP_TYPE_RESET 6
#define TRAP_TYPE_FIQ 7


//
// Image header machine architecture
//

#define IMAGE_FILE_MACHINE_NATIVE   0x01C4


//
// Private implementations of 8 bit interlocked operations until
// compiler is updated
//

char
InterlockedAnd8 (
    _Inout_ char volatile *Destination,
    _In_ char Value
    );

char
InterlockedOr8 (
    _Inout_ char volatile *Destination,
    _In_ char Value
    );

#endif

// begin_ntminiport

#if defined(_M_ARM64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#endif // defined(_M_ARM64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)
// end_ntminiport

#if defined(_ARM64_) // ntddk nthal irqls ntoshvp

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;
typedef LONG64 SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG64 PFN_NUMBER, *PPFN_NUMBER;

//
// Maximum number of event counters in performance monitoring unit.
//

#define MAX_EVENT_COUNTERS 31

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 32

//
// Indicate that the ARM64 compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1

//

//
// CPSR mode constants
//

#define CPSRM_EL3h 0xd
#define CPSRM_EL3t 0xc
#define CPSRM_EL2h 0x9
#define CPSRM_EL2t 0x8
#define CPSRM_EL1h 0x5
#define CPSRM_EL1t 0x4
#define CPSRM_EL0t 0x0
#define CPSRM_MASK 0x0f

//
// CPSR EL constants
//

#define CPSREL_3 0xc
#define CPSREL_2 0x8
#define CPSREL_1 0x4
#define CPSREL_0 0x0
#define CPSREL_MASK 0x0c

//
// DAIF enable/disables
//

#define DAIF_DEBUG 0x200
#define DAIF_ABORT 0x100
#define DAIF_INT   0x80
#define DAIF_FIQ   0x40

//
// NZCV flags
//

#define NZCV_N 0x80000000
#define NZCV_Z 0x40000000
#define NZCV_C 0x20000000
#define NZCV_V 0x10000000

//
// New ARM64 CSPR flags
//

#define CPSRM_T 0x00000020
#define CPSRM_AA32 0x00000010
#define CPSR_IL 0x00100000
#define CPSR_SS 0x00200000
#define CPSR_IT_MASK 0x0600fc00

//
// FPCR modes
//

#define FPCRM_AHP        0x04000000
#define FPCRM_DN         0x02000000
#define FPCRM_FZ         0x01000000

#define FPCRM_RMODE_MASK 0x00c00000
#define FPCRM_RMODE_RN   0x00000000
#define FPCRM_RMODE_RP   0x00400000
#define FPCRM_RMODE_RM   0x00800000
#define FPCRM_RMODE_RZ   0x00c00000

//
// FPCR exception controls
//

#define FPCR_IDE 0x00008000
#define FPCR_IXE 0x00001000
#define FPCR_UFE 0x00000800
#define FPCR_OFE 0x00000400
#define FPCR_DZE 0x00000200
#define FPCR_IOE 0x00000100

//
// FPSR exception states
//

#define FPSR_IDC 0x00000080
#define FPSR_IXC 0x00000010
#define FPSR_UFC 0x00000008
#define FPSR_OFC 0x00000004
#define FPSR_DZC 0x00000002
#define FPSR_IOC 0x00000001

//
// ARMv8 Status Registers
//

//
// Core registers
//

#define ARM64_SPSR_EL1          ARM64_SYSREG(3,0, 4, 0,0)   // Saved processor status register (EL1)
#define ARM64_SPSR_EL2          ARM64_SYSREG(3,4, 4, 0,0)   // Saved processor status register (EL2)
#define ARM64_ELR_EL1           ARM64_SYSREG(3,0, 4, 0,1)   // Exception return address (EL1)
#define ARM64_ELR_EL2           ARM64_SYSREG(3,4, 4, 0,1)   // Exception return address (EL2)
#define ARM64_SP_EL0            ARM64_SYSREG(3,0, 4, 1,0)   // User mode stack pointer (EL1)
#define ARM64_SP_EL1            ARM64_SYSREG(3,4, 4, 1,0)   // Kernel mode stack pointer (EL1)
#define ARM64_SP_EL2            ARM64_SYSREG(3,6, 4, 1,0)   // Hypervisor mode stack pointer (EL2)
#define ARM64_SPSel             ARM64_SYSREG(3,0, 4, 2,0)   // SP select (EL1)
#define ARM64_DAIF              ARM64_SYSREG(3,3, 4, 2,1)   // Interrupt Masks (EL0)
#define ARM64_CurrentEL         ARM64_SYSREG(3,0, 4, 2,2)   // Current Exception Level (ReadOnly, EL1)
#define ARM64_NZCV              ARM64_SYSREG(3,3, 4, 2,0)   // Flags (EL0)
//#define ARM64_FPCR            ARM64_SYSREG(3,3, 4, 4,0)   // Floating point control register (EL0)
//#define ARM64_FPSR            ARM64_SYSREG(3,3, 4, 4,1)   // Floating point status register (EL0)
#define ARM64_DSPSR             ARM64_SYSREG(3,3, 4, 5,0)   // ??? (EL0)
#define ARM64_DLR               ARM64_SYSREG(3,3, 4, 5,1)   // ??? (EL0)

//
// ID and feature registers
//

#define ARM64_MIDR_EL1          ARM64_SYSREG(3,0, 0, 0,0)   // Main ID Register [CP15_MIDR]
#define ARM64_VPIDR_EL2         ARM64_SYSREG(3,4, 0, 0,0)   // Virtualized Main ID Register [CP15_VPIDR]
#define ARM64_REVIDR_EL1        ARM64_SYSREG(3,0, 0, 0,6)   // Revision ID Register [CP15_REVIDR]
#define ARM64_CTR_EL0           ARM64_SYSREG(3,3, 0, 0,1)   // Cache Type Register [CP15_CTR]
#define ARM64_MPIDR_EL1         ARM64_SYSREG(3,0, 0, 0,5)   // Multiprocessor Affinity Register [CP15_MPIDR]
#define ARM64_VMPIDR_EL2        ARM64_SYSREG(3,4, 0, 0,5)   // Virtualized Multiprocessor Affinity Register [CP15_VMPIDR]
#define ARM64_ID_AA64PFR0_EL1   ARM64_SYSREG(3,0, 0, 4,0)   // Processor Feature Register 0
#define ARM64_ID_AA64PFR1_EL1   ARM64_SYSREG(3,0, 0, 4,1)   // Processor Feature Register 1
#define ARM64_ID_AA64DFR0_EL1   ARM64_SYSREG(3,0, 0, 5,0)   // Debug Feature Register 0
#define ARM64_ID_AA64DFR1_EL1   ARM64_SYSREG(3,0, 0, 5,1)   // Debug Feature Register 1
#define ARM64_ID_AA64AFR0_EL1   ARM64_SYSREG(3,0, 0, 5,4)   //
#define ARM64_ID_AA64AFR1_EL1   ARM64_SYSREG(3,0, 0, 5,5)   //
#define ARM64_ID_AA64ISAR0_EL1  ARM64_SYSREG(3,0, 0, 6,0)   // ISA Feature Register 0
#define ARM64_ID_AA64ISAR1_EL1  ARM64_SYSREG(3,0, 0, 6,1)   // ISA Feature Register 1
#define ARM64_ID_AA64MMFR0_EL1  ARM64_SYSREG(3,0, 0, 7,0)   // Memory Management Feature Register 0
#define ARM64_ID_AA64MMFR1_EL1  ARM64_SYSREG(3,0, 0, 7,1)   // Memory Management Feature Register 1

//
// System control registers
//

#define ARM64_SCTLR_EL1         ARM64_SYSREG(3,0, 1, 0,0)   // System Control Register [CP15_SCTLR]
#define ARM64_SCTLR_EL2         ARM64_SYSREG(3,4, 1, 0,0)   // System Control Register [CP15_HSCTLR]
#define ARM64_HCR_EL2           ARM64_SYSREG(3,4, 1, 1,0)   // Hypervisor Configuration Register (EL2)
#define ARM64_HSTR_EL2          ARM64_SYSREG(3,4, 1, 1,3)   // Hypervisor System Trap Configuration Register (EL2)
#define ARM64_HACR_EL2          ARM64_SYSREG(3,4, 1, 1,7)   // Hypervisor Auxiliary Configuration Register (EL2)
#define ARM64_ACTLR_EL1         ARM64_SYSREG(3,0, 1, 0,1)   // Auxiliary Control Register [CP15_ACTLR]
#define ARM64_ACTLR_EL2         ARM64_SYSREG(3,4, 1, 0,1)   // Auxiliary Control Register [CP15_HACTLR]
#define ARM64_CPACR_EL1         ARM64_SYSREG(3,0, 1, 0,2)   // Coprocessor Access Control Register [CP15_CPACR]
#define ARM64_SCR_EL3           ARM64_SYSREG(3,6, 1, 1,0)   // Secure Configuration Register [CP15_SCR]
#define ARM64_CPTR_EL3          ARM64_SYSREG(3,6, 1, 1,2)   // Non-Secure Access Control Register [CP15_NSACR]
#define ARM64_CPTR_EL2          ARM64_SYSREG(3,4, 1, 1,2)   // Hypervisor Access Control Register [CP15_HCPTR]

//
// Memory protection and control registers
//

#define ARM64_TTBR0_EL1         ARM64_SYSREG(3,0, 2, 0,0)   // Translation Table Base Register 0 [CP15_TTBR0]
#define ARM64_TTBR0_EL2         ARM64_SYSREG(3,4, 2, 0,0)   // Translation Table Base Register 0 [CP15_HTTBR]
#define ARM64_TTBR1_EL1         ARM64_SYSREG(3,0, 2, 0,1)   // Translation Table Base Register 1 [CP15_TTBR1]
#define ARM64_VTTBR_EL2         ARM64_SYSREG(3,4, 2, 1,0)   // Virtualization Translation Table Base Register 1 [CP15_VTTBR]
#define ARM64_TCR_EL1           ARM64_SYSREG(3,0, 2, 0,2)   // Translation Control Register [CP15_TTBCR]
#define ARM64_TCR_EL2           ARM64_SYSREG(3,4, 2, 0,2)   // Translation Control Register [CP15_HTCR]
#define ARM64_VTCR_EL2          ARM64_SYSREG(3,4, 2, 1,2)   // Virtualization Translation Control Register [CP15_VTCR]
#define ARM64_ESR_EL1           ARM64_SYSREG(3,0, 5, 2,0)   // Exception Status Register [CP15_DFSR/CP15_IFSR]
#define ARM64_ESR_EL2           ARM64_SYSREG(3,4, 5, 2,0)   // Exception Status Register [CP15_HSR]
#define ARM64_FAR_EL1           ARM64_SYSREG(3,0, 6, 0,0)   // Fault Address Registers [CP15_DFAR/CP15_IFAR]
#define ARM64_FAR_EL2           ARM64_SYSREG(3,4, 6, 0,0)   // Fault Address Registers [CP15_HDFAR/CP15_HIFAR]
#define ARM64_HPFAR_EL2         ARM64_SYSREG(3,4, 6, 0,4)   // Hypervisor IPA Fault Address Registers [CP15_HPFAR]
#define ARM64_AFSR0_EL1         ARM64_SYSREG(3,0, 5, 1,0)   // Auxiliary Fault Status Register 0 [CP15_ADFSR]
#define ARM64_AFSR0_EL2         ARM64_SYSREG(3,4, 5, 1,0)   // Auxiliary Fault Status Register 0 [CP15_HDFSR]
#define ARM64_AFSR1_EL1         ARM64_SYSREG(3,0, 5, 1,1)   // Auxiliary Fault Status Register 1 [CP15_AIFSR]
#define ARM64_AFSR1_EL2         ARM64_SYSREG(3,4, 5, 1,1)   // Auxiliary Fault Status Register 1 [CP15_HAIFSR]

//
// ARM Cache Operations
//

#define ARM64_DCZID_EL0         ARM64_SYSREG(3,3, 0, 0,7)   // Data Cache Zero ID Register

// IC opcodes, or use with SYS
#define ARM64_IC_IALLUIS        ARM64_SYSREG(2,0, 7, 1,0)   // Invalidate all instruction caches to PoU Inner Shareable [CP15_ICIALLUIS]
#define ARM64_IC_IALLU          ARM64_SYSREG(2,0, 7, 5,0)   // Invalidate all instruction caches to PoU [CP15_ICIALLU]
#define ARM64_IC_IVAU           ARM64_SYSREG(2,3, 7, 5,1)   // Invalidate all instruction caches by MVA to PoU [CP15_ICIMVAU]

// DC opcodes, or use with SYS
#define ARM64_DC_ZVA            ARM64_SYSREG(2,3, 7, 4,1)   // Zero cache line at VA
#define ARM64_DC_IVAC           ARM64_SYSREG(2,0, 7, 6,1)   // Invalidate data cache line by VA to PoC [CP15_DCIMVAC]
#define ARM64_DC_ISW            ARM64_SYSREG(2,0, 7, 6,2)   // Invalidate data cache line by set/way [CP15_DCISW]
#define ARM64_DC_CVAC           ARM64_SYSREG(2,3, 7,10,1)   // Clean data cache line by VA to PoC [CP15_DCCMVAC]
#define ARM64_DC_CSW            ARM64_SYSREG(2,0, 7,10,2)   // Clean data cache line by set/way [CP15_DCCSW]
#define ARM64_DC_CVAU           ARM64_SYSREG(2,3, 7,11,1)   // Clean data cache line by VA to PoU [CP15_DCCMVAU]
#define ARM64_DC_CIVAC          ARM64_SYSREG(2,3, 7,14,1)   // Clean and invalidate data cache line by VA to PoC [CP15_DCCIMVAC]
#define ARM64_DC_CISW           ARM64_SYSREG(2,0, 7,14,2)   // Clean and invalidate data cache line by set/way [CP15_DCCISW]

//
// ARM Translation Operations
//

#define ARM64_PAR_EL1           ARM64_SYSREG(3,0, 7, 4,0)   // Physical Address Register (Translation Result) [CP15_PAR]

// AT opcodes, or use with SYS
#define ARM64_AT_S1E2R          ARM64_SYSREG(2,4, 7, 8,0)   // Translate Stage1, EL2, read
#define ARM64_AT_S1E2W          ARM64_SYSREG(2,4, 7, 8,1)   // Translate Stage1, EL2, write
#define ARM64_AT_S1E1R          ARM64_SYSREG(2,0, 7, 8,0)   // Translate Stage1, EL1, read
#define ARM64_AT_S1E1W          ARM64_SYSREG(2,0, 7, 8,1)   // Translate Stage1, EL1, write
#define ARM64_AT_S1E0R          ARM64_SYSREG(2,0, 7, 8,2)   // Translate Stage1, EL0, read
#define ARM64_AT_S1E0W          ARM64_SYSREG(2,0, 7, 8,3)   // Translate Stage1, EL0, write
#define ARM64_AT_S12E1R         ARM64_SYSREG(2,4, 7, 8,4)   // Translate Stage12, EL1, read
#define ARM64_AT_S12E1W         ARM64_SYSREG(2,4, 7, 8,5)   // Translate Stage12, EL1, write
#define ARM64_AT_S12E0R         ARM64_SYSREG(2,4, 7, 8,6)   // Translate Stage12, EL0, read
#define ARM64_AT_S12E0W         ARM64_SYSREG(2,4, 7, 8,7)   // Translate Stage12, EL0, write

//
// ARM Generic Timer registers
//

#define ARM64_CNTFRQ_EL0        ARM64_SYSREG(3,3,14, 0,0)   // Holds the clock frequency of the system counter
#define ARM64_CNTPCT_EL0        ARM64_SYSREG(3,3,14, 0,1)   // Holds the 64bit physical count value
#define ARM64_CNTVCT_EL0        ARM64_SYSREG(3,3,14, 0,2)   // Holds the 64bit virtual count value
#define ARM64_CNTV_OFF_EL2      ARM64_SYSREG(3,4,14, 0,3)   // Holds the 64bit virtual count offset value
#define ARM64_CNTP_TVAL_EL0     ARM64_SYSREG(3,3,14, 2,0)   // Holds the timer value for the El1 physical timer
#define ARM64_CNTP_CTL_EL0      ARM64_SYSREG(3,3,14, 2,1)   // Control register for the El1 physical timer
#define ARM64_CNTP_CVAL_EL0     ARM64_SYSREG(3,3,14, 2,2)   // Holds the compare value for the El1 physical timer
#define ARM64_CNTV_TVAL_EL0     ARM64_SYSREG(3,3,14, 3,0)   // Holds the timer value for the virtual timer
#define ARM64_CNTV_CTL_EL0      ARM64_SYSREG(3,3,14, 3,1)   // Control register for the virtual timer
#define ARM64_CNTV_CVAL_EL0     ARM64_SYSREG(3,3,14, 3,2)   // Holds the compare value for the virtual timer
#define ARM64_CNTK_CTL_EL1      ARM64_SYSREG(3,0,14, 1,0)   // Controls the generation of an event stream from the virtual counter, and access from EL0 to the physical counter, virtual counter, EL1 physical timers, and the virtual timer.
#define ARM64_CNT_HCTL_EL2      ARM64_SYSREG(3,4,14, 1,0)   // Counter-timer Hypervisor Control register
#define ARM64_CNTHP_TVAL_EL2    ARM64_SYSREG(3,4,14, 2,0)   // Counter-timer Hypervisor Physical Timer TimerValue register
#define ARM64_CNTHP_CTL_EL2     ARM64_SYSREG(3,4,14, 2,1)   // Counter-timer Hypervisor Physical Timer Control register
#define ARM64_CNTHP_CVAL_EL2    ARM64_SYSREG(3,4,14, 2,2)   // 64-bit, Counter-timer Hypervisor Physical Timer CompareValue register

#define ARM64_CNT_HCTL_EL1PCTEN    0x00000001
#define ARM64_CNT_HCTL_EL1PCEN     0x00000002
#define ARM64_CNT_HCTL_EVNTEN      0x00000004
#define ARM64_CNT_HCTL_EVNTDIR     0x00000008
#define ARM64_CNT_HCTL_EVNTI_MASK  0x000000F0
#define ARM64_CNT_HCTL_EVNTI_SHIFT 4

#define ARM64_CNT_CTL_ENABLE      0x00000001
#define ARM64_CNT_CTL_IMASK       0x00000002
#define ARM64_CNT_CTL_ISTATUS     0x00000004

#define ARM64_CNTK_CTL_EL0PCTEN   0x00000001 // Controls whether the physical counter, CNTPCT_EL0, and the frequency register CNTFRQ_EL0, are accessible from EL0 modes
#define ARM64_CNTK_CTL_EL0VCTEN   0x00000002 // Controls whether the virtual counter, CNTVCT_EL0, and the frequency register CNTFRQ_EL0, are accessible from EL0 modes
#define ARM64_CNTK_CTL_EVNTEN     0x00000004 // Enables the generation of an event stream from the corresponding counter
#define ARM64_CNTK_CTL_EVNTDIR    0x00000008 // Controls which transition of the counter register (CNTPCT_EL0 or CNTVCT_EL0) trigger bit, defined by EVNTI, generates an event when the event stream is enabled
#define ARM64_CNTK_CTL_EVNTI_MASK 0x000000F0 // Selects which bit (0 to 15) of the corresponding counter register (CNTPCT_EL0 or CNTVCT_EL0) is the trigger for the event stream generated from that counter, when that stream is enabled.
#define ARM64_CNTK_CTL_EL0VTEN    0x00000100 // Controls whether the virtual timer registers are accessible from EL0 modes
#define ARM64_CNTK_CTL_EL0PTEN    0x00000200 // Controls whether the physical timer registers are accessible from EL0 modes

//
// Structure describing the output retrieved from the ARM64_PAR_EL1 register.
//

typedef union _ARM64_PAR {
    ULONG64 Ulong;
    struct {
        ULONG64 Fault         :  1;
        ULONG64 FaultStatus   :  6;
        ULONG64 Shareability  :  2;
        ULONG64 Stage         :  1;
        ULONG64 ImplDefined   :  1;
        ULONG64 Res1          :  1;
        ULONG64 Pfn           : 36;
        ULONG64 Res0          :  8;
        ULONG64 Mair          :  8;
    };
} ARM64_PAR;

//
// TLB maintenance operations
//

// TLBI opcodes, or use with SYS
#define ARM64_TLBI_VMALLE1      ARM64_SYSREG(2,0, 8, 7,0)   // Invalidate unified TLB [CP15_TLBIALL]
#define ARM64_TLBI_VAE1         ARM64_SYSREG(2,0, 8, 7,1)   // Invalidate unified TLB entry by VA [CP15_TLBIMVA]
#define ARM64_TLBI_ASIDE1       ARM64_SYSREG(2,0, 8, 7,2)   // Invalidate unified TLB by ASID match [CP15_TLBIASID]
#define ARM64_TLBI_VAAE1        ARM64_SYSREG(2,0, 8, 7,3)   // Invalidate unified TLB entries by VA all ASID [CP15_TLBIMVAA]
#define ARM64_TLBI_VALE1        ARM64_SYSREG(2,0, 8, 7,5)   //
#define ARM64_TLBI_VAALE1       ARM64_SYSREG(2,0, 8, 7,7)   //
#define ARM64_TLBI_VMALLE1IS    ARM64_SYSREG(2,0, 8, 3,0)   // Invalidate entire TLB Inner Shareable [CP15_TLBIALLIS]
#define ARM64_TLBI_VAE1IS       ARM64_SYSREG(2,0, 8, 3,1)   // Invalidate unified TLB entry by VA Inner Shareable [CP15_TLBIMVAIS]
#define ARM64_TLBI_ASIDE1IS     ARM64_SYSREG(2,0, 8, 3,2)   // Invalidate unified TLB by ASID match Inner Shareable [CP15_TLBIASIDIS]
#define ARM64_TLBI_VAAE1IS      ARM64_SYSREG(2,0, 8, 3,3)   // Invalidate unified TLB entries by VA all ASID Inner Shareable [CP15_TLBIMVAAIS]
#define ARM64_TLBI_VALE1IS      ARM64_SYSREG(2,0, 8, 3,5)   //
#define ARM64_TLBI_VAALE1IS     ARM64_SYSREG(2,0, 8, 3,7)   //
#define ARM64_TLBI_ALLE2        ARM64_SYSREG(2,4, 8, 7,0)   // Invalidate unified TLB EL2
#define ARM64_TLBI_VAE2         ARM64_SYSREG(2,4, 8, 7,1)   // Invalidate EL2 regime stage 1 TLB entries for the given VA.
#define ARM64_TLBI_ALLE1        ARM64_SYSREG(2,4, 8, 7,4)   // Invalidate unified TLB EL1 (Stage 1 and 2)
#define ARM64_TLBI_VMALLS12E1IS ARM64_SYSREG(2,4, 8, 3,6)   // Invalidate by VMID, All entries at Stage 1 and 2, EL1, Inner Shareable

//
// TLB maintenance definitions and masks
//

#define ARM64_TLBI_ASID_SHIFT   48
#define ARM64_TLBI_VA_MASK      0x00fffffffffff000ULL

//
// Performance counter registers
//

#define ARM64_PMCCFILTR_EL0     ARM64_SYSREG(3,3,14,15,7)  // Performance Monitors Cycle Count Filter Register [CP15_PMCCFILTR]
#define ARM64_MDCR_EL2          ARM64_SYSREG(3,4, 1, 1,1)  // Monitor Debug Configuration Register (EL2) [CP15_HDCR]
#define ARM64_PMCR_EL0          ARM64_SYSREG(3,3, 9,12,0)  // Performance Monitor Control Register [CP15_PMCR]
#define ARM64_PMCNTENSET_EL0    ARM64_SYSREG(3,3, 9,12,1)  // Count Enable Set Register [CP15_PMCNTENSET]
#define ARM64_PMCNTENCLR_EL0    ARM64_SYSREG(3,3, 9,12,2)  // Count Enable Clear Register [CP15_PMCNTENCLR]
#define ARM64_PMOVSCLR_EL0      ARM64_SYSREG(3,3, 9,12,3)  // Overflow Flag Status Register [CP15_PMOVSR]
#define ARM64_PMSWINC_EL0       ARM64_SYSREG(3,3, 9,12,4)  // Software Increment Register [CP15_PSWINC]
#define ARM64_PMSELR_EL0        ARM64_SYSREG(3,3, 9,12,5)  // Event Counter Selection Register [CP15_PMSELR]
#define ARM64_PMCCNTR_EL0       ARM64_SYSREG(3,3, 9,13,0)  // Cycle Count Register [CP15_PMCCNTR]
#define ARM64_PMXEVTYPER_EL0    ARM64_SYSREG(3,3, 9,13,1)  // Event Type Select Register [CP15_PMXEVTYPER]
#define ARM64_PMXEVTYPERn_EL0(n) ARM64_SYSREG(3,3,14, 12+((n)/8), (n)%8)    // Direct Event Type Select Register [n/a]
#define ARM64_PMXEVCNTR_EL0     ARM64_SYSREG(3,3, 9,13,2)  // Event Count Register [CP15_PMXEVCNTR]
#define ARM64_PMXEVCNTRn_EL0(n) ARM64_SYSREG(3,3,14, 8+((n)/8), (n)%8)    // Direct Event Count Register [n/a]
#define ARM64_PMUSERENR_EL0     ARM64_SYSREG(3,3, 9,14,0)  // User Enable Register [CP15_PMUSERENR]
#define ARM64_PMINTENSET_EL1    ARM64_SYSREG(3,0, 9,14,1)  // Interrupt Enable Set Register [CP15_PMINTENSET]
#define ARM64_PMINTENCLR_EL1    ARM64_SYSREG(3,0, 9,14,2)  // Interrupt Enable Clear Register [CP15_PMINTENCLR]

//
// Memory remap registers
//

#define ARM64_MAIR_EL1          ARM64_SYSREG(3,0,10, 2,0)  // Primary Region Remap Register [CP15_PRRR/CP15_NMRR]
#define ARM64_AMAIR_EL1         ARM64_SYSREG(3,0,10, 3,0)  // Auxiliary Region Remap Register [CP15_AMAIR0/CP15_AMAIR1]
#define ARM64_MAIR_EL2          ARM64_SYSREG(3,4,10, 2,0)  // Primary Region Remap Register [CP15_HMAIR0/CP15_HMAIR1]
#define ARM64_AMAIR_EL2         ARM64_SYSREG(3,4,10, 3,0)  // Auxiliary Region Remap Register [CP15_HAMAIR0/CP15_HAMAIR1]

//
// Security extensions registers
//

#define ARM64_VBAR_EL1          ARM64_SYSREG(3,0,12, 0,0)  // Vector Base Address Register [CP15_VBAR]
#define ARM64_VBAR_EL2          ARM64_SYSREG(3,4,12, 0,0)  // Vector Base Address Register [CP15_HVBAR]
#define ARM64_ISR_EL1           ARM64_SYSREG(3,0,12, 1,0)  // Interrupt Status Register [CP15_ISR]

//
// Process, context and thread ID registers
//

#define ARM64_TPIDR_EL0         ARM64_SYSREG(3,3,13, 0,2)  // Thread ID Register, User Read/Write [CP15_TPIDRURW]
#define ARM64_TPIDRRO_EL0       ARM64_SYSREG(3,3,13, 0,3)  // Thread ID Register, User Read Only [CP15_TPIDRURO]
#define ARM64_TPIDR_EL1         ARM64_SYSREG(3,0,13, 0,4)  // Thread ID Register, Privileged Only [CP15_TPIDRPRW]
#define ARM64_TPIDR_EL2         ARM64_SYSREG(3,4,13, 0,2)  // Thread ID Register, Hypervisor Only [CP15_HTPIDR]
#define ARM64_CONTEXTIDR_EL1    ARM64_SYSREG(3,0,13, 0,1)  // Context ID Register

//
// Cache information registers
//

#define ARM64_CCSIDR_EL1        ARM64_SYSREG(3,1, 0, 0,0)  // Cache Size ID Register [CP15_CCSIDR]
#define ARM64_CLIDR_EL1         ARM64_SYSREG(3,1, 0, 0,1)  // Cache Level ID Register [CP15_CLIDR]
#define ARM64_AIDR_EL1          ARM64_SYSREG(3,1, 0, 0,7)  // Auxiliary ID Register [CP15_AIDR]
#define ARM64_CSSELR_EL1        ARM64_SYSREG(3,2, 0, 0,0)  // Cache Size Selection Register [CP15_CSSELR]

//
// Generic Timer Registers
//

#define ARM64_CNTVCT            ARM64_SYSREG(3,3,14, 0,2)
#define ARM64_CNTKCTL           ARM64_SYSREG(3,0,14, 1,0)
#define ARM64_CNTV_CTL          ARM64_SYSREG(3,3,14, 3,1)
#define ARM64_CNTV_CVAL         ARM64_SYSREG(3,3,14, 3,2)

//
// CP14 debugging registers
//

#define ARM64_MDCCSR_EL0        ARM64_SYSREG(2,3, 0, 1,0)  // Debug Comms Channel Status Register (internal view) [CP14_DBGDSCRint]
#define ARM64_DBGDTRRX_EL0      ARM64_SYSREG(2,3, 0, 5,0)  // Host to Target Data Transfer Register (internal view) [CP14_DBGDTRRXint]
#define ARM64_DBGDTRTX_EL0      ARM64_DBGDTRRX_EL0         // Target to Host Data Transfer Register (internal view) [CP14_DBGDTRTXint]
#define ARM64_OSDTRRX_EL1       ARM64_SYSREG(2,0, 0, 0,2)  // Host to Target Data Transfer Register [CP14_DBGDTRRX]
#define ARM64_MDSCR_EL1         ARM64_SYSREG(2,0, 0, 2,2)  // Debug Status and Control Register (external view) [CP14_DBGDSCR]
#define ARM64_OSDTRTX_EL1       ARM64_SYSREG(2,0, 0, 3,2)  // Target to Host Data Transfer Register [CP14_DBGDTRTX]
#define ARM64_DBGBVR0_EL1       ARM64_SYSREG(2,0, 0, 0,4)  // Breakpoint Value Register 0 [CP14_DBGBVRn]
#define ARM64_DBGBVR1_EL1       ARM64_SYSREG(2,0, 0, 1,4)  // ...
#define ARM64_DBGBVR2_EL1       ARM64_SYSREG(2,0, 0, 2,4)  // ...
#define ARM64_DBGBVR3_EL1       ARM64_SYSREG(2,0, 0, 3,4)  // ...
#define ARM64_DBGBVR4_EL1       ARM64_SYSREG(2,0, 0, 4,4)  // ...
#define ARM64_DBGBVR5_EL1       ARM64_SYSREG(2,0, 0, 5,4)  // ...
#define ARM64_DBGBVR6_EL1       ARM64_SYSREG(2,0, 0, 6,4)  // ...
#define ARM64_DBGBVR7_EL1       ARM64_SYSREG(2,0, 0, 7,4)  // ...
#define ARM64_DBGBVR8_EL1       ARM64_SYSREG(2,0, 0, 8,4)  // ...
#define ARM64_DBGBVR9_EL1       ARM64_SYSREG(2,0, 0, 9,4)  // ...
#define ARM64_DBGBVR10_EL1      ARM64_SYSREG(2,0, 0,10,4)  // ...
#define ARM64_DBGBVR11_EL1      ARM64_SYSREG(2,0, 0,11,4)  // ...
#define ARM64_DBGBVR12_EL1      ARM64_SYSREG(2,0, 0,12,4)  // ...
#define ARM64_DBGBVR13_EL1      ARM64_SYSREG(2,0, 0,13,4)  // ...
#define ARM64_DBGBVR14_EL1      ARM64_SYSREG(2,0, 0,14,4)  // ...
#define ARM64_DBGBVR15_EL1      ARM64_SYSREG(2,0, 0,15,4)  // ...
#define ARM64_DBGBCR0_EL1       ARM64_SYSREG(2,0, 0, 0,5)  // Breakpoint Value Register 0 [CP14_DBGBCRn]
#define ARM64_DBGBCR1_EL1       ARM64_SYSREG(2,0, 0, 1,5)  // ...
#define ARM64_DBGBCR2_EL1       ARM64_SYSREG(2,0, 0, 2,5)  // ...
#define ARM64_DBGBCR3_EL1       ARM64_SYSREG(2,0, 0, 3,5)  // ...
#define ARM64_DBGBCR4_EL1       ARM64_SYSREG(2,0, 0, 4,5)  // ...
#define ARM64_DBGBCR5_EL1       ARM64_SYSREG(2,0, 0, 5,5)  // ...
#define ARM64_DBGBCR6_EL1       ARM64_SYSREG(2,0, 0, 6,5)  // ...
#define ARM64_DBGBCR7_EL1       ARM64_SYSREG(2,0, 0, 7,5)  // ...
#define ARM64_DBGBCR8_EL1       ARM64_SYSREG(2,0, 0, 8,5)  // ...
#define ARM64_DBGBCR9_EL1       ARM64_SYSREG(2,0, 0, 9,5)  // ...
#define ARM64_DBGBCR10_EL1      ARM64_SYSREG(2,0, 0,10,5)  // ...
#define ARM64_DBGBCR11_EL1      ARM64_SYSREG(2,0, 0,11,5)  // ...
#define ARM64_DBGBCR12_EL1      ARM64_SYSREG(2,0, 0,12,5)  // ...
#define ARM64_DBGBCR13_EL1      ARM64_SYSREG(2,0, 0,13,5)  // ...
#define ARM64_DBGBCR14_EL1      ARM64_SYSREG(2,0, 0,14,5)  // ...
#define ARM64_DBGBCR15_EL1      ARM64_SYSREG(2,0, 0,15,5)  // ...
#define ARM64_DBGWVR0_EL1       ARM64_SYSREG(2,0, 0, 0,6)  // Watchpoint Value Register 0 [CP14_DBGWVRn]
#define ARM64_DBGWVR1_EL1       ARM64_SYSREG(2,0, 0, 1,6)  // ...
#define ARM64_DBGWVR2_EL1       ARM64_SYSREG(2,0, 0, 2,6)  // ...
#define ARM64_DBGWVR3_EL1       ARM64_SYSREG(2,0, 0, 3,6)  // ...
#define ARM64_DBGWVR4_EL1       ARM64_SYSREG(2,0, 0, 4,6)  // ...
#define ARM64_DBGWVR5_EL1       ARM64_SYSREG(2,0, 0, 5,6)  // ...
#define ARM64_DBGWVR6_EL1       ARM64_SYSREG(2,0, 0, 6,6)  // ...
#define ARM64_DBGWVR7_EL1       ARM64_SYSREG(2,0, 0, 7,6)  // ...
#define ARM64_DBGWVR8_EL1       ARM64_SYSREG(2,0, 0, 8,6)  // ...
#define ARM64_DBGWVR9_EL1       ARM64_SYSREG(2,0, 0, 9,6)  // ...
#define ARM64_DBGWVR10_EL1      ARM64_SYSREG(2,0, 0,10,6)  // ...
#define ARM64_DBGWVR11_EL1      ARM64_SYSREG(2,0, 0,11,6)  // ...
#define ARM64_DBGWVR12_EL1      ARM64_SYSREG(2,0, 0,12,6)  // ...
#define ARM64_DBGWVR13_EL1      ARM64_SYSREG(2,0, 0,13,6)  // ...
#define ARM64_DBGWVR14_EL1      ARM64_SYSREG(2,0, 0,14,6)  // ...
#define ARM64_DBGWVR15_EL1      ARM64_SYSREG(2,0, 0,15,6)  // ...
#define ARM64_DBGWCR0_EL1       ARM64_SYSREG(2,0, 0, 0,7)  // Watchpoint Value Register 0 [CP14_DBGWCRn]
#define ARM64_DBGWCR1_EL1       ARM64_SYSREG(2,0, 0, 1,7)  // ...
#define ARM64_DBGWCR2_EL1       ARM64_SYSREG(2,0, 0, 2,7)  // ...
#define ARM64_DBGWCR3_EL1       ARM64_SYSREG(2,0, 0, 3,7)  // ...
#define ARM64_DBGWCR4_EL1       ARM64_SYSREG(2,0, 0, 4,7)  // ...
#define ARM64_DBGWCR5_EL1       ARM64_SYSREG(2,0, 0, 5,7)  // ...
#define ARM64_DBGWCR6_EL1       ARM64_SYSREG(2,0, 0, 6,7)  // ...
#define ARM64_DBGWCR7_EL1       ARM64_SYSREG(2,0, 0, 7,7)  // ...
#define ARM64_DBGWCR8_EL1       ARM64_SYSREG(2,0, 0, 8,7)  // ...
#define ARM64_DBGWCR9_EL1       ARM64_SYSREG(2,0, 0, 9,7)  // ...
#define ARM64_DBGWCR10_EL1      ARM64_SYSREG(2,0, 0,10,7)  // ...
#define ARM64_DBGWCR11_EL1      ARM64_SYSREG(2,0, 0,11,7)  // ...
#define ARM64_DBGWCR12_EL1      ARM64_SYSREG(2,0, 0,12,7)  // ...
#define ARM64_DBGWCR13_EL1      ARM64_SYSREG(2,0, 0,13,7)  // ...
#define ARM64_DBGWCR14_EL1      ARM64_SYSREG(2,0, 0,14,7)  // ...
#define ARM64_DBGWCR15_EL1      ARM64_SYSREG(2,0, 0,15,7)  // ...
#define ARM64_OSLAR_EL1         ARM64_SYSREG(2,0, 1, 0,4)  // OS Lock Access Register [CP14_DBGOSLAR]
#define ARM64_OSLSR_EL1         ARM64_SYSREG(2,0, 1, 1,4)  // OS Lock Status Register [CP14_DBGOSLSR]
#define ARM64_OSDLR_EL1         ARM64_SYSREG(2,0, 1, 3,4)  // OS Double Lock Register [CP14_DBGOSDLR]
#define ARM64_DBGPRCR_EL1       ARM64_SYSREG(2,0, 1, 4,4)  // Debug Power/Reset Control Register

#define ARM64_OSLSR_LOCK_IMP    0x1
#define ARM64_OSLSR_LOCKED      0x2



//
// ARM Feature ID Codes
//
// These nibble-offsets define which nibble in a control register
// is used to determine the existance of a feature.
//

#define READ_ARM64_FEATURE(_FeatureRegister, _Index) \
        (((ULONG64)_ReadStatusReg(_FeatureRegister) >> ((_Index) * 4)) & 0xF)

#define AFR0_EL0_EXCEPTIONS         0
#define AFR0_EL1_EXCEPTIONS         1
#define AFR0_EL2_EXCEPTIONS         2
#define AFR0_EL3_EXCEPTIONS         3
#define AFR0_ELn_EXCEPTIONS_NI      0
#define AFR0_ELn_EXCEPTIONS_64ONLY  1
#define AFR0_ELn_EXCEPTIONS_64OR32  2

#define AFR0_FLOATING_POINT         4
#define AFR0_FLOATING_POINT_IMP     0
#define AFR0_FLOATING_POINT_NI      15

#define AFR0_ADVANCED_SIMD          5
#define AFR0_ADVANCED_SIMD_IMP      0
#define AFR0_ADVANCED_SIMD_NI       15

#define DFR0_ARCH_VERSION           0
#define DFR0_ARCH_VERSION_V8A       6

#define DFR0_TRACE_VERSION          1
#define DFR0_TRACE_VERSION_NI       0
#define DFR0_TRACE_VERSION_IMP      1

#define DFR0_PERFMON_VERSION        2
#define DFR0_PERFMON_VERSION_NI     0
#define DFR0_PERFMON_VERSION_V3     1
#define DFR0_PERFMON_VERSION_UNK    15

#define DFR0_BREAKPOINT_COUNT       3

#define DFR0_WATCHPOINT_COUNT       5

#define DFR0_CONTEXT_BP_COUNT       7

#define MMFR0_ADDRESS_BITS          0
#define MMFR0_ADDRESS_BITS_32       0
#define MMFR0_ADDRESS_BITS_36       1
#define MMFR0_ADDRESS_BITS_40       2
#define MMFR0_ADDRESS_BITS_42       3
#define MMFR0_ADDRESS_BITS_44       4
#define MMFR0_ADDRESS_BITS_48       5

#define MMFR0_ASID_BITS             1
#define MMFR0_ASID_BITS_8           0
#define MMFR0_ASID_BITS_16          2

#define MMFR0_MIXED_ENDIAN          2
#define MMFR0_MIXED_ENDIAN_NI       0
#define MMFR0_MIXED_ENDIAN_IMP      1

#define MMFR0_SECURE_MEMORY         3
#define MMFR0_SECURE_MEMORY_NI      0
#define MMFR0_SECURE_MEMORY_IMP     1

#define MMFR0_MIXED_ENDIAN_EL0      4
#define MMFR0_MIXED_ENDIAN_EL0_NI   0
#define MMFR0_MIXED_ENDIAN_EL0_IMP  1

#define ISAR0_AES                   1
#define ISAR0_AES_NI                0
#define ISAR0_AES_INSTRUCTIONS      1
#define ISAR0_AES_PLUS_PMULL64      2

#define ISAR0_SHA1                  2
#define ISAR0_SHA1_NI               0
#define ISAR0_SHA1_INSTRUCTIONS     1

#define ISAR0_SHA2                  3
#define ISAR0_SHA2_NI               0
#define ISAR0_SHA2_INSTRUCTIONS     1

#define ISAR0_CRC32                 4
#define ISAR0_CRC32_NI              0
#define ISAR0_CRC32_INSTRUCTIONS    1


//
// VFP sub-architecture is really bits 16-22 (0x007F0000), however, bit 22
// is used to indicate if the subarchitecture was designed by ARM, so all we
// really need to look at are bits 16-21
//
// VFPv3 indicates "The entire floating-point implementation is in
// hardware, and no software support code is required."
//
/*
#define CPVFP_FPSID_SW                  0x00800000      // Software-only floating-point

#define CPVFP_FPEXC_EX                  0x80000000      // Extra state required for context save
#define CPVFP_FPEXC_EN                  0x40000000      // VFP/Advanced SIMD enable
#define CPVFP_FPEXC_DEX                 0x20000000      // synchronous exception flag
#define CPVFP_FPEXC_FP2V                0x10000000      // FPINST2 is valid
*/
#define ARM64_CPACR_VFP_MASK            0x00300000      // Mask for enabling/disabling VFP/NEON access
#define ARM64_CPACR_VFP_MASK_BIT        20              // Index of low bit for TBNZ purposes

#define ARM64_CPTR_VFP_USERMODE         0x00000400      // Enable CP10/CP11 in user mode

#define ARM64_CPTR_TFP                  0x00000400      // Trap Floating Point instructions from EL0/1 to EL2 that are not trapped to EL1.
#define ARM64_CPTR_TTA                  0x00100000      // Trap Trace functionality to EL2 when executed from EL0/1
#define ARM64_CPTR_CPAC                 0x80000000      // Trap direct access to CPACR or CPACR_EL1 from EL1 to EL2
#define ARM64_CPTR_RES1_BITS            0x000033FF      // Bits in CPTR_ELx that are RES1

//
// Coprocessor registers for ARMv7 cache hierarchy information
//

#define ARM_MPIDR_U                   0x40000000
#define ARM_MPIDR_MT                  0x01000000

//
// Constants for flags in system control register.
//

#define ARM64_SCTLR_M                    0x00000001
#define ARM64_SCTLR_A                    0x00000002
#define ARM64_SCTLR_C                    0x00000004
#define ARM64_SCTLR_SA                   0x00000008 /* ARMv7: was W */
#define ARM64_SCTLR_SA0                  0x00000010 /* ARMv7: was P */
#define ARM64_SCTLR_CP15BEN              0x00000020 /* ARMv7: was D */
#define ARM64_SCTLR_THEE                 0x00000040 /* ARMv7: was L */
#define ARM64_SCTLR_ITD                  0x00000080 /* ARMv7: was B */
#define ARM64_SCTLR_SED                  0x00000100 /* ARMv7: was S */
#define ARM64_SCTLR_UMA                  0x00000200 /* ARMv7: was R */
#define ARM64_SCTLR_RES0_10              0x00000400 /* ARMv7: was F */
#define ARM64_SCTLR_RES1_11              0x00000800 /* ARMv7: was Z */
#define ARM64_SCTLR_I                    0x00001000
#define ARM64_SCTLR_RES0_13              0x00002000 /* ARMv7: was V */
#define ARM64_SCTLR_DZE                  0x00004000 /* ARMv7: was RR */
#define ARM64_SCTLR_UCT                  0x00008000 /* ARMv7: was L4 */
#define ARM64_SCTLR_nTWI                 0x00010000 /* ARMv7: was DT */
#define ARM64_SCTLR_RES0_17              0x00020000
#define ARM64_SCTLR_nTWE                 0x00040000 /* ARMv7: was IT */
#define ARM64_SCTLR_WXN                  0x00080000
#define ARM64_SCTLR_RES1_20              0x00100000
#define ARM64_SCTLR_RES0_21              0x00200000 /* ARMv7: was FI */
#define ARM64_SCTLR_RES1_22              0x00400000 /* ARMv7: was U */
#define ARM64_SCTLR_RES1_23              0x00800000 /* ARMv7: was XP */
#define ARM64_SCTLR_E0E                  0x01000000 /* ARMv7: was VE */
#define ARM64_SCTLR_EE                   0x02000000
#define ARM64_SCTLR_UCI                  0x04000000 /* ARMv7: was L2 */
#define ARM64_SCTLR_RES0_27              0x08000000 /* ARMv7: was NM */
#define ARM64_SCTLR_RES1_28              0x10000000 /* ARMv7: was TR */
#define ARM64_SCTLR_RES1_29              0x20000000 /* ARMv7: was AF */
#define ARM64_SCTLR_RES0_30              0x40000000 /* ARMv7: was TE */
#define ARM64_SCTLR_RES0_31              0x80000000 /* ARMv7: was X3 */

//
// Processor feature register definitions and masks
//

#define ARM64_PFR0_EL1_EL0_MASK          0x000000000000000F
#define ARM64_PFR0_EL1_EL1_MASK          0x00000000000000F0
#define ARM64_PFR0_EL1_EL2_MASK          0x0000000000000F00
#define ARM64_PFR0_EL1_EL3_MASK          0x000000000000F000
#define ARM64_PFR0_EL1_FP_MASK           0x00000000000F0000
#define ARM64_PFR0_EL1_ADVSIMD_MASK      0x0000000000F00000
#define ARM64_PFR0_EL1_GIC_MASK          0x000000000F000000


//
// Translation table base register definitions and masks
//

#define ARM64_TTBRx_BADDR_MASK     0x0000ffffffffffffULL
#define ARM64_TTBRx_ASID_MASK      0xffff000000000000ULL
#define ARM64_TTBRx_ASID_SHIFT     48

//
// Constants for flags in the hypervisor control register
//

#define ARM64_HCR_EL2_VM                0x000000000000001ULL
#define ARM64_HCR_EL2_SWIO              0x000000000000002ULL
#define ARM64_HCR_EL2_PTW               0x000000000000004ULL
#define ARM64_HCR_EL2_FMO               0x000000000000008ULL
#define ARM64_HCR_EL2_IMO               0x000000000000010ULL
#define ARM64_HCR_EL2_AMO               0x000000000000020ULL
#define ARM64_HCR_EL2_VF                0x000000000000040ULL
#define ARM64_HCR_EL2_VI                0x000000000000080ULL
#define ARM64_HCR_EL2_VSE               0x000000000000100ULL
#define ARM64_HCR_EL2_FB                0x000000000000200ULL
#define ARM64_HCR_EL2_BSU_NONE          0x000000000000000ULL
#define ARM64_HCR_EL2_BSU_ISH           0x000000000000400ULL
#define ARM64_HCR_EL2_BSU_OSH           0x000000000000800ULL
#define ARM64_HCR_EL2_BSU_FS            0x000000000000C00ULL
#define ARM64_HCR_EL2_BSU_MASK          0x000000000000C00ULL
#define ARM64_HCR_EL2_DC                0x000000000001000ULL
#define ARM64_HCR_EL2_TWI               0x000000000002000ULL
#define ARM64_HCR_EL2_TWE               0x000000000004000ULL
#define ARM64_HCR_EL2_TID0              0x000000000008000ULL
#define ARM64_HCR_EL2_TID1              0x000000000010000ULL
#define ARM64_HCR_EL2_TID2              0x000000000020000ULL
#define ARM64_HCR_EL2_TID3              0x000000000040000ULL
#define ARM64_HCR_EL2_TSC               0x000000000080000ULL
#define ARM64_HCR_EL2_TIDCP             0x000000000100000ULL
#define ARM64_HCR_EL2_TACR              0x000000000200000ULL
#define ARM64_HCR_EL2_TSW               0x000000000400000ULL
#define ARM64_HCR_EL2_TPC               0x000000000800000ULL
#define ARM64_HCR_EL2_TPU               0x000000001000000ULL
#define ARM64_HCR_EL2_TTLB              0x000000002000000ULL
#define ARM64_HCR_EL2_TVM               0x000000004000000ULL
#define ARM64_HCR_EL2_TGE               0x000000008000000ULL
#define ARM64_HCR_EL2_TDZ               0x000000010000000ULL
#define ARM64_HCR_EL2_HCD               0x000000020000000ULL
#define ARM64_HCR_EL2_TRVM              0x000000040000000ULL
#define ARM64_HCR_EL2_RW                0x000000080000000ULL
#define ARM64_HCR_EL2_CD                0x000000100000000ULL
#define ARM64_HCR_EL2_ID                0x000000200000000ULL


//
// Constants for flags in translation control register.
// (configured so that hardware page table walks are cached)
//

#define ARM64_TCR_T0SZ_MASK             0x000000000000003fULL
#define ARM64_TCR_RES0_1                0x0000000000000040ULL
#define ARM64_TCR_EPD0                  0x0000000000000080ULL
#define ARM64_TCR_IRGN0_NC              0x0000000000000000ULL
#define ARM64_TCR_IRGN0_WBWA            0x0000000000000100ULL
#define ARM64_TCR_IRGN0_WT              0x0000000000000200ULL
#define ARM64_TCR_IRGN0_WB              0x0000000000000300ULL
#define ARM64_TCR_IRGN0_MASK            0x0000000000000300ULL
#define ARM64_TCR_ORGN0_NC              0x0000000000000000ULL
#define ARM64_TCR_ORGN0_WBWA            0x0000000000000400ULL
#define ARM64_TCR_ORGN0_WT              0x0000000000000800ULL
#define ARM64_TCR_ORGN0_WB              0x0000000000000c00ULL
#define ARM64_TCR_ORGN0_MASK            0x0000000000000c00ULL
#define ARM64_TCR_SH0_NON_SHARED        0x0000000000000000ULL
#define ARM64_TCR_SH0_OUTER_SHARED      0x0000000000002000ULL
#define ARM64_TCR_SH0_INNER_SHARED      0x0000000000003000ULL
#define ARM64_TCR_SH0_MASK              0x0000000000003000ULL
#define ARM64_TCR_TG0_4K                0x0000000000000000ULL
#define ARM64_TCR_TG0_16K               0x0000000000008000ULL
#define ARM64_TCR_TG0_64K               0x0000000000004000ULL
#define ARM64_TCR_TG0_RESERVED          0x000000000000c000ULL
#define ARM64_TCR_TG0_MASK              0x000000000000c000ULL

#define ARM64_TCR_T1SZ_MASK             0x00000000003f0000ULL
#define ARM64_TCR_A1                    0x0000000000400000ULL
#define ARM64_TCR_EPD1                  0x0000000000800000ULL
#define ARM64_TCR_IRGN1_NC              0x0000000000000000ULL
#define ARM64_TCR_IRGN1_WBWA            0x0000000001000000ULL
#define ARM64_TCR_IRGN1_WT              0x0000000002000000ULL
#define ARM64_TCR_IRGN1_WB              0x0000000003000000ULL
#define ARM64_TCR_IRGN1_MASK            0x0000000003000000ULL
#define ARM64_TCR_ORGN1_NC              0x0000000000000000ULL
#define ARM64_TCR_ORGN1_WBWA            0x0000000004000000ULL
#define ARM64_TCR_ORGN1_WT              0x0000000008000000ULL
#define ARM64_TCR_ORGN1_WB              0x000000000c000000ULL
#define ARM64_TCR_ORGN1_MASK            0x000000000c000000ULL
#define ARM64_TCR_SH1_NON_SHARED        0x0000000000000000ULL
#define ARM64_TCR_SH1_OUTER_SHARED      0x0000000020000000ULL
#define ARM64_TCR_SH1_INNER_SHARED      0x0000000030000000ULL
#define ARM64_TCR_SH1_MASK              0x0000000030000000ULL
#define ARM64_TCR_TG1_4K                0x0000000080000000ULL
#define ARM64_TCR_TG1_16K               0x0000000040000000ULL
#define ARM64_TCR_TG1_64K               0x00000000c0000000ULL
#define ARM64_TCR_TG1_RESERVED          0x0000000000000000ULL
#define ARM64_TCR_TG1_MASK              0x00000000c0000000ULL

#define ARM64_TCR_IPASize_4G            0x0000000000000000ULL
#define ARM64_TCR_IPASize_64G           0x0000000100000000ULL
#define ARM64_TCR_IPASize_1T            0x0000000200000000ULL
#define ARM64_TCR_IPASize_4T            0x0000000300000000ULL
#define ARM64_TCR_IPASize_16T           0x0000000400000000ULL
#define ARM64_TCR_IPASize_256T          0x0000000500000000ULL
#define ARM64_TCR_IPASize_MASK          0x0000000700000000ULL
#define ARM64_TCR_RES0_35               0x0000000800000000ULL
#define ARM64_TCR_AS                    0x0000001000000000ULL
#define ARM64_TCR_TBI0                  0x0000002000000000ULL
#define ARM64_TCR_TBI1                  0x0000004000000000ULL

#define ARM64_TCR_T0SZ_SHIFT            0
#define ARM64_TCR_T1SZ_SHIFT            16
#define ARM64_TCR_IPASize_SHIFT         32


//
// Constants for flags in translation control register for EL2.
// (HTCR) that are different from the EL1 version of this register.
//

#define ARM64_TCR_PASize_4G             0x00000000
#define ARM64_TCR_PASize_64G            0x00010000
#define ARM64_TCR_PASize_1T             0x00020000
#define ARM64_TCR_PASize_4T             0x00030000
#define ARM64_TCR_PASize_16T            0x00040000
#define ARM64_TCR_PASize_256T           0x00050000
#define ARM64_TCR_PASize_MASK           0x00070000

#define ARM64_TCR_EL2_TBI               0x00100000
#define ARM64_TCR_EL2_PASize_SHIFT      16

/*
//
// Fault status syndrome masks
//

#define CP15_xFSR_FS_LOW                0x0000000f
#define CP15_xFSR_FS_HIGH               0x00000400
#define CP15_DFSR_WnR                   0x00000800
*/
//
// Performance counter register bits
//

#define ARM64_PMCR_N_MASK               0x0000f800
#define ARM64_PMCR_N_SHIFT              11
#define ARM64_PMCR_LC                   0x00000040
#define ARM64_PMCR_DP                   0x00000020
#define ARM64_PMCR_X                    0x00000010
#define ARM64_PMCR_D                    0x00000008
#define ARM64_PMCR_C                    0x00000004
#define ARM64_PMCR_P                    0x00000002
#define ARM64_PMCR_E                    0x00000001


#define ARM64_PMCNTEN_PMCCNT            0x80000000

//
// Performance counter user-enable register bits
//

#define ARM64_PMUSERENR_EN              0x00000001
#define ARM64_PMUSERENR_SW              0x00000002
#define ARM64_PMUSERENR_CR              0x00000004
#define ARM64_PMUSERENR_ER              0x00000008

//
// Performance filter register bits
//

#define ARM64_PMCCFILTR_M               0x04000000
#define ARM64_PMCCFILTR_NSH             0x08000000
#define ARM64_PMCCFILTR_NSU             0x10000000
#define ARM64_PMCCFILTR_NSK             0x20000000
#define ARM64_PMCCFILTR_U               0x40000000
#define ARM64_PMCCFILTR_P               0x80000000

//
// Monitor Debug Configuration Register bits
//

#define ARM64_MDCR_HPMN_MASK            0x0000001F
#define ARM64_MDCR_TPMCR                0x00000020
#define ARM64_MDCR_TPM                  0x00000040
#define ARM64_MDCR_HPME                 0x00000080
#define ARM64_MDCR_TDE                  0x00000100
#define ARM64_MDCR_TDA                  0x00000200
#define ARM64_MDCR_TDOSA                0x00000400
#define ARM64_MDCR_TDRA                 0x00000800


CFORCEINLINE
VOID
_SyncPte (
    VOID
    )
{
    //
    // If the PTE that was changed was already in the valid state, then
    // DSB and ISB memory barriers must be issued as per the ARM ARM B3.10.5
    // specification.
    //
    // If the PTE was invalid and is being made valid then the DSB
    // and ISB is also required.  The ISB is needed to guarantee as
    // per the ARM ARM revC section B3.10.1 that the translation
    // table walk (caused by a subsequent explicit load or store)
    // will see the updated translation.  Typically this is not necessary
    // because the fault handler would be invoked & see the PTE is valid
    // and hence dismiss the fault (and the exception return implies an
    // implicit ISB).  But if the created PTE was being used
    // for a nonpaged mapping and the caller did not expect to fault (ie
    // is at raised IRQL or holds working set synchronization, etc) then
    // we cannot defer this to the fault handler hence we always issue
    // the ISB explicitly here.
    //
    // Of course if the PTE was being changed from one invalid state to
    // another, no call to this function is issued at all.
    //

    _DataSynchronizationBarrier();

    _InstructionSynchronizationBarrier();
}

//
// The hardware fault status registers DFSR and IFSR contain fields
// that can describe up to 64 different fault sources/causes.  To
// address the large number and the inconvenient encoding, we map
// these sources to an internal software fault status representation.
//

// ARM64_WORKITEM: Update these to match new behavior
#define SWFS_WRITE                      0x01
#define SWFS_EXECUTE                    0x08
#define SWFS_PAGE_FAULT                 0x10
#define SWFS_ALIGN_FAULT                0x20
#define SWFS_HWERR_FAULT                0x40
#define SWFS_DEBUG_FAULT                0x80


//
// Remap register settings.  Goal is to remap the 3 attribute bits
// down to 2 attributes plus one OS-managed bit.
//

// ARM64: double-check these -- are they right?

//
// Memory attribute indirection register settings. Goal is to provide
// memory attribute encodings corresponding to the possible AttrIndx values in
// Long-descriptor format translation table entry for stage 1 translations.
//

//
// The memory types are encoded as follows:
//         Attr0           Cached normal memory
//         Attr1           Device-nGnRnE memory (uncached, Strongly ordered)
//         Attr2           UNUSED
//         Attr3           Non-Cacheable normal memory (similar to WC)
//

#define ARM64_MAIR_CACHE_WBWA       0xff
#define ARM64_MAIR_CACHE_NC         0x00
#define ARM64_MAIR_CACHE_WTNA       0xbb
#define ARM64_MAIR_CACHE_WC         0x44

#define ARM64_MAIR_DEFAULT \
    (((ULONG64) ARM64_MAIR_CACHE_WBWA <<  0) | \
     ((ULONG64) ARM64_MAIR_CACHE_NC   <<  8) | \
     ((ULONG64) ARM64_MAIR_CACHE_WTNA << 16) | \
     ((ULONG64) ARM64_MAIR_CACHE_WC   << 24) | \
     ((ULONG64) ARM64_MAIR_CACHE_WBWA << 32) | \
     ((ULONG64) ARM64_MAIR_CACHE_NC   << 40) | \
     ((ULONG64) ARM64_MAIR_CACHE_WTNA << 48) | \
     ((ULONG64) ARM64_MAIR_CACHE_WC   << 56))

//
// Debug register bits.
//


#define ARM64_DBGBCR_MISMATCH_BIT        0x00400000
#define ARM64_DBGBCR_SECURITY_BITS       0x0000c000
#define   ARM64_DBGBCR_ANY_SECURE        0x00000000
#define   ARM64_DBGBCR_NONSECURE_ONLY    0x00004000
#define   ARM64_DBGBCR_SECURE_ONLY       0x00008000
#define ARM64_DBGBCR_PRIVILEGE_BITS      0x00000006
#define   ARM64_DBGBCR_USER_SYS_SUPER    0x00000000
#define   ARM64_DBGBCR_PRIVILEGED_ONLY   0x00000002
#define   ARM64_DBGBCR_USER_ONLY         0x00000004
#define   ARM64_DBGBCR_ANY_PRIVILEGE     0x00000006
#define ARM64_DBGBCR_ENABLE_BIT          0x00000001

#define ARM64_MDSCR_RXfull               0x40000000
#define ARM64_MDSCR_TXfull               0x20000000
#define ARM64_MDSCR_MDE                  0x00008000
#define ARM64_MDSCR_HDE                  0x00004000
#define ARM64_MDSCR_KDE                  0x00002000
#define ARM64_MDSCR_TDCC                 0x00001000
#define ARM64_MDSCR_SS                   0x00000001


// end_nthal

// begin_irqls
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0                 // Passive release level
#define LOW_LEVEL 0                     // Lowest interrupt level
#define APC_LEVEL 1                     // APC interrupt level
#define DISPATCH_LEVEL 2                // Dispatcher level

#define CLOCK_LEVEL 13                  // Interval clock level
#define IPI_LEVEL 14                    // Interprocessor interrupt level
#define DRS_LEVEL 14                    // Deferred Recovery Service level
#define POWER_LEVEL 14                  // Power failure level
#define PROFILE_LEVEL 15                // timer used for profiling.
#define HIGH_LEVEL 15                   // Highest interrupt level

// end_irqls

// begin_wdm
//
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#define SYNCH_LEVEL (IPI_LEVEL-2)       

#if defined(_ARM64_)

//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//
//  N.B. This implementation assumes that the memory mapped registers
//       have been mapped using the OS concept of uncached memory
//       which is implemented using the ARMv7 strongly ordered memory
//       type.  In addition, the register access is bracketed by a
//       compiler barrier to ensure that the compiler does not
//       re-order the I/O accesses with other accesses and a data
//       synchronization barrier to ensure that any side effects of
//       the access have started (but not necessairly completed).
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT
//  space.  The ARM architecture doesn't have a seperate I/O space.
//  These operations bugcheck so as to identify incorrect code.
//

#ifdef __cplusplus
extern "C" {
#endif

__forceinline
UCHAR
READ_REGISTER_NOFENCE_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register
    )
{

    return ReadUCharNoFence(Register);
}

__forceinline
USHORT
READ_REGISTER_NOFENCE_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register
    )
{

    return ReadUShortNoFence(Register);
}

__forceinline
ULONG
READ_REGISTER_NOFENCE_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register
    )
{

    return ReadULongNoFence(Register);
}

__forceinline
ULONG64
READ_REGISTER_NOFENCE_ULONG64 (
    _In_ _Notliteral_ volatile ULONG64 *Register
    )
{

    return ReadULong64NoFence(Register);
}

__forceinline
VOID
READ_REGISTER_NOFENCE_BUFFER_UCHAR (
    _In_reads_(Count) _Notliteral_ volatile UCHAR *Register,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{

    volatile UCHAR *registerBuffer =  Register;
    PUCHAR readBuffer = Buffer;
    ULONG readCount;

    for (readCount = Count; readCount--; readBuffer++, registerBuffer++) {
        *readBuffer = ReadUCharNoFence(registerBuffer);
    }


    return;
}

__forceinline
VOID
READ_REGISTER_NOFENCE_BUFFER_USHORT (
    _In_reads_(Count) _Notliteral_ volatile USHORT *Register,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{
    volatile USHORT *registerBuffer =  Register;
    PUSHORT readBuffer = Buffer;
    ULONG readCount;

    for (readCount = Count; readCount--; readBuffer++, registerBuffer++) {
        *readBuffer = ReadUShortNoFence(registerBuffer);
    }

    return;
}

__forceinline
VOID
READ_REGISTER_NOFENCE_BUFFER_ULONG (
    _In_reads_(Count) _Notliteral_ volatile ULONG *Register,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{
    volatile ULONG *registerBuffer =  Register;
    PULONG readBuffer = Buffer;
    ULONG readCount;

    for (readCount = Count; readCount--; readBuffer++, registerBuffer++) {
        *readBuffer = ReadULongNoFence(registerBuffer);
    }
    return;
}

__forceinline
VOID
READ_REGISTER_NOFENCE_BUFFER_ULONG64 (
    _In_reads_(Count) _Notliteral_ volatile ULONG64 *Register,
    _Out_writes_all_(Count) PULONG64 Buffer,
    _In_ ULONG Count
    )
{
    volatile ULONG64 *registerBuffer =  Register;
    PULONG64 readBuffer = Buffer;
    ULONG readCount;

    for (readCount = Count; readCount--; readBuffer++, registerBuffer++) {
        *readBuffer = ReadULong64NoFence(registerBuffer);
    }
    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register,
    _In_ UCHAR Value
    )
{

    WriteUCharNoFence(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register,
    _In_ USHORT Value
    )
{

    WriteUShortNoFence(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register,
    _In_ ULONG Value
    )
{

    WriteULongNoFence(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_ULONG64 (
    _In_ _Notliteral_ volatile ULONG64 *Register,
    _In_ ULONG64 Value
    )
{

    WriteULong64NoFence(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_BUFFER_UCHAR (
    _Out_writes_(Count) _Notliteral_ volatile UCHAR *Register,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{

    volatile UCHAR *registerBuffer = Register;
    PUCHAR writeBuffer = Buffer;
    ULONG writeCount;

    for (writeCount = Count; writeCount--; writeBuffer++, registerBuffer++) {
        WriteUCharNoFence(registerBuffer, *writeBuffer);
    }

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_BUFFER_USHORT (
    _Out_writes_(Count) _Notliteral_ volatile USHORT *Register,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{

    volatile USHORT *registerBuffer = Register;
    PUSHORT writeBuffer = Buffer;
    ULONG writeCount;

    for (writeCount = Count; writeCount--; writeBuffer++, registerBuffer++) {
        WriteUShortNoFence(registerBuffer, *writeBuffer);
    }

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_BUFFER_ULONG (
    _Out_writes_(Count) _Notliteral_ volatile ULONG *Register,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{

    volatile ULONG *registerBuffer = Register;
    PULONG writeBuffer = Buffer;
    ULONG writeCount;

    for (writeCount = Count; writeCount--; writeBuffer++, registerBuffer++) {
        WriteULongNoFence(registerBuffer, *writeBuffer);
    }

    return;
}

__forceinline
VOID
WRITE_REGISTER_NOFENCE_BUFFER_ULONG64 (
    _Out_writes_(Count) _Notliteral_ volatile ULONG64 *Register,
    _In_reads_(Count) PULONG64 Buffer,
    _In_ ULONG Count
    )
{

    volatile ULONG64 *registerBuffer = Register;
    PULONG64 writeBuffer = Buffer;
    ULONG writeCount;

    for (writeCount = Count; writeCount--; writeBuffer++, registerBuffer++) {
        WriteULong64NoFence(registerBuffer, *writeBuffer);
    }

    return;
}

__forceinline
VOID
REGISTER_FENCE (
    VOID
    )
{

    _DataSynchronizationBarrier();
}

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register
    )
{
    UCHAR Value;

    _DataSynchronizationBarrier();
    Value = READ_REGISTER_NOFENCE_UCHAR(Register);

    return Value;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register
    )
{
    USHORT Value;

    _DataSynchronizationBarrier();
    Value = READ_REGISTER_NOFENCE_USHORT(Register);

    return Value;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register
    )
{
    ULONG Value;

    _DataSynchronizationBarrier();
    Value = READ_REGISTER_NOFENCE_ULONG(Register);

    return Value;
}

__forceinline
ULONG64
READ_REGISTER_ULONG64 (
    _In_ _Notliteral_ volatile ULONG64 *Register
    )
{
    ULONG64 Value;

    _DataSynchronizationBarrier();
    Value = READ_REGISTER_NOFENCE_ULONG64(Register);

    return Value;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    _In_reads_(Count) _Notliteral_ volatile UCHAR *Register,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{
    _DataSynchronizationBarrier();
    READ_REGISTER_NOFENCE_BUFFER_UCHAR(Register, Buffer, Count);

    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    _In_reads_(Count) _Notliteral_ volatile USHORT *Register,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    READ_REGISTER_NOFENCE_BUFFER_USHORT(Register, Buffer, Count);

    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    _In_reads_(Count) _Notliteral_ volatile ULONG *Register,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    READ_REGISTER_NOFENCE_BUFFER_ULONG(Register, Buffer, Count);

    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG64 (
    _In_reads_(Count) _Notliteral_ volatile ULONG64 *Register,
    _Out_writes_all_(Count) PULONG64 Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    READ_REGISTER_NOFENCE_BUFFER_ULONG64(Register, Buffer, Count);

    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    _In_ _Notliteral_ volatile UCHAR *Register,
    _In_ UCHAR Value
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_UCHAR(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    _In_ _Notliteral_ volatile USHORT *Register,
    _In_ USHORT Value
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_USHORT(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    _In_ _Notliteral_ volatile ULONG *Register,
    _In_ ULONG Value
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_ULONG(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG64 (
    _In_ _Notliteral_ volatile ULONG64 *Register,
    _In_ ULONG64 Value
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_ULONG64(Register, Value);

    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    _Out_writes_(Count) _Notliteral_ volatile UCHAR *Register,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_BUFFER_UCHAR(Register, Buffer, Count);

    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    _Out_writes_(Count) _Notliteral_ volatile USHORT *Register,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_BUFFER_USHORT(Register, Buffer, Count);

    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    _Out_writes_(Count) _Notliteral_ volatile ULONG *Register,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_BUFFER_ULONG(Register, Buffer, Count);

    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG64 (
    _Out_writes_(Count) _Notliteral_ volatile ULONG64 *Register,
    _In_reads_(Count) PULONG64 Buffer,
    _In_ ULONG Count
    )
{

    _DataSynchronizationBarrier();
    WRITE_REGISTER_NOFENCE_BUFFER_ULONG64(Register, Buffer, Count);

    return;
}



// end_wudfpwdm

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    _In_ _Notliteral_ PUCHAR Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    _In_ _Notliteral_ PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    _In_ _Notliteral_ PULONG Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _Out_writes_all_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _Out_writes_all_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _Out_writes_all_(Count) PULONG Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _In_ UCHAR Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _In_ USHORT Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _In_ ULONG Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    _In_ _Notliteral_ PUCHAR Port,
    _In_reads_(Count) PUCHAR Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    _In_ _Notliteral_ PUSHORT Port,
    _In_reads_(Count) PUSHORT Buffer,
    _In_ ULONG Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    _In_ _Notliteral_ PULONG Port,
    _In_reads_(Count) PULONG Buffer,
    _In_ ULONG Count
    );

// begin_wudfpwdm

#ifdef __cplusplus
}
#endif

#endif

// end_ntndis end_wudfpwdm
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


VOID
KeFlushIoBuffers(
    _In_ PMDL  Mdl,
    _In_ BOOLEAN  ReadOperation,
    _In_ BOOLEAN  DmaOperation
    );

VOID
KeFlushIoRectangle (
    _In_ PMDL Mdl,
    _In_ PVOID Start,
    _In_ ULONG Width,
    _In_ ULONG Height,
    _In_ ULONG Stride,
    _In_ BOOLEAN ReadOperation
    );


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


//
// ARM64 hardware structures
//
// The following bit arrangements and semantics for ARMv8 style MMU
// A Page Table Entry on an ARM64 has the following definition.
//

typedef struct _HARDWARE_PTE {
    ULONGLONG Valid : 1;
    ULONGLONG NotLargePage : 1;         // ARM Large page bit is inverted !
    ULONGLONG CacheType : 2;            // Lower 2 bits for cache type encoding
    ULONGLONG OsAvailable2 : 1;         // Memory Attribute Index (can be Mm usage)
    ULONGLONG NonSecure : 1;
    ULONGLONG Owner : 1;                // 0 == kernel, 1 = user
    ULONGLONG NotDirty : 1;             // 0 == modified (written), 1 == clean (ronly)
    ULONGLONG Shareability : 2;
    ULONGLONG Accessed : 1;
    ULONGLONG NonGlobal : 1;
    ULONGLONG PageFrameNumber : 36;
    ULONGLONG reserved1 : 4;
    ULONGLONG ContiguousBit : 1;
    ULONGLONG PrivilegedNoExecute : 1;
    ULONGLONG UserNoExecute : 1;
    ULONGLONG Writable : 1;             // OS managed
    ULONGLONG CopyOnWrite : 1;          // OS managed
    ULONGLONG OsAvailable : 2;          // 2 bits available for Mm usage
    ULONGLONG PxnTable : 1;
    ULONGLONG UxnTable : 1;
    ULONGLONG ApTable : 2;
    ULONGLONG NsTable : 1;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \
     *((PULONG64)(dirbase)) = (((ULONG64)(pfn)) << PAGE_SHIFT)

// begin_windbgkd

#if defined(_ARM64_)

//
// Define special kernel registers
//

typedef struct _KSPECIAL_REGISTERS {

    ULONG64 Elr_El1;
    ULONG32 Spsr_El1;
    ULONG64 Tpidr_El0;
    ULONG64 Tpidrro_El0;
    ULONG64 Tpidr_El1;

    //
    // H/w [break/watch]point support.
    //

    ULONG64 KernelBvr[ARM64_MAX_BREAKPOINTS];
    ULONG KernelBcr[ARM64_MAX_BREAKPOINTS];
    ULONG64 KernelWvr[ARM64_MAX_WATCHPOINTS];
    ULONG KernelWcr[ARM64_MAX_WATCHPOINTS];

} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Define remaining architectural state
//

typedef struct _KARM64_ARCH_STATE
{
    ULONG64 Midr_El1;
    ULONG64 Sctlr_El1;
    ULONG64 Actlr_El1;
    ULONG64 Cpacr_El1;
    ULONG64 Tcr_El1;
    ULONG64 Ttbr0_El1;
    ULONG64 Ttbr1_El1;
    ULONG64 Esr_El1;
    ULONG64 Far_El1;
    ULONG64 Pmcr_El0;
    ULONG64 Pmcntenset_El0;
    ULONG64 Pmccntr_El0;
    ULONG64 Pmxevcntr_El0[MAX_EVENT_COUNTERS];
    ULONG64 Pmxevtyper_El0[MAX_EVENT_COUNTERS];
    ULONG64 Pmovsclr_El0;
    ULONG64 Pmselr_El0;
    ULONG64 Pmuserenr_El0;
    ULONG64 Mair_El1;
    ULONG64 Vbar_El1;
} KARM64_ARCH_STATE, *PKARM64_ARCH_STATE;

//
// Define processor state structure.
//

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    KARM64_ARCH_STATE ArchState;
    CONTEXT ContextFrame;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _ARM64_

// end_windbgkd

//
// Define processor vendors.
//

typedef enum {
    CPU_UNKNOWN,
    CPU_ARM,
    CPU_QUALCOMM,
    CPU_AMD
} CPU_VENDORS;

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1

#define PRCB_BUILD_DEBUG 0x1
#define PRCB_BUILD_UNIPROCESSOR 0x2

#define MAXIMUM_CACHES 6

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    UCHAR LegacyNumber;             // +000/+980
    UCHAR ReservedMustBeZero;       // +001/+981
    BOOLEAN IdleHalt;               // +002/+982
    struct _KTHREAD *CurrentThread; // +008/+988
    struct _KTHREAD *NextThread;    // +010/+990
    struct _KTHREAD *IdleThread;    // +018/+998
    UCHAR NestingLevel;             // +020/+9A0
    BOOLEAN ClockOwner;             // +021/+9A1
    union {                         // +022/+9A2
        UCHAR PendingTickFlags;

        struct {
            UCHAR PendingTick:1;
            UCHAR PendingBackupTick:1;
        };
    };

    UCHAR IdleState;                // +023/+9A3
    ULONG Number;                   // +024/+9A4
    KSPIN_LOCK PrcbLock;
    PSCHAR PriorityState;
    KPROCESSOR_STATE ProcessorState;
    USHORT ProcessorModel;
    USHORT ProcessorRevision;
    ULONG MHz;
    ULONG64 CycleCounterFrequency;
    ULONG64 HalReserved[10];
    USHORT MinorVersion;
    USHORT MajorVersion;
    UCHAR BuildType;
    UCHAR CpuVendor;
    UCHAR CoresPerPhysicalProcessor;
    UCHAR LogicalProcessorsPerCore;
    PVOID AcpiReserved;
    KAFFINITY GroupSetMember;
    UCHAR Group;
    UCHAR GroupIndex;

//
// End of the architecturally defined section of the PRCB.
//

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

C_ASSERT(FIELD_OFFSET(KPRCB, HalReserved) == 0x700);  // Do not move field
C_ASSERT(FIELD_OFFSET(KPRCB, AcpiReserved) == 0x758); // Do not move field


//
// ARM64 IDT Entry Structure Definition
//
// ARM64 does not have a native IDT format and does not vector interrupt
// exceptions.
//

//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Certain fields in the TIB are not used in kernel mode. These include the
// exception list, stack base, stack limit, subsystem TIB, fiber data, and
// the arbitrary user pointer. Therefore, these fields are overlaid with
// other data to get better cache locality.
//
// N.B. The offset to the PRCB in the PCR is fixed for all time.
//

    union {
        NT_TIB NtTib;                   // +000
        struct {
            PVOID TibPad0[2];           // +000
            PVOID Spare1;               // +010
            struct _KPCR *Self;         // +018
            PVOID PcrReserved0;         // +020
            PKSPIN_LOCK_QUEUE LockArray;// +028
            PVOID Used_Self;            // +030
        };
    };

    KIRQL CurrentIrql;                  // +038
    UCHAR SecondLevelCacheAssociativity;// +039
    UCHAR Pad1[2];                      // +03A
    USHORT MajorVersion;                // +03C
    USHORT MinorVersion;                // +03E
    ULONG StallScaleFactor;             // +040

    ULONG SecondLevelCacheSize;         // +044
    union {
        USHORT SoftwareInterruptPending;// +048 -- Software Interrupt Pending Flag
        struct {
            UCHAR ApcInterrupt;         // +048 -- 0x01 if APC int pending
            UCHAR DispatchInterrupt;    // +049 -- 0x01 if dispatch int pending
        };
    };
    USHORT InterruptPad;                // +04A

    ULONG64 PanicStorage[6];            // +050 -- Must be 16-byte aligned
    PVOID KdVersionBlock;               // +080
    PVOID HalReserved[15];              // +088

// end_ntddk

    PVOID Idt[256];                     // +100
    PVOID *IdtExt;                      // +900
    PVOID PcrAlign[15];                 // +908

    KPRCB Prcb;                         // +980

//
// End of the architecturally defined section of the PCR.
//

} KPCR, *PKPCR;


//
// Definitions for MIDR Register e.g. ID and cache information
//

typedef union _ARM64_IDCODE {
    ULONG64 Ulong;
    struct {
        ULONG64 MinorRevision :  4;
        ULONG64 Model         : 12;
        ULONG64 Architecture  :  4;
        ULONG64 Revision      :  4;
        ULONG64 Implementer   :  8;
        ULONG64 Reserved      : 32;
    };
} ARM64_IDCODE, *PARM64_IDCODE;

C_ASSERT(sizeof(ARM64_IDCODE) == 8);

// end_wdm
// begin_nthal begin_ntoshvp
/*
#define CP15_CR0_HARVARD_CACHE (1 << 24)
*/
// Define ARMv8 cache information structure

#define ARM64_L1_ICACHE_UNKNOWN 0
#define ARM64_L1_ICACHE_VIVT    1
#define ARM64_L1_ICACHE_VIPT    2
#define ARM64_L1_ICACHE_PIPT    3

typedef union _ARM64_CACHE_TYPE {
    ULONG64 Ulong;
    struct {
        ULONG64 IMinLine               : 4;
        ULONG64 Reserved               : 10;
        ULONG64 IPolicy                : 2;
        ULONG64 DMinLine               : 4;
        ULONG64 Reserved2              : 12;
    };
} ARM64_CACHE_TYPE, *PARM64_CACHE_TYPE;

C_ASSERT(sizeof(ARM64_CACHE_TYPE) == 8);

#define ARM64_CACHE_NONE        0
#define ARM64_CACHE_INSTRUCTION 1
#define ARM64_CACHE_DATA        2
#define ARM64_CACHE_HARVARD     3
#define ARM64_CACHE_UNIFIED     4

typedef union _ARM64_CACHE_LEVEL_ID {
    ULONG64 Ulong;
    struct {
        ULONG64 Level1 : 3;
        ULONG64 Level2 : 3;
        ULONG64 Level3 : 3;
        ULONG64 Level4 : 3;
        ULONG64 Level5 : 3;
        ULONG64 Level6 : 3;
        ULONG64 Level7 : 3;
        ULONG64 LoUIS  : 3;
        ULONG64 LoC    : 3;
        ULONG64 LoU    : 3;
    };
} ARM64_CACHE_LEVEL_INFO;

C_ASSERT(sizeof(ARM64_CACHE_LEVEL_INFO) == 8);

#define ARM64_CACHE_SELECT_DATA_OR_UNIFIED 0
#define ARM64_CACHE_SELECT_INSTRUCTION     1

typedef union _ARM64_CACHE_INFO_SELECTOR {
    ULONG64 Ulong;
    struct {
        ULONG64 Select : 1;
        ULONG64 Level  : 3;
    };
} ARM64_CACHE_INFO_SELECTOR;

C_ASSERT(sizeof(ARM64_CACHE_INFO_SELECTOR) == 8);

typedef union _ARM64_CACHE_INFO {
    ULONG64 Ulong;
    struct {
        ULONG64 LineSize           : 3;
        ULONG64 Associativity      : 10;
        ULONG64 NumberOfSets       : 15;
        ULONG64 WriteThrough       : 1;
        ULONG64 WriteBack          : 1;
        ULONG64 ReadAllocate       : 1;
        ULONG64 WriteAllocate      : 1;
    };
} ARM64_CACHE_INFO;

C_ASSERT(sizeof(ARM64_CACHE_INFO) == 8);

// end_nthal end_ntoshvp
//
// A BRK #n instruction is used for debugging and failure
// reporting. We explicitly use non-zero base values.
//

#define ARM64_BREAK_DEBUG_BASE          0xf000
#define ARM64_BREAKPOINT                (ARM64_BREAK_DEBUG_BASE + 0)
#define ARM64_ASSERT                    (ARM64_BREAK_DEBUG_BASE + 1)
#define ARM64_DEBUG_SERVICE             (ARM64_BREAK_DEBUG_BASE + 2)
#define ARM64_FASTFAIL                  (ARM64_BREAK_DEBUG_BASE + 3)
#define ARM64_DIVIDE_BY_0               (ARM64_BREAK_DEBUG_BASE + 4)

//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all nonvolatile registers. The volatile registers will already
//  have been saved in a trap frame.
//
// N.B. The exception frame is preceded in the trap handling code by
//      an exception record capable of storing information for four
//      parameter values.
//

typedef struct _KEXCEPTION_FRAME {

//
// Saved nonvolatile registers.
//

    ULONG64 X19;
    ULONG64 X20;
    ULONG64 X21;
    ULONG64 X22;
    ULONG64 X23;
    ULONG64 X24;
    ULONG64 X25;
    ULONG64 X26;
    ULONG64 X27;
    ULONG64 X28;
    ULONG64 Fp;

    ULONG64 Return;

} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

// end_ntddk
// begin_nthal

#define KEXCEPTION_FRAME_LENGTH sizeof(KEXCEPTION_FRAME)

C_ASSERT((sizeof(KEXCEPTION_FRAME) & STACK_ROUND) == 0);
C_ASSERT((FIELD_OFFSET(KEXCEPTION_FRAME, Return) + sizeof(ULONG64)) == sizeof(KEXCEPTION_FRAME));

#define EXCEPTION_RECORD_LENGTH ((sizeof(EXCEPTION_RECORD) + STACK_ROUND - 1) & ~STACK_ROUND)

//
// Machine Frame
//
// This frame is established by code that trampolines to user mode (e.g. user
// APC, user callback, dispatch user exception, etc.). The purpose of this
// frame is to allow unwinding through these callbacks if an exception occurs.
//

typedef struct _MACHINE_FRAME {
    ULONG64 Sp;
    ULONG64 Pc;
} MACHINE_FRAME, *PMACHINE_FRAME;

#define MACHINE_FRAME_LENGTH sizeof(MACHINE_FRAME)

C_ASSERT((sizeof(MACHINE_FRAME) & STACK_ROUND) == 0);

//
// Switch Frame
//
// This frame is established by the code that switches context from one
// thread to the next and is used by the thread initialization code to
// construct a stack that will start the execution of a thread in the
// thread start up code.
//

typedef struct _KSWITCH_FRAME {
    KIRQL ApcBypass;
    UCHAR Fill[7];
    ULONG64 Tpidr;
    ULONG64 Fp;
    ULONG64 Return;
} KSWITCH_FRAME, *PKSWITCH_FRAME;

#define KSWITCH_FRAME_LENGTH sizeof(KSWITCH_FRAME)

C_ASSERT((sizeof(KSWITCH_FRAME) & STACK_ROUND) == 0);

//
// Start system thread frame.
//
// This frame is established by the ARM64 specific thread initialization
// code. It is used to store the initial context for starting a system
// thread.
//

typedef struct _KSTART_FRAME {
    ULONG64 X0;
    ULONG64 X1;
    ULONG64 X2;
    ULONG64 Return;
} KSTART_FRAME, *PKSTART_FRAME;

#define KSTART_FRAME_LENGTH sizeof(KSTART_FRAME)

C_ASSERT((sizeof(KSTART_FRAME) & STACK_ROUND) == 0);

// end_nthal
// begin_ntddk
//
// VFP State -- specially organized collection of VFP state that
// is used in context switching. The volatile section is also used
// in trap frame handling and lazy VFP enabling.
//

typedef struct _KARM64_VFP_STATE
{
    struct _KARM64_VFP_STATE *Link;         // link to next state entry
    ULONG Fpcr;                             // FPCR register
    ULONG Fpsr;                             // FPSR register
    NEON128 V[32];                          // All V registers (0-31)
} KARM64_VFP_STATE, *PKARM64_VFP_STATE;

//
// Trap frame
//
// This frame is established when handling a trap. It provides a place to
// save all volatile registers. The nonvolatile registers are saved in an
// exception frame or through the normal C calling conventions for saved
// registers.
//
// Code to generate the trap frame is found in ntos\ke\arm\trap.asm.
//

#define KTRAP_FRAME_ARGUMENTS (10 * 8)       // up to 10 in-memory syscall args

typedef struct _KTRAP_FRAME {

//
// Exception active indicator.
//
//    0 - interrupt frame.
//    1 - exception frame.
//    2 - service frame.
//

    /* +0x000 */ UCHAR ExceptionActive;              // always valid
    /* +0x001 */ UCHAR ContextFromKFramesUnwound;    // set if KeContextFromKFrames created this frame
    /* +0x002 */ UCHAR DebugRegistersValid;          // always valid
    /* +0x003 */ union {
                     KPROCESSOR_MODE PreviousMode;   // system services only
                     KIRQL PreviousIrql;             // interrupts only
                 };

//
// Page fault information (page faults only)
// Previous trap frame address (system services only)
//
// Organized this way to allow first couple words to be used
// for scratch space in the general case
//

    /* +0x004 */ ULONG FaultStatus;                      // page faults only
    /* +0x008 */ union {
                     ULONG64 FaultAddress;             // page faults only
                     ULONG64 TrapFrame;                // system services only
                 };

//
// The ARM architecture does not have an architectural trap frame.  On
// an exception or interrupt, the processor switches to an
// exception-specific processor mode in which at least the LR and SP
// registers are banked.  Software is responsible for preserving
// registers which reflect the processor state in which the
// exception occurred rather than any intermediate processor modes.
//

//
// Volatile floating point state is dynamically allocated; this
// pointer may be NULL if the FPU was not enabled at the time the
// trap was taken.
//

    /* +0x010 */ PKARM64_VFP_STATE VfpState;

//
// Debug registers
//

    /* +0x018 */ ULONG Bcr[ARM64_MAX_BREAKPOINTS];
    /* +0x038 */ ULONG64 Bvr[ARM64_MAX_BREAKPOINTS];
    /* +0x078 */ ULONG Wcr[ARM64_MAX_WATCHPOINTS];
    /* +0x080 */ ULONG64 Wvr[ARM64_MAX_WATCHPOINTS];

//
// Volatile registers X0-X17, and the FP, SP, LR
//

    /* +0x090 */ ULONG Spsr;
    /* +0x094 */ ULONG Esr;
    /* +0x098 */ ULONG64 Sp;
    /* +0x0A0 */ union {
        ULONG64 X[19];
        struct {
            ULONG64 X0;
            ULONG64 X1;
            ULONG64 X2;
            ULONG64 X3;
            ULONG64 X4;
            ULONG64 X5;
            ULONG64 X6;
            ULONG64 X7;
            ULONG64 X8;
            ULONG64 X9;
            ULONG64 X10;
            ULONG64 X11;
            ULONG64 X12;
            ULONG64 X13;
            ULONG64 X14;
            ULONG64 X15;
            ULONG64 X16;
            ULONG64 X17;
            ULONG64 X18;
        };
    };
    /* +0x138 */ ULONG64 Lr;
    /* +0x140 */ ULONG64 Fp;
    /* +0x148 */ ULONG64 Pc;
    /* +0x150 */

} KTRAP_FRAME, *PKTRAP_FRAME;

// end_ntddk

//
// Define TrapFrame->ExceptionActive constants.
//

#define KEXCEPTION_ACTIVE_INTERRUPT_FRAME 0
#define KEXCEPTION_ACTIVE_EXCEPTION_FRAME 1
#define KEXCEPTION_ACTIVE_SERVICE_FRAME   2

// begin_nthal

#define KTRAP_FRAME_LENGTH sizeof(KTRAP_FRAME)

C_ASSERT((sizeof(KTRAP_FRAME) & STACK_ROUND) == 0);

//
// The "red zone" on ARM is the amount of stack guaranteed not be
// stepped on when generating exceptions. It must be honored in both
// kernel and user mode. There is code in the system that assumes
// data stored at [sp-8] and [sp-16] will not get trampled.
//

#define ARM64_RED_ZONE_BYTES      16

//
// Profile, update run time, and update system time interrupt routines.
//

_IRQL_requires_(IPI_LEVEL);
NTKERNELAPI
BOOLEAN
KiIpiServiceRoutine (
    _In_ PVOID Interrupt,
    _In_ PVOID Context
    );

NTKERNELAPI
NTSTATUS
KiConnectHalInterrupt (
    _Inout_ PVOID Interrupt
    );

NTKERNELAPI
VOID
KiReplayInterrupt (
    _In_ ULONG Vector,
    _In_ KIRQL Irql,
    _In_ KIRQL PreviousIrql,
    _In_ ULONG OpaqueToken
    );

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    _In_ PKTRAP_FRAME TrapFrame,
    _In_ KPROFILE_SOURCE ProfileSource
    );

// end_nthal

//
// The frame saved by the call out to user mode code is defined here
// to allow the kernel debugger to trace the entire kernel stack when
// user mode callouts are active.
//
// N.B. The kernel callout frame is the same as an exception frame.
//

typedef struct _UCALLOUT_FRAME {
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    ULONG64 Reserved;
    ULONG64 OriginalLr;
    MACHINE_FRAME MachineFrame;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;

C_ASSERT((sizeof(UCALLOUT_FRAME) & STACK_ROUND) == 0);

// begin_wdm
//
// Dummy nonvolatile floating state structure.
//

typedef struct _KFLOATING_SAVE {
    ULONG Dummy;
} KFLOATING_SAVE, *PKFLOATING_SAVE;


//
// ARM64 Specific portions of Mm component.
//

#define PXE_BASE          0xFFFFF6FB7DBED000UI64
#define PXE_SELFMAP       0xFFFFF6FB7DBEDF68UI64
#define PPE_BASE          0xFFFFF6FB7DA00000UI64
#define PDE_BASE          0xFFFFF6FB40000000UI64
#define PTE_BASE          0xFFFFF68000000000UI64

#define PXE_TOP           0xFFFFF6FB7DBEDFFFUI64
#define PPE_TOP           0xFFFFF6FB7DBFFFFFUI64
#define PDE_TOP           0xFFFFF6FB7FFFFFFFUI64
#define PTE_TOP           0xFFFFF6FFFFFFFFFFUI64

#define PDE_KTBASE_ARM64  PPE_BASE

#define PTI_SHIFT 12
#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PXI_SHIFT 39

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512

#define PTI_MASK_ARM64 (PTE_PER_PAGE - 1)
#define PDI_MASK_ARM64 (PDE_PER_PAGE - 1)
#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

// begin_ntddk

//
// Define the highest user address and user probe address.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG64 MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// Allow non-kernel components to capture the user probe address and use a
// local copy for efficiency.
//

#if defined(_LOCAL_COPY_USER_PROBE_ADDRESS_)

#define MM_USER_PROBE_ADDRESS _LOCAL_COPY_USER_PROBE_ADDRESS_

#if defined(__CONVERGED_WIN32K_DRIVER__)
extern DLLBASEEXPORT ULONG_PTR _LOCAL_COPY_USER_PROBE_ADDRESS_;
#else
extern ULONG_PTR _LOCAL_COPY_USER_PROBE_ADDRESS_;
#endif

#else

#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)(LONG_PTR)0x10000

// end_ntddk
// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_wdm

//
// State sanitization support
//
// If kernel mode, then caller can specify:
//      Condition codes (N,Z,C,V)
//      Single step
//      IRQ Disabled
// For kernel mode, the following configuration is enforced:
//      SVC mode
//

#define CPSR_KERNEL_SANITIZE (NZCV_N | NZCV_Z | NZCV_C | NZCV_V | \
                              CPSR_SS | \
                              DAIF_INT)

//
// If user mode, then caller can specify:
//      Condition codes (N,Z,C,V)
//      Single step
// For user mode, the following configuration is enforced:
//      USER mode
//      IRQ Enabled
//

#define CPSR_USER_SANITIZE   (NZCV_N | NZCV_Z | NZCV_C | NZCV_V | \
                              CPSR_SS)

#define CPSR_USER_SANITIZE32 (NZCV_N | NZCV_Z | NZCV_C | NZCV_V | \
                              CPSR_SS | CPSRM_AA32 | CPSRM_T | CPSR_IT_MASK)

//
// Define inlined function to sanitize CPSR, debug address and control registers.
//

__forceinline
ULONG
SANITIZE_CPSR(ULONG Cpsr, MODE mode)
{
    return ((mode == KernelMode) ?
            ((Cpsr & CPSR_KERNEL_SANITIZE) | CPSRM_EL1t | DAIF_FIQ) :
            ((Cpsr & CPSRM_AA32) ?
             ((Cpsr & CPSR_USER_SANITIZE32) | CPSRM_EL0t | DAIF_FIQ) :
             ((Cpsr & CPSR_USER_SANITIZE) | CPSRM_EL0t | DAIF_FIQ)));
}

__forceinline
ULONG64
SANITIZE_DEBUG_ADDR(ULONG64 DebugReg, MODE mode)
{
    return ((mode == KernelMode) ?
            (DebugReg) :
            (((PVOID)(DebugReg) <= MM_HIGHEST_USER_ADDRESS) ?
             (DebugReg) :
             (0)));
}

__forceinline
ULONG
SANITIZE_DEBUG_CTRL(ULONG DebugReg, MODE mode)
{
    return ((mode == KernelMode) ?
            (DebugReg) :
            ((DebugReg & ~(ARM64_DBGBCR_SECURITY_BITS | ARM64_DBGBCR_PRIVILEGE_BITS)) |
                          (ARM64_DBGBCR_ANY_SECURE | ARM64_DBGBCR_USER_ONLY)));
}

//
// CPSR value given to first thread on new processors (note interrupts
// and external aborts are disabled).
//

#define INITIAL_KERNEL_CPSR (CPSRM_EL1t | DAIF_FIQ | DAIF_INT | DAIF_ABORT)

//
// Value PSR is restored to on return from system call. Done to
// discourage dependence on what happens inside a system call.  In
// fact the banked status registers ensure that status bits don't
// filter back into user mode.
//

#define SYSCALL_PSR         (CPSRM_EL0t)

//
// Define sanitize debug register macros.
//


//
// Intrinsic functions
//

#if defined(_M_ARM64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)

//
// The following routines are provided for backward compatibility with old
// code. They are no longer the preferred way to accomplish these functions.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

#define ExInterlockedDecrementLong(Addend, Lock)                            \
    _ExInterlockedDecrementLong(Addend)

_Post_satisfies_(return >= 0 && return <= 2)
__forceinline
LONG
_ExInterlockedDecrementLong (
    _Inout_ _Interlocked_operand_ PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedDecrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedIncrementLong(Addend, Lock)                            \
    _ExInterlockedIncrementLong(Addend)

_Post_satisfies_(return >= 0 && return <= 2)
__forceinline
LONG
_ExInterlockedIncrementLong (
    _Inout_ _Interlocked_operand_ PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedIncrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedExchangeUlong(Target, Value, Lock)                     \
    _ExInterlockedExchangeUlong(Target, Value)

__forceinline
ULONG
_ExInterlockedExchangeUlong (
    _Inout_ _Interlocked_operand_ PULONG Target,
    _In_ ULONG Value
    )

{

    return (ULONG)InterlockedExchange((PLONG)Target, (LONG)Value);
}

#endif // defined(_M_ARM64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)


#define ARM64_PCR_RESERVED_MASK 0xFFF
#define KIPCR() ((ULONG_PTR)(_ReadStatusReg(ARM64_TPIDR_EL1)) & ~ARM64_PCR_RESERVED_MASK)

// end_wdm

#if !defined(MIDL_PASS) && defined(_M_ARM64)

//
// ARM64 function prototype definitions
//

// end_nthal

//
// Get address of current processor block.
//

CFORCEINLINE
PKPCR
KeGetPcr (
    VOID
    )

{
    return (PKPCR)__getReg(18);
}

// end_ntddk begin_nthal
//
// Get address of current processor block.
//

CFORCEINLINE
PKPRCB
KeGetCurrentPrcb (
    VOID
    )
{
    PKPRCB Prcb;

    Prcb = (PKPRCB)((ULONG_PTR)__getReg(18) + 0x980);
    return Prcb;
}

// end_nthal
// begin_ntddk

#if (NTDDI_VERSION < NTDDI_WIN7) || !defined(NT_PROCESSOR_GROUPS)

//
// Get the current processor number
//

__forceinline
ULONG
KeGetCurrentProcessorNumber (
    VOID
    )

{

    return (ULONG)__readx18byte(0x980);
}

#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN7)

CFORCEINLINE
ULONG
KeGetCurrentProcessorIndex (
    VOID
    )

{

    return __readx18dword(0x9a4);
}

#endif

// end_wdm
// begin_nthal

NTKERNELAPI
PKPRCB
KeQueryPrcbAddress (
    _In_ ULONG Number
    );


#endif // !defined(MIDL_PASS) && defined(_M_ARM64)


#if !defined(_CROSS_PLATFORM_)

CFORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )

/*++

Routine Description:

    This function orders memory accesses as seen by other processors.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _ReadWriteBarrier();
    MemoryBarrier();
    return;
}

//++
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function instructs the compiler not to reorder loads and stores
//    across the function invocation.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

//
// Define function to read the value of the time stamp counter.
//
// N.B. On some platforms (e.g., any non-Intel platform like ARM)
// the "timestamp counter" may be backed by QueryPerformanceCounter
// or the like, and may not be as low-latency as one might expect.
//

ULONG64
ReadTimeStampCounter (
    VOID
    );

#else

#define KeMemoryBarrier()
#define KeMemoryBarrierWithoutFence()

#endif



_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_When_(return>=0, _Kernel_float_saved_)
_At_(*FloatSave, _When_(return>=0, _Kernel_acquires_resource_(FloatState)))
__forceinline
NTSTATUS
KeSaveFloatingPointState (
    _Out_ PKFLOATING_SAVE FloatSave
    )

#pragma warning (suppress:28104 28161 6001 6101) // PFD can't recognize the implementation
{

    UNREFERENCED_PARAMETER(FloatSave);

    return STATUS_SUCCESS;
}

_Success_(1)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Kernel_float_restored_
_At_(*FloatSave, _Kernel_requires_resource_held_(FloatState) _Kernel_releases_resource_(FloatState))
__forceinline
NTSTATUS
KeRestoreFloatingPointState (
    _In_ PKFLOATING_SAVE FloatSave
    )

#pragma warning (suppress:28103 28162) // PFD can't recognize the implementation
{

    UNREFERENCED_PARAMETER(FloatSave);

    return STATUS_SUCCESS;
}


#endif // defined(_ARM64_)


//
// Platform specific kernel fucntions to raise and lower IRQL.
//


#if defined(_ARM64_) && !defined(MIDL_PASS)
// end_ntddk

_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_saves_
NTHALAPI
KIRQL
KeGetCurrentIrql (
    VOID
    );

_IRQL_requires_max_(HIGH_LEVEL)
NTHALAPI
VOID
KfLowerIrql (
    _In_ _IRQL_restores_ _Notliteral_ KIRQL NewIrql
    );

#define KeLowerIrql(a) KfLowerIrql(a)
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

NTHALAPI
KIRQL
_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_raises_(NewIrql)
_IRQL_saves_
KfRaiseIrql (
    _In_ KIRQL NewIrql
    );


_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
__forceinline
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to DPC_LEVEL and returns the
    previous IRQL.

Arguments:

    None.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(DISPATCH_LEVEL);
}

_IRQL_saves_
_IRQL_raises_(12)
__forceinline
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to SYNCH_LEVEL and returns the
    previous IRQL.

Arguments:

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    return KfRaiseIrql(12);
}

// begin_wdm
#endif // defined(_ARM64_) && !defined(MIDL_PASS)


#if defined(_M_ARM64)

VOID
KeCompactServiceTable (
    _Inout_ PVOID Table,
    _In_ PVOID Arguments,
    _In_ ULONG Limit,
    _In_ BOOLEAN Win32k
    );

VOID
KiLockServiceTable (
    _Inout_ PVOID Table,
    _In_ PVOID Arguments,
    _In_ ULONG limit,
    _In_ BOOLEAN Win32k
    );

//
// Lazy VFP helpers
//

__forceinline
PKARM64_VFP_STATE
KiGetVfpStatePointer(
    _In_ PKTRAP_FRAME TrapFrame
    )
{

    //
    // The only time the VFPState field should be NULL is through a System Service
    // exception. In this situation, the memory is allocated on the stack, but the
    // data is not populated for performance reasons. The code path below, however,
    // requires a valid VFP state, so the memory is reclaimed and zeroed into a
    // safe state.
    //

    if (TrapFrame->VfpState == NULL) {
        NT_ASSERT(TrapFrame->ExceptionActive == KEXCEPTION_ACTIVE_SERVICE_FRAME);

        TrapFrame->VfpState = (PKARM64_VFP_STATE)(TrapFrame + 1);
        RtlZeroMemory(TrapFrame->VfpState, sizeof(*TrapFrame->VfpState));
    }
    return TrapFrame->VfpState;
}


//
// Trap frame log entry
//

typedef struct _TRAPFRAME_LOG_ENTRY {
    ULONG_PTR Thread;
    UCHAR CpuNumber;
    UCHAR TrapType;
    USHORT Padding;
    ULONG Cpsr;
    ULONG_PTR X0;
    ULONG_PTR X1;
    ULONG_PTR X2;
    ULONG_PTR X3;
    ULONG_PTR X4;
    ULONG_PTR X5;
    ULONG_PTR X6;
    ULONG_PTR X7;
    ULONG_PTR Fp;
    ULONG_PTR Lr;
    ULONG_PTR Sp;
    ULONG_PTR Pc;
    ULONG_PTR Reserved1;
    ULONG_PTR Reserved2;
} TRAPFRAME_LOG_ENTRY, *PTRAPFRAME_LOG_ENTRY;

#define TRAP_TYPE_INTERRUPT 1
#define TRAP_TYPE_SYSCALL 2
#define TRAP_TYPE_UNDEFINED 3
#define TRAP_TYPE_DATA_ABORT 4
#define TRAP_TYPE_PREFETCH_ABORT 5
#define TRAP_TYPE_RESET 6
#define TRAP_TYPE_FIQ 7


//
// Image header machine architecture
//

#define IMAGE_FILE_MACHINE_NATIVE   0xaa64


//
// Private implementations of 8 bit interlocked operations until
// compiler is updated
//

char
InterlockedAnd8 (
    _Inout_ char volatile *Destination,
    _In_ char Value
    );

char
InterlockedOr8 (
    _Inout_ char volatile *Destination,
    _In_ char Value
    );

#endif

// begin_ntsecapi
#ifndef _NTLSA_IFS_
// begin_ntifs

//
// All of this stuff (between the Ifndef _NTLSA_AUDIT_ and its endif) were not
// present in NTIFS prior to Windows Server 2003 SP1. All of the definitions however
// exist down to windows 2000 (except for the few exceptions noted in the code).
//

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types related to Auditing                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  a unicode string containing "-".
                                    //
                                    //Note:  This is typically used to
                                    //       indicate that a parameter value
                                    //       was not available.
                                    //

    SeAdtParmTypeString,            //Produces 1 parameter.
                                    //Received Value:
                                    //
                                    //  Unicode String (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  No transformation.  The string
                                    //  entered into the event record as
                                    //  received.
                                    //
                                    // The Address value of the audit info
                                    // should be a pointer to a UNICODE_STRING
                                    // structure.



    SeAdtParmTypeFileSpec,          //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  Unicode string containing a file or
                                    //  directory name.
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string with the prefix of the
                                    //  file's path replaced by a drive letter
                                    //  if possible.
                                    //




    SeAdtParmTypeUlong,             //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value.


    SeAdtParmTypeSid,               //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  SID (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  String representation of SID
                                    //




    SeAdtParmTypeLogonId,           //Produces 4 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string
                                    //  param 2: Username string
                                    //  param 3: domain name string
                                    //  param 4: Logon ID (Luid) string


    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  param 1: "-"
                                    //  param 2: "-"
                                    //  param 3: "-"
                                    //  param 4: "-"
                                    //
                                    //Note:
                                    //
                                    //  This type is used when a logon ID
                                    //  is needed, but one is not available
                                    //  to pass.  For example, if an
                                    //  impersonation logon ID is expected
                                    //  but the subject is not impersonating
                                    //  anyone.
                                    //

    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //  ACCESS_MASK followed by
                                    //  a Unicode string.  The unicode
                                    //  string contains the name of the
                                    //  type of object the access mask
                                    //  applies to.  The event's source
                                    //  further qualifies the object type.
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string built to
                                    //  take advantage of the specified
                                    //  source's parameter message file.
                                    //
                                    //Note:
                                    //
                                    //  An access mask containing three
                                    //  access types for a Widget object
                                    //  type (defined by the Foozle source)
                                    //  might end up looking like:
                                    //
                                    //      %%1062\n\t\t%1066\n\t\t%%601
                                    //
                                    //  The %%numbers are signals to the
                                    //  event viewer to perform parameter
                                    //  substitution before display.
                                    //



    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string similar to
                                    //  that for access types.  Each priv
                                    //  will be formatted to be displayed
                                    //  on its own line.  E.g.,
                                    //
                                    //      %%642\n\t\t%%651\n\t\t%%655
                                    //

    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
                                    //Received value:
                                    //
                                    // Produces a list a stringized GUIDS along
                                    // with information similar to that for
                                    // an access mask.

    SeAdtParmTypeHexUlong,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

// In W2k this value did not exist, it was ParmTypeLUID

    SeAdtParmTypePtr,               //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  pointer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

//
// Everything below exists only in Windows XP and greater
//

    SeAdtParmTypeTime,              //Produces 2 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time.

                                    //
    SeAdtParmTypeGuid,              //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  GUID pointer
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of GUID
                                    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                                    //

//
// Everything below exists only in Windows Server 2003 and Greater
//

    SeAdtParmTypeLuid,              //
                                    //Produces 1 parameter
                                    //Received value:
                                    //
                                    // LUID
                                    //
                                    //Results in:
                                    //
                                    // Hex LUID
                                    //

    SeAdtParmTypeHexInt64,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  64 bit integer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

    SeAdtParmTypeStringList,        //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_STRING_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the strings in the list

    SeAdtParmTypeSidList,           //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_SID_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the SIDs in the list

    SeAdtParmTypeDuration,          //Produces 1 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // a duration.

    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
                                    //Received value:
                                    //
                                    // old and new UserAccountControl values
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representations of
                                    // the flags in UserAccountControl.
                                    // 1 - old value in hex
                                    // 2 - new value in hex
                                    // 3 - difference as strings

    SeAdtParmTypeNoUac,             //Produces 3 parameters
                                    //Received value:
                                    //
                                    // none
                                    //
                                    //Results in:
                                    //
                                    // Three dashes ('-') as unicode strings.

    SeAdtParmTypeMessage,           //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  ULONG (MessageNo from msobjs.mc)
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // %%MessageNo which the event viewer
                                    // will replace with the message string
                                    // from msobjs.mc

    SeAdtParmTypeDateTime,          //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time (in _one_ string).

    SeAdtParmTypeSockAddr,          // Produces 2 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IP address string
                                    // param 2: Port number string
                                    //

//
// Everything below this exists only in Windows Server 2008 and greater
//

    SeAdtParmTypeSD,                // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SECURITY_DESCRIPTOR
                                    // structure. This HAS to appear in pairs.
                                    // The first parameter will represent the
                                    // old SD and the second parameter will
                                    // represent the New SD
                                    //
                                    // Results in:
                                    //
                                    // SDDL string representation of SD
                                    //

    SeAdtParmTypeLogonHours,        // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to LOGON_HOURS
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of allowed logon hours
                                    //

    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Username string
                                    //  param 2: domain name string
                                    //  param 3: Logon ID (Luid) string

    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
                                    // Received Value:
                                    // Ulong
                                    //
                                    //Results in:
                                    // Not converted to string
                                    //

    SeAdtParmTypeSockAddrNoPort,    // Produces 1 parameter
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IPv4/IPv6 address string
                                    //
//
// Everything below this exists only in Windows Server 2008 and greater
//

    SeAdtParmTypeAccessReason,      // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SE_ADT_ACCESS_REASON structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of the access reason.
                                    //
//
// Everything below this exists only in Windows Server 2012 and greater
//

    SeAdtParmTypeStagingReason,     // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SE_ADT_ACCESS_REASON structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of Staging policy's
                                    // access reason.
                                    //

    SeAdtParmTypeResourceAttribute, // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SECURITY_DESCRIPTOR
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // SDDL string representation of the
                                    // Resource Attribute ACEs in the SD
                                    //

    SeAdtParmTypeClaims,            // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to the structure -
                                    // CLAIM_SECURITY_ATTRIBUTES_INFORMATION
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // Claims information as attributes, value
                                    // pairs
                                    //

    SeAdtParmTypeLogonIdAsSid,      // Produces 4 parameters.
                                    // Received Value:
                                    //
                                    //  SID  (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string (based on SID and not derived from the LUID)
                                    //  param 2: -
                                    //  param 3: -
                                    //  param 4: -

    SeAdtParmTypeMultiSzString,     //Produces 1 parameter
                                    //Received value:
                                    //
                                    // PZZWSTR string
                                    //
                                    //Results in:
                                    //
                                    // Unicode string with each null replaced with /r/n

    SeAdtParmTypeLogonIdEx,         //Produces 4 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string
                                    //  param 2: Username string
                                    //  param 3: domain name string
                                    //  param 4: Logon ID (Luid) string

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;

} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;


typedef struct _SE_ADT_ACCESS_REASON{
    ACCESS_MASK AccessMask;
    ULONG  AccessReasons[32];
    ULONG  ObjectTypeIndex;
    ULONG AccessGranted;
    PSECURITY_DESCRIPTOR SecurityDescriptor;    // multple SDs may be stored here in self-relative way.
} SE_ADT_ACCESS_REASON, *PSE_ADT_ACCESS_REASON;

typedef struct _SE_ADT_CLAIMS {

    ULONG Length;
    PCLAIMS_BLOB Claims; // one claim blob will be stored here in self-relative way

} SE_ADT_CLAIMS, *PSE_ADT_CLAIMS;

//
// Structure that will be passed between the Reference Monitor and LSA
// to transmit auditing information.
//

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;


#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010


//
// This macro only existed in Windows Server 2008 and after
//

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // _NTLSA_AUDIT_

// end_ntifs
#endif // _NTLSA_IFS_
// end_ntsecapi
typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT;


typedef
_IRQL_requires_same_
_Function_class_(KENUM_ROUTINE)
VOID
KENUM_ROUTINE (
    _In_reads_(_Inexpressible_(Length)) PVOID Data,
    _In_ ULONG Length,
    _In_ PVOID Context
    );

typedef KENUM_ROUTINE *PKENUM_ROUTINE;

NTKERNELAPI
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID
KeEnumerateQueueApc (
    _Inout_ PKTHREAD Thread,
    _In_ PKENUM_ROUTINE CallbackRoutine,
    _In_ PVOID Context,
    _In_opt_ KPROCESSOR_MODE *ApcMode
    );

NTKERNELAPI
_IRQL_requires_same_
_When_(Environment!=OriginalApcEnvironment, __drv_reportError("Caution: "
    "Using an APC environment other than the original environment can lead to "
    "a system bugcheck if the target thread is attached to a process with APCs "
    "disabled. APC environments should be used with care."))
VOID
KeInitializeApc (
    _Out_ PRKAPC Apc,
    _In_ PRKTHREAD Thread,
    _In_ KAPC_ENVIRONMENT Environment,
    _In_ PKKERNEL_ROUTINE KernelRoutine,
    _In_opt_ PKRUNDOWN_ROUTINE RundownRoutine,
    _In_opt_ PKNORMAL_ROUTINE NormalRoutine,
    _In_opt_ KPROCESSOR_MODE ProcessorMode,
    _In_opt_ PVOID NormalContext
    );

NTKERNELAPI
_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
BOOLEAN
KeInsertQueueApc (
    _Inout_ PRKAPC Apc,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2,
    _In_ KPRIORITY Increment
    );

NTKERNELAPI
_Must_inspect_result_
_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL + 1)
_IRQL_requires_same_
BOOLEAN
KeTryToInsertQueueApc (
    _Inout_ PRKAPC Apc,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2
    );

ULONG
KeIsApcRunningThread (
    _In_ PKTHREAD Thread
    );

NTKERNELAPI
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID
KeEnumerateProcessorDpcs (
    _In_ ULONG ProcessorNumber,
    _In_ PKENUM_ROUTINE CallbackRoutine,
    _In_ PVOID Context,
    _In_opt_ PULONG DpcType
    );

NTKERNELAPI
_IRQL_requires_same_
LOGICAL
KeIsExecutingDpc (
    VOID
    );

NTKERNELAPI
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID
KeGenericCallDpc (
    _In_ PKDEFERRED_ROUTINE Routine,
    _In_opt_ PVOID Context
    );

NTKERNELAPI
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
VOID
KeSignalCallDpcDone (
    _In_ PVOID SystemArgument1
    );

NTKERNELAPI
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
LOGICAL
KeSignalCallDpcSynchronize (
    _In_ PVOID SystemArgument2
    );


NTKERNELAPI
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
KPRIORITY
KeQueryEffectivePriorityThread (
    __in PKTHREAD Thread
    );


NTKERNELAPI
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
BOOLEAN
KeTestAlertThread (
    _In_ KPROCESSOR_MODE
    );

extern PLOADER_PARAMETER_BLOCK KeLoaderBlock;       

#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks

// begin_ntddk

//
// Several routines have an architecture specific implementation. Generate
// an error if a supported target is not defined.
//

#if !(defined(_X86_) || defined(_AMD64_) || defined(_ARM_) || defined(_ARM64_))

#error "No target architecture defined"

#endif

#if (NTDDI_VERSION < NTDDI_WIN7) || defined(_X86_) || !defined(NT_PROCESSOR_GROUPS)

#define SINGLE_GROUP_LEGACY_API 1

#endif


// end_ntddk
//

#if defined(_X86_) || defined(_AMD64_)

#define PAUSE_PROCESSOR YieldProcessor();

#elif defined(_ARM_) || defined(_ARM64_)

#define PAUSE_PROCESSOR __yield();

#endif


//
// Define macro to generate an affinity mask.
//

#define AFFINITY_MASK(n) (((ULONG_PTR)1) << (n))

#if (defined(_X86_) || defined(_AMD64_)) && !defined(XBOX_SYSTEMOS)

typedef struct _PROCESSOR_LOCKSTEP {
    ULONG Processor;
    LONG Limit;
    volatile LONG TargetCount;
    LONG volatile *TargetPhase;
} PROCESSOR_LOCKSTEP, *PPROCESSOR_LOCKSTEP;

NTSTATUS
KeLoadMTRR (
    __inout PPROCESSOR_LOCKSTEP IpiContext
    );

#endif

// begin_wudfwdm
// begin_wdm begin_ntminiport begin_ntndis
// begin_ntoshvp
//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
} KINTERRUPT_MODE;

// end_wudfwdm

typedef enum _KINTERRUPT_POLARITY {
    InterruptPolarityUnknown,
    InterruptActiveHigh,
    InterruptRisingEdge = InterruptActiveHigh,
    InterruptActiveLow,
    InterruptFallingEdge = InterruptActiveLow,

#if (NTDDI_VERSION >= NTDDI_WIN8)

    InterruptActiveBoth,

#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

    InterruptActiveBothTriggerLow = InterruptActiveBoth,
    InterruptActiveBothTriggerHigh,

#endif

} KINTERRUPT_POLARITY, *PKINTERRUPT_POLARITY;

// end_ntoshvp
// begin_wudfpwdm
//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrSpare0,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    MaximumWaitReason
} KWAIT_REASON;

// end_wudfpwdm
// end_wdm
// begin_ntifs

//
// Miscellaneous type definitions
//
// APC state
//
// N.B. The user APC pending field must be the last member of this structure.
//

typedef struct _KAPC_STATE {
    LIST_ENTRY ApcListHead[MaximumMode];
    struct _KPROCESS *Process;
    union {
        UCHAR InProgressFlags;
        struct {
            BOOLEAN KernelApcInProgress : 1;
            BOOLEAN SpecialApcInProgress : 1;
        };
    };

    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;

// end_ntifs

#define KE_KERNEL_APC_IN_PROGRESS 0x1
#define KE_SPECIAL_APC_IN_PROGRESS 0x2

_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
KeIsWaitListEmpty (
    _In_ PVOID Object
    );


typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    UCHAR WaitType;
    volatile UCHAR BlockState;
    USHORT WaitKey;

#if defined(_WIN64)

    LONG SpareLong;

#endif

    union {
        struct _KTHREAD *Thread;
        struct _KQUEUE *NotificationQueue;
    };

    PVOID Object;
    PVOID SparePtr;

} KWAIT_BLOCK, *PKWAIT_BLOCK, *PRKWAIT_BLOCK;

//
// Thread start function
//

typedef
_IRQL_requires_same_
_Function_class_(KSTART_ROUTINE)
VOID
KSTART_ROUTINE (
    _In_ PVOID StartContext
    );
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

#define ASSERT_DEVICE_QUEUE(E) NT_ASSERT((E)->Type == DeviceQueueObject)

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;

#if defined(_AMD64_)

    union {
        BOOLEAN Busy;
        struct {
            LONG64 Reserved : 8;
            LONG64 Hint : 56;
        };
    };

#else

    BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

//
// Define the interrupt service function type and the empty struct
// type.
//

typedef
_Function_class_(KSERVICE_ROUTINE)
_IRQL_requires_(HIGH_LEVEL) // HIGH_LEVEL is best approximation of DIRQL
_IRQL_requires_same_
BOOLEAN
KSERVICE_ROUTINE (
    _In_ struct _KINTERRUPT *Interrupt,
    _In_opt_ PVOID ServiceContext
    );

typedef KSERVICE_ROUTINE *PKSERVICE_ROUTINE;

typedef
_Function_class_(KMESSAGE_SERVICE_ROUTINE)
_IRQL_requires_same_
BOOLEAN
KMESSAGE_SERVICE_ROUTINE (
    _In_ struct _KINTERRUPT *Interrupt,
    _In_ PVOID ServiceContext,
    _In_ ULONG MessageID
    );

typedef KMESSAGE_SERVICE_ROUTINE *PKMESSAGE_SERVICE_ROUTINE;

typedef struct _KINTERRUPT *PKINTERRUPT, *PRKINTERRUPT; 
//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;


typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;       // Object lock
    volatile ULONG CurrentCount;    // Interlocked
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;      // Object lock
} KQUEUE, *PKQUEUE, *PRKQUEUE;

typedef struct _KPRIQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead[MAXIMUM_PRIORITY];
    volatile LONG CurrentCount[MAXIMUM_PRIORITY];
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KPRIQUEUE, *PKPRIQUEUE;
//
//
// Semaphore object
//
// N.B. The limit field must be the last member of this structure.
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

#define KSEMAPHORE_ACTUAL_LENGTH                                             \
    (FIELD_OFFSET(KSEMAPHORE, Limit) + sizeof(LONG))

//
// DPC object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeDpc (
    _Out_ __drv_aliasesMem PRKDPC Dpc,
    _In_ PKDEFERRED_ROUTINE DeferredRoutine,
    _In_opt_ __drv_aliasesMem PVOID DeferredContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
KeInitializeThreadedDpc (
    _Out_ PRKDPC Dpc,
    _In_ PKDEFERRED_ROUTINE DeferredRoutine,
    _In_opt_ PVOID DeferredContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    _Inout_ PRKDPC Dpc,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ __drv_aliasesMem PVOID SystemArgument2
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(HIGH_LEVEL)
NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    _Inout_ PRKDPC Dpc
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_max_(HIGH_LEVEL)
NTKERNELAPI
BOOLEAN
KeRemoveQueueDpcEx (
    _Inout_ PRKDPC Dpc,
    _In_ BOOLEAN WaitIfActive
    );
#endif

// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
NTSTATUS
KeInitializeCrashDumpHeader(
    _In_ ULONG DumpType,
    _In_ ULONG Flags,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG BufferNeeded
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeSetImportanceDpc (
    _Inout_ PRKDPC Dpc,
    _In_ KDPC_IMPORTANCE Importance
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K) && defined(SINGLE_GROUP_LEGACY_API)
NTKERNELAPI
VOID
KeSetTargetProcessorDpc (
    _Inout_ PRKDPC Dpc,
    _In_ CCHAR Number
    );
#endif

// end_ntddk

#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeFlushQueuedDpcs (
    VOID
    );
#endif

//
// Device queue object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    _Out_ PKDEVICE_QUEUE DeviceQueue
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    _Inout_ PKDEVICE_QUEUE DeviceQueue,
    _Inout_ PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    _Inout_ PKDEVICE_QUEUE DeviceQueue,
    _Inout_ PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    _In_ ULONG SortKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    _Inout_ PKDEVICE_QUEUE DeviceQueue
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    _Inout_ PKDEVICE_QUEUE DeviceQueue,
    _In_ ULONG SortKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueueIfBusy (
    _Inout_ PKDEVICE_QUEUE DeviceQueue,
    _In_ ULONG SortKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    _Inout_ PKDEVICE_QUEUE DeviceQueue,
    _Inout_ PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(HIGH_LEVEL) // HIGH_LEVEL is best approximation of DIRQL
NTKERNELAPI
BOOLEAN
KeSynchronizeExecution (
    _Inout_ PKINTERRUPT Interrupt,
    _In_ PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    _In_opt_ __drv_aliasesMem PVOID SynchronizeContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_not_held_(*Interrupt->ActualLock)
_Acquires_lock_(*Interrupt->ActualLock)
_IRQL_requires_max_(HIGH_LEVEL) // HIGH_LEVEL is best approximation of DIRQL
_IRQL_saves_
_IRQL_raises_(HIGH_LEVEL) // HIGH_LEVEL is best approximation of DIRQL
NTKERNELAPI
KIRQL
KeAcquireInterruptSpinLock (
    _Inout_ PKINTERRUPT Interrupt
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_held_(*Interrupt->ActualLock)
_Releases_lock_(*Interrupt->ActualLock)
_IRQL_requires_(HIGH_LEVEL) // HIGH_LEVEL is best approximation of DIRQL
NTKERNELAPI
VOID
KeReleaseInterruptSpinLock (
    _Inout_ PKINTERRUPT Interrupt,
    _In_ _IRQL_restores_ KIRQL OldIrql
    );
#endif

//
// Kernel dispatcher object functions
//
// Event Object
//

NTKERNELAPI
VOID
KeInitializeEvent (
    _Out_ PRKEVENT Event,
    _In_ EVENT_TYPE Type,
    _In_ BOOLEAN State
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeClearEvent (
    _Inout_ PRKEVENT Event
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KePulseEvent (
    _Inout_ PRKEVENT Event,
    _In_ KPRIORITY Increment,
    _In_ BOOLEAN Wait
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeReadStateEvent (
    _In_ PRKEVENT Event
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeResetEvent (
    _Inout_ PRKEVENT Event
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_When_(Wait==0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(Wait==1, _IRQL_requires_max_(APC_LEVEL))
_When_(Wait==1, __drv_reportError("Caution: 'Wait' argument does not provide"
                                      " any synchronization guarantees, only a hint"
                                      " to the system that the thread will immediately"
                                      " issue a wait operation"))
NTKERNELAPI
LONG
KeSetEvent (
    _Inout_ PRKEVENT Event,
    _In_ KPRIORITY Increment,
    _In_ _Literal_ BOOLEAN Wait
    );
#endif

//
// Mutex object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeMutex (
    _Out_ PRKMUTEX Mutex,
    _In_ ULONG Level
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeReadStateMutex (
    _In_ PRKMUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_When_(Wait==0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(Wait==1, _IRQL_requires_max_(APC_LEVEL))
_When_(Wait==1, __drv_reportError("Caution: 'Wait' argument does not provide"
                                      " any synchronization guarantees, only a hint"
                                      " to the system that the thread will immediately"
                                      " issue a wait operation"))
NTKERNELAPI
LONG
KeReleaseMutex (
    _Inout_ PRKMUTEX Mutex,
    _In_ BOOLEAN Wait
    );
#endif

// end_wdm
// begin_nthal begin_ntifs
//
// Queue Object.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeQueue (
    _Out_ PRKQUEUE Queue,
    _In_ ULONG Count
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeReadStateQueue (
    _In_ PRKQUEUE Queue
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeInsertQueue (
    _Inout_ PRKQUEUE Queue,
    _Inout_ PLIST_ENTRY Entry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeInsertHeadQueue (
    _Inout_ PRKQUEUE Queue,
    _Inout_ PLIST_ENTRY Entry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_When_((Timeout==NULL || Timeout->QuadPart!=0), _IRQL_requires_max_(APC_LEVEL))
_When_((Timeout!=NULL && Timeout->QuadPart==0), _IRQL_requires_max_(DISPATCH_LEVEL))
NTKERNELAPI
PLIST_ENTRY
KeRemoveQueue (
    _Inout_ PRKQUEUE Queue,
    _In_ KPROCESSOR_MODE WaitMode,
    _In_opt_ PLARGE_INTEGER Timeout
    );
#endif

// end_ntifs end_nthal
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_min_(PASSIVE_LEVEL)
_When_((Timeout==NULL || Timeout->QuadPart!=0), _IRQL_requires_max_(APC_LEVEL))
_When_((Timeout!=NULL && Timeout->QuadPart==0), _IRQL_requires_max_(DISPATCH_LEVEL))
NTKERNELAPI
ULONG
KeRemoveQueueEx (
    _Inout_ PKQUEUE Queue,
    _In_ KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_writes_to_(Count, return) PLIST_ENTRY *EntryArray,
    _In_ ULONG Count
    );
#endif

// end_ntifs
// begin_ntifs begin_nthal

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PLIST_ENTRY
KeRundownQueue (
    _Inout_ PRKQUEUE Queue
    );
#endif

// end_ntifs end_nthal

#define KI_PRIQUEUE_WAIT_NEXT   0x00000001UL
#define KI_PRIQUEUE_THREAD_AVAILABLE  0x00000002UL

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

NTKERNELAPI
VOID
KeInitializePriQueue (
    _Out_ PKPRIQUEUE Queue,
    _In_ ULONG Count
    );

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeInsertPriQueue (
    _Inout_ PKPRIQUEUE Queue,
    _Inout_ PLIST_ENTRY Entry,
    _In_ KPRIORITY Priority,
    _In_ KPRIORITY Increment,
    _In_ ULONG Flags
    );

_IRQL_requires_min_(PASSIVE_LEVEL)
_When_((Timeout==NULL || Timeout->QuadPart!=0), _IRQL_requires_max_(APC_LEVEL))
_When_((Timeout!=NULL && Timeout->QuadPart==0), _IRQL_requires_max_(DISPATCH_LEVEL))
NTKERNELAPI
PLIST_ENTRY
KeRemovePriQueue (
    _Inout_ PKPRIQUEUE Queue,
    _In_ KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

_IRQL_requires_same_
VOID
KeSetMaximumCountPriQueue (
    _Inout_ PKPRIQUEUE Queue,
    _In_ ULONG NewMaximumCount
    );

#endif

// begin_wdm
//
// Semaphore object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeInitializeSemaphore (
    _Out_ PRKSEMAPHORE Semaphore,
    _In_ LONG Count,
    _In_ LONG Limit
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeReadStateSemaphore (
    _In_ PRKSEMAPHORE Semaphore
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_When_(Wait==0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(Wait==1, _IRQL_requires_max_(APC_LEVEL))
_When_(Wait==1, __drv_reportError("Caution: 'Wait' argument does not provide"
                                      " any synchronization guarantees, only a hint"
                                      " to the system that the thread will immediately"
                                      " issue a wait operation"))
NTKERNELAPI
LONG
KeReleaseSemaphore (
    _Inout_ PRKSEMAPHORE Semaphore,
    _In_ KPRIORITY Increment,
    _In_ LONG Adjustment,
    _In_ _Literal_ BOOLEAN Wait
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeAttachProcess (
    _Inout_ PRKPROCESS Process
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeDetachProcess (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeStackAttachProcess (
    _Inout_ PRKPROCESS PROCESS,
    _Out_ PRKAPC_STATE ApcState
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeUnstackDetachProcess (
    _In_ PRKAPC_STATE ApcState
    );
#endif


_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
KeIsAttachedProcess (
    VOID
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
KeDelayExecutionThread (
    _In_ KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_ PLARGE_INTEGER Interval
    );
#endif


#define MAXIMUM_EXPANSION_SIZE (KERNEL_LARGE_STACK_SIZE - (PAGE_SIZE / 2))

typedef
_IRQL_requires_same_
_Function_class_(EXPAND_STACK_CALLOUT)
VOID
(NTAPI EXPAND_STACK_CALLOUT) (
    _In_opt_ PVOID Parameter
    );

typedef EXPAND_STACK_CALLOUT *PEXPAND_STACK_CALLOUT;

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
KeExpandKernelStackAndCallout (
    _In_ PEXPAND_STACK_CALLOUT Callout,
    _In_opt_ PVOID Parameter,
    _In_ SIZE_T Size
    );

#endif

// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
__drv_reportError("DISPATCH_LEVEL is only supported on Windows 7 or later.")
NTKERNELAPI
NTSTATUS
KeExpandKernelStackAndCalloutEx (
    _In_ PEXPAND_STACK_CALLOUT Callout,
    _In_opt_ PVOID Parameter,
    _In_ SIZE_T Size,
    _In_ BOOLEAN Wait,
    _In_opt_ PVOID Context
    );
#endif

// end_ntifs
// end_ntddk
// begin_ntosifs

#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
KeAllocateCalloutStack (
    _In_ BOOLEAN LargeStack
    );

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeFreeCalloutStack (
    _In_ PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef enum _KSTACK_TYPE {
    ReserveStackNormal = 0,
    ReserveStackLarge,
    MaximumReserveStacks
} KSTACK_TYPE;

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
KeAllocateCalloutStackEx (
    _In_ _Strict_type_match_ KSTACK_TYPE StackType,
    _In_ UCHAR RecursionDepth,
    _Reserved_ SIZE_T Reserved,
    _Outptr_ PVOID *StackContext
    );

#endif

// end_ntosifs
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
KPRIORITY
KeQueryPriorityThread (
    _In_ PKTHREAD Thread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
ULONG
KeQueryRuntimeThread (
    _In_ PKTHREAD Thread,
    _Out_ PULONG UserTime
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
ULONG64
KeQueryTotalCycleTimeThread (
    _Inout_ PKTHREAD Thread,
    _Out_ PULONG64 CycleTimeStamp
    );
#endif

// end_wdm
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN7)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
KeSetTargetProcessorDpcEx (
    _Inout_ PKDPC Dpc,
    _In_ PPROCESSOR_NUMBER ProcNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K) && defined(SINGLE_GROUP_LEGACY_API)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeRevertToUserAffinityThread (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K) && defined(SINGLE_GROUP_LEGACY_API)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeSetSystemAffinityThread (
    _In_ KAFFINITY Affinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA) && defined(SINGLE_GROUP_LEGACY_API)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeRevertToUserAffinityThreadEx (
    _In_ KAFFINITY Affinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeSetSystemGroupAffinityThread (
    _In_ PGROUP_AFFINITY Affinity,
    _Out_opt_ PGROUP_AFFINITY PreviousAffinity
    );

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeRevertToUserGroupAffinityThread (
    _In_ PGROUP_AFFINITY PreviousAffinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(SINGLE_GROUP_LEGACY_API)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
KAFFINITY
KeSetSystemAffinityThreadEx (
    _In_ KAFFINITY Affinity
    );
#endif

// end_wdm

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
NTSTATUS
KeSetSelectedCpuSetsThread (
    _Inout_ PKTHREAD Thread,
    _In_ ULONG CpuSetCount,
    _In_reads_(CpuSetCount) PULONG64 CpuSetMasks
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG
KeSetBasePriorityThread (
    _Inout_ PKTHREAD Thread,
    _In_ LONG Increment
    );
#endif

// end_ntddk

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
KPRIORITY
KeSetActualBasePriorityThread (
    _Inout_ PKTHREAD Thread,
    _In_ KPRIORITY NewBase
    );
#endif

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
KHETERO_CPU_POLICY
FASTCALL
KeQueryHeteroCpuPolicyThread (
    _In_ PKTHREAD Thread,
    _In_ LOGICAL UserPolicy
    );

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
KHETERO_CPU_POLICY
KeSetHeteroCpuPolicyThread (
    PKTHREAD Thread,
    KHETERO_CPU_POLICY Policy,
    LOGICAL Reset
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
KeSetKernelStackSwapEnable (
    _In_ BOOLEAN Enable
    );
#endif

// end_ntifs
// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
KPRIORITY
KeSetPriorityThread (
    _Inout_ PKTHREAD Thread,
    _In_ KPRIORITY Priority
    );
#endif

// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Acquires_lock_(_Global_critical_region_)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Releases_lock_(_Global_critical_region_)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Acquires_lock_(_Global_critical_region_)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeEnterGuardedRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Releases_lock_(_Global_critical_region_)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
KeLeaveGuardedRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeAreApcsDisabled (
    VOID
    );
#endif

// end_ntddk

//
// Timer object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeInitializeTimer (
    _Out_ PKTIMER Timer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeInitializeTimerEx (
    _Out_ PKTIMER Timer,
    _In_ TIMER_TYPE Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeCancelTimer (
    _Inout_ PKTIMER
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeReadStateTimer (
    _In_ PKTIMER Timer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeSetTimer (
    _Inout_ PKTIMER Timer,
    _In_ LARGE_INTEGER DueTime,
    _In_opt_ PKDPC Dpc
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    _Inout_ PKTIMER Timer,
    _In_ LARGE_INTEGER DueTime,
    _In_ LONG Period,
    _In_opt_ PKDPC Dpc
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeSetCoalescableTimer (
    _Inout_ PKTIMER Timer,
    _In_ LARGE_INTEGER DueTime,
    _In_ ULONG Period,
    _In_ ULONG TolerableDelay,
    _In_opt_ PKDPC Dpc
    );
#endif


#define KeWaitForMutexObject KeWaitForSingleObject

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_When_((Timeout==NULL || Timeout->QuadPart!=0), _IRQL_requires_max_(APC_LEVEL))
_When_((Timeout!=NULL && Timeout->QuadPart==0), _IRQL_requires_max_(DISPATCH_LEVEL))
NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    _In_ ULONG Count,
    _In_reads_(Count) PVOID Object[],
    _In_ _Strict_type_match_ WAIT_TYPE WaitType,
    _In_ _Strict_type_match_ KWAIT_REASON WaitReason,
    _In_ __drv_strictType(KPROCESSOR_MODE/enum _MODE,__drv_typeConst) KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_opt_ PKWAIT_BLOCK WaitBlockArray
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_min_(PASSIVE_LEVEL)
_When_((Timeout==NULL || Timeout->QuadPart!=0), _IRQL_requires_max_(APC_LEVEL))
_When_((Timeout!=NULL && Timeout->QuadPart==0), _IRQL_requires_max_(DISPATCH_LEVEL))
NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    _In_ _Points_to_data_ PVOID Object,
    _In_ _Strict_type_match_ KWAIT_REASON WaitReason,
    _In_ __drv_strictType(KPROCESSOR_MODE/enum _MODE,__drv_typeConst) KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );
#endif

//
// Define interprocess interrupt generic call types.
//

typedef
_IRQL_requires_same_
_Function_class_(KIPI_BROADCAST_WORKER)
_IRQL_requires_(IPI_LEVEL)
ULONG_PTR
KIPI_BROADCAST_WORKER (
    _In_ ULONG_PTR Argument
    );

typedef KIPI_BROADCAST_WORKER *PKIPI_BROADCAST_WORKER;

#if (NTDDI_VERSION >= NTDDI_WS03)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(IPI_LEVEL-1)
NTKERNELAPI
ULONG_PTR
KeIpiGenericCall (
    _In_ PKIPI_BROADCAST_WORKER BroadcastFunction,
    _In_ ULONG_PTR Context
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_not_held_(Number)
_Acquires_lock_(Number)
_IRQL_raises_(DISPATCH_LEVEL)
NTKERNELAPI
KIRQL
FASTCALL
KeAcquireQueuedSpinLock (
    _In_ KSPIN_LOCK_QUEUE_NUMBER Number
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_held_(Number)
_Releases_lock_(Number)
NTKERNELAPI
VOID
FASTCALL
KeReleaseQueuedSpinLock (
    _In_ KSPIN_LOCK_QUEUE_NUMBER Number,
    _In_ KIRQL OldIrql
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Must_inspect_result_
_Post_satisfies_(return == 1 || return == 0)
NTKERNELAPI
LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock (
    _In_ KSPIN_LOCK_QUEUE_NUMBER Number,
    _Out_ _At_(*OldIrql, _IRQL_saves_)
    PKIRQL OldIrql
    );
#endif

//
// Spin lock functions
//

#if ((defined(_X86_) && (defined(_WDM_INCLUDED_) || defined(WIN9X_COMPAT_SPINLOCK))) || \
     ((NTDDI_VERSION > NTDDI_WIN7) && !defined(WIN9X_COMPAT_SPINLOCK) && \
      (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_) || defined(_BLDR_))))

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    _Out_ PKSPIN_LOCK SpinLock
    );

#endif

#else

CFORCEINLINE
VOID
NTAPI
KzInitializeSpinLock (
    _Out_ PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function initializes a spinlock.

Arguments:

    SpinLock - Supplies a pointer to a spinlock.

Return Value:

    None.

--*/

{

    *SpinLock = 0;
    return;
}

#define KeInitializeSpinLock KzInitializeSpinLock

#endif

// begin_nthal

#if (NTDDI_VERSION >= NTDDI_WS03)
_Must_inspect_result_
NTKERNELAPI
BOOLEAN
FASTCALL
KeTestSpinLock (
    _In_ PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Must_inspect_result_
_IRQL_requires_min_(DISPATCH_LEVEL)
_Post_satisfies_(return == 1 || return == 0)
NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    _Inout_ _Requires_lock_not_held_(*_Curr_)
    _When_(return!=0, _Acquires_lock_(*_Curr_))
    PKSPIN_LOCK SpinLock
    );
#endif

#if defined(_X86_)   // ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_not_held_(*SpinLock)
_Acquires_lock_(*SpinLock)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_held_(*SpinLock)
_Releases_lock_(*SpinLock)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

#define KeAcquireSpinLockAtDpcLevel(a) KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a) KefReleaseSpinLockFromDpcLevel(a)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_not_held_(*SpinLock)
_Acquires_lock_(*SpinLock)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
NTKERNELAPI
KIRQL
FASTCALL
KfAcquireSpinLock (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_held_(*SpinLock)
_Releases_lock_(*SpinLock)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KfReleaseSpinLock (
    _Inout_ PKSPIN_LOCK SpinLock,
    _In_ _IRQL_restores_ KIRQL NewIrql
    );
#endif

// end_wdm
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_not_held_(*SpinLock)
_Acquires_lock_(*SpinLock)
_IRQL_raises_(SYNCH_LEVEL)
_IRQL_saves_
NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

// end_ntifs
// begin_wdm

#define KeAcquireSpinLock(a,b) *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b) KfReleaseSpinLock(a,b)

#else // ntifs

//
// These functions are imported for ARM, ntddk, ntifs, nthal, ntosp, and wdm.
// They can be inlined for the system on AMD64.
//

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

// end_wdm

// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_not_held_(*SpinLock)
_Acquires_lock_(*SpinLock)
_IRQL_raises_(SYNCH_LEVEL)
_IRQL_saves_
NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToSynch (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

// end_ntifs
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_not_held_(*SpinLock)
_Acquires_lock_(*SpinLock)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_not_held_(*SpinLock)
_Acquires_lock_(*SpinLock)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToDpc (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_held_(*SpinLock)
_Releases_lock_(*SpinLock)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeReleaseSpinLock (
    _Inout_ PKSPIN_LOCK SpinLock,
    _In_ _IRQL_restores_ KIRQL NewIrql
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_held_(*SpinLock)
_Releases_lock_(*SpinLock)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

#endif // ntifs

// end_nthal
// end_wdm

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WS03)
_Requires_lock_not_held_(*SpinLock)
_Acquires_lock_(*SpinLock)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_
NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockForDpc (
    _Inout_ PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
_Requires_lock_held_(*SpinLock)
_Releases_lock_(*SpinLock)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeReleaseSpinLockForDpc (
    _Inout_ PKSPIN_LOCK SpinLock,
    _In_ _IRQL_restores_ KIRQL OldIrql
    );
#endif

// end_ntndis

//
// Queued spin lock functions for "in stack" lock handles.
//
// The following three functions RAISE and LOWER IRQL when a queued
// in stack spin lock is acquired or released using these routines.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_not_held_(*LockHandle)
_Acquires_lock_(*LockHandle)
_Post_same_lock_(*SpinLock, *LockHandle)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_global_(QueuedSpinLock,LockHandle)
_IRQL_raises_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLock (
    _Inout_ PKSPIN_LOCK SpinLock,
    _Out_ PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_held_(*LockHandle)
_Releases_lock_(*LockHandle)
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_restores_global_(QueuedSpinLock,LockHandle)
NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLock (
    _In_ PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

//
// The following two functions do NOT raise or lower IRQL when a queued
// in stack spin lock is acquired or released using these functions.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_not_held_(*LockHandle)
_Acquires_lock_(*LockHandle)
_Post_same_lock_(*SpinLock, *LockHandle)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockAtDpcLevel (
    _Inout_ PKSPIN_LOCK SpinLock,
    _Out_ PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Requires_lock_held_(*LockHandle)
_Releases_lock_(*LockHandle)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    _In_ PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

//
// The following two functions conditionally raise or lower IRQL when a
// queued in-stack spin lock is acquired or released using these functions.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
_Requires_lock_not_held_(*LockHandle)
_Acquires_lock_(*LockHandle)
_Post_same_lock_(*SpinLock, *LockHandle)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_saves_global_(QueuedSpinLock,LockHandle)
NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockForDpc (
    _Inout_ PKSPIN_LOCK SpinLock,
    _Out_ PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_Requires_lock_held_(*LockHandle)
_Releases_lock_(*LockHandle)
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_restores_global_(QueuedSpinLock,LockHandle)
NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockForDpc (
    _In_ PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

//
// Miscellaneous kernel functions
//

typedef struct _KDPC_WATCHDOG_INFORMATION {
    ULONG DpcTimeLimit;
    ULONG DpcTimeCount;
    ULONG DpcWatchdogLimit;
    ULONG DpcWatchdogCount;
    ULONG Reserved;
} KDPC_WATCHDOG_INFORMATION, *PKDPC_WATCHDOG_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
KeQueryDpcWatchdogInformation (
    _Out_ PKDPC_WATCHDOG_INFORMATION WatchdogInformation
    );
#endif

typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;

typedef
_Function_class_(KBUGCHECK_CALLBACK_ROUTINE)
_IRQL_requires_same_
VOID
KBUGCHECK_CALLBACK_ROUTINE (
    IN PVOID Buffer,
    IN ULONG Length
    );
typedef KBUGCHECK_CALLBACK_ROUTINE *PKBUGCHECK_CALLBACK_ROUTINE;

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
    _Field_size_bytes_opt_(Length) PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

#define KeInitializeCallbackRecord(CallbackRecord) \
    (CallbackRecord)->State = BufferEmpty

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckCallback (
    _Inout_ PKBUGCHECK_CALLBACK_RECORD CallbackRecord
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
NTKERNELAPI
BOOLEAN
KeRegisterBugCheckCallback (
    _Out_ PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
    _In_ PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
    _In_reads_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ PUCHAR Component
    );
#endif

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
    KbCallbackAddPages,
    KbCallbackSecondaryMultiPartDumpData,
    KbCallbackRemovePages
} KBUGCHECK_CALLBACK_REASON;

typedef
_Function_class_(KBUGCHECK_REASON_CALLBACK_ROUTINE)
_IRQL_requires_same_
VOID
KBUGCHECK_REASON_CALLBACK_ROUTINE (
    _In_ KBUGCHECK_CALLBACK_REASON Reason,
    _In_ struct _KBUGCHECK_REASON_CALLBACK_RECORD* Record,
    _Inout_ PVOID ReasonSpecificData,
    _In_ ULONG ReasonSpecificDataLength
    );
typedef KBUGCHECK_REASON_CALLBACK_ROUTINE *PKBUGCHECK_REASON_CALLBACK_ROUTINE;

KBUGCHECK_REASON_CALLBACK_ROUTINE BugCheckSecondaryMultiPartDumpDataCallback;

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _KBUGCHECK_SECONDARY_DUMP_DATA {
    IN PVOID InBuffer;
    IN ULONG InBufferLength;
    IN ULONG MaximumAllowed;
    OUT GUID Guid;
    OUT PVOID OutBuffer;
    OUT ULONG OutBufferLength;
} KBUGCHECK_SECONDARY_DUMP_DATA, *PKBUGCHECK_SECONDARY_DUMP_DATA;

typedef struct _KBUGCHECK_SECONDARY_DUMP_DATA_EX {
    _In_    PVOID InBuffer;
    _In_    ULONG InBufferLength;
    _In_    ULONG MaximumAllowed;
    _Out_   GUID  Guid;
    _Inout_ PVOID OutBuffer;
    _Inout_ ULONG OutBufferLength;
    _Inout_ PVOID Context;
    _Inout_ ULONG Flags;         // KB_SECONDARY_DATA_FLAG_xxx
    _In_    ULONG DumpType;      // DUMP_TYPE defined in ntiodump.h
    _In_    ULONG BugCheckCode;
    _In_    ULONG_PTR BugCheckParameter1;
    _In_    ULONG_PTR BugCheckParameter2;
    _In_    ULONG_PTR BugCheckParameter3;
    _In_    ULONG_PTR BugCheckParameter4;
} KBUGCHECK_SECONDARY_DUMP_DATA_EX, *PKBUGCHECK_SECONDARY_DUMP_DATA_EX;

#define KB_SECONDARY_DATA_FLAG_ADDITIONAL_DATA      0x00000001
#define KB_SECONDARY_DATA_FLAG_NO_DEVICE_ACCESS     0x00000002

typedef enum _KBUGCHECK_DUMP_IO_TYPE {
    KbDumpIoInvalid,
    KbDumpIoHeader,
    KbDumpIoBody,
    KbDumpIoSecondaryData,
    KbDumpIoComplete
} KBUGCHECK_DUMP_IO_TYPE;

typedef struct _KBUGCHECK_DUMP_IO {
    IN ULONG64 Offset;
    IN PVOID Buffer;
    IN ULONG BufferLength;
    IN KBUGCHECK_DUMP_IO_TYPE Type;
} KBUGCHECK_DUMP_IO, *PKBUGCHECK_DUMP_IO;

//
// KbCallbackAddPages related definitions
//

#define KB_ADD_PAGES_FLAG_VIRTUAL_ADDRESS           0x00000001UL
#define KB_ADD_PAGES_FLAG_PHYSICAL_ADDRESS          0x00000002UL
#define KB_ADD_PAGES_FLAG_ADDITIONAL_RANGES_EXIST   0x80000000UL
// end_wdm

//
// 4 bits of the 'Flags' field are used to specify a set of page
// features, such as their encryption domain.
//

#define KB_ADD_PAGES_FEATURE_MASK                   0x000000f0UL
#define KB_ADD_PAGES_FEATURE_SHIFT                  4

// begin_wdm

typedef struct _KBUGCHECK_ADD_PAGES {
    _Inout_ PVOID Context;      // Private context for callback use
    _Inout_ ULONG Flags;        // Zero initialized on input
    _In_ ULONG BugCheckCode;
    _Out_ ULONG_PTR Address;
    _Out_ ULONG_PTR Count;
} KBUGCHECK_ADD_PAGES, *PKBUGCHECK_ADD_PAGES;

//
// KbCallbackRemovePages related definitions
//

#define KB_REMOVE_PAGES_FLAG_VIRTUAL_ADDRESS           0x00000001UL
#define KB_REMOVE_PAGES_FLAG_PHYSICAL_ADDRESS          0x00000002UL
#define KB_REMOVE_PAGES_FLAG_ADDITIONAL_RANGES_EXIST   0x80000000UL

typedef struct _KBUGCHECK_REMOVE_PAGES {
    _Inout_ PVOID Context;      // Private context for callback use
    _Inout_ ULONG Flags;        // Zero initialized on input
    _In_ ULONG BugCheckCode;
    _Out_ ULONG_PTR Address;
    _Out_ ULONG_PTR Count;
} KBUGCHECK_REMOVE_PAGES, *PKBUGCHECK_REMOVE_PAGES;

//
// Equates for exceptions which cause system fatal error
//

#define EXCEPTION_DIVIDED_BY_ZERO       0
#define EXCEPTION_DEBUG                 1
#define EXCEPTION_NMI                   2
#define EXCEPTION_INT3                  3
#define EXCEPTION_BOUND_CHECK           5
#define EXCEPTION_INVALID_OPCODE        6
#define EXCEPTION_NPX_NOT_AVAILABLE     7
#define EXCEPTION_DOUBLE_FAULT          8
#define EXCEPTION_NPX_OVERRUN           9
#define EXCEPTION_INVALID_TSS           0x0A
#define EXCEPTION_SEGMENT_NOT_PRESENT   0x0B
#define EXCEPTION_STACK_FAULT           0x0C
#define EXCEPTION_GP_FAULT              0x0D
#define EXCEPTION_RESERVED_TRAP         0x0F
#define EXCEPTION_NPX_ERROR             0x010
#define EXCEPTION_ALIGNMENT_CHECK       0x011

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
_Must_inspect_result_
NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckReasonCallback (
    _Inout_ PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
_Must_inspect_result_
NTKERNELAPI
BOOLEAN
KeRegisterBugCheckReasonCallback (
    _Out_ PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
    _In_ PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
    _In_ KBUGCHECK_CALLBACK_REASON Reason,
    _In_ PUCHAR Component
    );
#endif

typedef
_Function_class_(NMI_CALLBACK)
_IRQL_requires_same_
BOOLEAN
NMI_CALLBACK(
    _In_opt_ PVOID Context,
    _In_ BOOLEAN Handled
    );
typedef NMI_CALLBACK *PNMI_CALLBACK;

#if (NTDDI_VERSION >= NTDDI_WS03)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
KeRegisterNmiCallback (
    _In_ PNMI_CALLBACK CallbackRoutine,
    _In_opt_ PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
KeDeregisterNmiCallback (
    _In_ PVOID Handle
    );
#endif

#if defined(_X86_) || defined(_AMD64_)

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
typedef enum _BOUND_CALLBACK_STATUS {
    BoundExceptionContinueSearch = 0,
    BoundExceptionHandled,
    BoundExceptionError,
    BoundExceptionMaximum
} BOUND_CALLBACK_STATUS, *PBOUND_CALLBACK_STATUS;
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
typedef
_IRQL_requires_same_
BOUND_CALLBACK_STATUS
BOUND_CALLBACK(
    VOID
    );
typedef BOUND_CALLBACK *PBOUND_CALLBACK;
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
KeRegisterBoundCallback (
    _In_ PBOUND_CALLBACK CallbackRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
KeDeregisterBoundCallback (
    _In_ PVOID Handle
    );
#endif

#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__drv_preferredFunction("error logging or driver shutdown",
    "Whenever possible, all kernel-mode components should log an error and "
    "continue to run, rather than calling KeBugCheck")
NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    _In_ ULONG BugCheckCode
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
__drv_preferredFunction("error logging or driver shutdown",
    "Whenever possible, all kernel-mode components should log an error and "
    "continue to run, rather than calling KeBugCheckEx")
NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheckEx(
    _In_ ULONG BugCheckCode,
    _In_ ULONG_PTR BugCheckParameter1,
    _In_ ULONG_PTR BugCheckParameter2,
    _In_ ULONG_PTR BugCheckParameter3,
    _In_ ULONG_PTR BugCheckParameter4
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeInvalidateAllCaches (
    VOID
    );
#endif

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeInvalidateRangeAllCaches (
    _In_ PVOID BaseAddress,
    _In_ ULONG Length
    );

// end_ntddk
// begin_nthal

#define IOMMU_FLUSH_ENTIRE MAXULONG

typedef struct _KTB_FLUSH_VA {
    union {
        struct {

#define KTB_FLUSH_RUN_MAXIMUM  (PAGE_SIZE / 2 - 1)

            ULONG_PTR NumberOfEntries : 11; // 0 means 1 entry, 1 means 2 etc
            ULONG_PTR PageSize : 1;     // 0 == PAGE_SIZE, 1 == LARGE_PAGE
        };
        PVOID Va;
        ULONG_PTR VaLong;
    } u1;
} KTB_FLUSH_VA, *PKTB_FLUSH_VA;

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(HIGH_LEVEL)
VOID
KeSweepLocalCaches (
    VOID
    );

#if !defined(XBOX_SYSTEMOS)

VOID
KeWriteProtectPAT (
    _In_ BOOLEAN DisableDirtyLineAllocation
    );

#endif

VOID
KeStallWhileFrozen (
    _In_ ULONG MicroSeconds
    );


#define WIN32K_SERVICE_INDEX 1

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
KeAddSystemServiceTable (
    _In_ PULONG_PTR Base,
    _In_opt_ PULONG Count,
    _In_ ULONG Limit,
    _In_ PUCHAR Number,
    _In_ ULONG Index
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
KeRemoveSystemServiceTable (
    _In_ ULONG Index
    );


#if !defined(_AMD64_) && !defined(_ARM64_)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeQuerySystemTime (
    _Out_ PLARGE_INTEGER CurrentTime
    );
#endif

#endif // !_AMD64_

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
VOID
KeQuerySystemTimePrecise (
    _Out_ PLARGE_INTEGER CurrentTime
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_same_
ULONG64
KeQueryInterruptTimePrecise (
    _Out_ PULONG64 QpcTimeStamp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
KeQueryTimeIncrement (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
ULONGLONG
KeQueryUnbiasedInterruptTime (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
ULONG
KeGetRecommendedSharedDataAlignment (
    VOID
    );
#endif

// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K) && defined(SINGLE_GROUP_LEGACY_API)
NTKERNELAPI
KAFFINITY
KeQueryActiveProcessors (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA) && defined(SINGLE_GROUP_LEGACY_API)
NTKERNELAPI
ULONG
KeQueryActiveProcessorCount (
    _Out_opt_ PKAFFINITY ActiveProcessors
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
ULONG
KeQueryActiveProcessorCountEx (
    _In_ USHORT GroupNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(SINGLE_GROUP_LEGACY_API)
NTKERNELAPI
ULONG
KeQueryMaximumProcessorCount (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
ULONG
KeQueryMaximumProcessorCountEx (
    _In_ USHORT GroupNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
USHORT
KeQueryActiveGroupCount (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
USHORT
KeQueryMaximumGroupCount (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
KAFFINITY
KeQueryGroupAffinity (
    _In_ USHORT GroupNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
ULONG
KeGetCurrentProcessorNumberEx (
    _Out_opt_ PPROCESSOR_NUMBER ProcNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
KeQueryNodeActiveAffinity (
    _In_ USHORT NodeNumber,
    _Out_opt_ PGROUP_AFFINITY Affinity,
    _Out_opt_ PUSHORT Count
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
USHORT
KeQueryNodeMaximumProcessorCount (
    _In_ USHORT NodeNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
USHORT
KeQueryHighestNodeNumber (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
USHORT
KeGetCurrentNodeNumber (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
_When_(_Old_(*Length) == 0, _Post_satisfies_(return < 0))
NTKERNELAPI
NTSTATUS
KeQueryLogicalProcessorRelationship (
    _In_opt_ PPROCESSOR_NUMBER ProcessorNumber,
    _In_ LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
    _Out_writes_bytes_opt_(*Length) PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Information,
    _Always_(_Inout_) PULONG Length
    );
#endif

_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
LOGICAL
KeShouldYieldProcessor (
    VOID
    );

// end_ntddk end_wdm

NTKERNELAPI
USHORT
KeGetProcessorNodeNumber (
    _In_ PKPRCB Prcb
    );

// begin_nthal

//
// Extended affinity object.
//

NTKERNELAPI
ULONG
KeQueryActiveProcessorAffinity  (
    _Out_ PKAFFINITY_EX Affinity
    );

VOID
KeInitializeAffinityEx (
    _Out_ PKAFFINITY_EX Affinity
    );

VOID
KeAddProcessorAffinityEx (
    _Inout_ PKAFFINITY_EX Affinity,
    _In_ ULONG ProcIndex
    );

VOID
KeRemoveProcessorAffinityEx (
    _Inout_ PKAFFINITY_EX Affinity,
    _In_ ULONG ProcIndex
    );

LOGICAL
KeCheckProcessorAffinityEx (
    _In_ PKAFFINITY_EX Affinity,
    _In_ ULONG ProcIndex
    );

VOID
KeAddGroupAffinityEx (
    _Inout_ PKAFFINITY_EX Affinity,
    _In_ USHORT GroupNumber,
    _In_ KAFFINITY ProcessorMask
    );

VOID
KeRemoveGroupAffinityEx (
    _Inout_ PKAFFINITY_EX Affinity,
    _In_ USHORT GroupNumber,
    _In_ KAFFINITY ProcessorMask
    );

LOGICAL
KeIsEmptyAffinityEx (
    _In_ PKAFFINITY_EX Affinity
    );

LOGICAL
KeIsEqualAffinityEx (
    _In_ PKAFFINITY_EX Affinity1,
    _In_ PKAFFINITY_EX Affinity2
    );

LOGICAL
KeAndAffinityEx (
    _In_ PKAFFINITY_EX Affinity1,
    _In_ PKAFFINITY_EX Affinity2,
    _Out_opt_ PKAFFINITY_EX Result
    );

LOGICAL
KeAndGroupAffinityEx (
    _In_ PKAFFINITY_EX Affinity,
    _In_ PGROUP_AFFINITY GroupAffinity,
    _Out_opt_ PGROUP_AFFINITY Result
    );

LOGICAL
KeOrAffinityEx (
    _In_ PKAFFINITY_EX Affinity1,
    _In_ PKAFFINITY_EX Affinity2,
    _Out_opt_ PKAFFINITY_EX Result
    );

VOID
KeComplementAffinityEx (
    _Out_ PKAFFINITY_EX Result,
    _In_ PKAFFINITY_EX Affinity
    );

LOGICAL
KeSubtractAffinityEx (
    _In_ PKAFFINITY_EX Affinity1,
    _In_ PKAFFINITY_EX Affinity2,
    _Out_opt_ PKAFFINITY_EX Result
    );

LOGICAL
KeIsSubsetAffinityEx (
    _In_ PKAFFINITY_EX Affinity1,
    _In_ PKAFFINITY_EX Affinity2
    );

ULONG
KeCountSetBitsAffinityEx (
    _In_ PKAFFINITY_EX Affinity
    );

ULONG
KeFindFirstSetLeftAffinityEx (
    _In_ PKAFFINITY_EX Affinity
    );

ULONG
KeFindFirstSetRightAffinityEx (
    _In_ PKAFFINITY_EX Affinity
    );

VOID
KeInitializeInterlockedAffinityEx (
    _Out_ PKAFFINITY_EX Affinity
    );

LOGICAL
KeInterlockedSetProcessorAffinityEx (
    _Inout_ PKAFFINITY_EX Affinity,
    _In_ ULONG ProcIndex
    );

LOGICAL
KeInterlockedClearProcessorAffinityEx (
    _Inout_ PKAFFINITY_EX Affinity,
    _In_ ULONG ProcIndex
    );

VOID
KeCopyAffinityEx (
    _Out_ PKAFFINITY_EX Dest,
    _In_ PKAFFINITY_EX Source
    );

KAFFINITY
KeQueryGroupAffinityEx (
    _In_ PKAFFINITY_EX Affinity,
    _In_ USHORT GroupNumber
    );

NTSTATUS
KeFirstGroupAffinityEx (
    _Out_ PGROUP_AFFINITY GroupAffinity,
    _In_ PKAFFINITY_EX Affinity
    );

LOGICAL
KeIsSingleGroupAffinityEx (
    _In_ PKAFFINITY_EX Affinity,
    _Out_opt_ PUSHORT Group
    );

VOID
KeInitializeEnumerationContext (
    _Out_ PKAFFINITY_ENUMERATION_CONTEXT Context,
    _In_ PKAFFINITY_EX Affinity
    );

VOID
KeInitializeEnumerationContextFromGroup (
    _Out_ PKAFFINITY_ENUMERATION_CONTEXT Context,
    _In_ PGROUP_AFFINITY GroupAffinity
    );

VOID
KeInitializeEnumerationContextFromAffinity (
    _Out_ PKAFFINITY_ENUMERATION_CONTEXT Context,
    _In_ USHORT Group,
    _In_ KAFFINITY Affinity
    );


NTSTATUS
KeEnumerateNextProcessor (
    _Out_ PULONG ProcIndex,
    _Inout_ PKAFFINITY_ENUMERATION_CONTEXT Context
    );

VOID
KeProcessorGroupAffinity (
    _Out_ PGROUP_AFFINITY GroupAffinity,
    _In_ ULONG ProcIndex
    );

VOID
KeAddProcessorGroupAffinity (
    _Inout_ PGROUP_AFFINITY GroupAffinity,
    _In_ ULONG ProcIndex
    );

VOID
KeRemoveProcessorGroupAffinity (
    _Inout_ PGROUP_AFFINITY GroupAffinity,
    _In_ ULONG ProcIndex
    );

LOGICAL
KeCheckProcessorGroupAffinity (
    _In_ PGROUP_AFFINITY GroupAffinity,
    _In_ ULONG ProcIndex
    );

ULONG
KeCountSetBitsGroupAffinity (
    _In_ PGROUP_AFFINITY GroupAffinity
    );

ULONG
KeFindFirstSetLeftGroupAffinity (
    _In_ PGROUP_AFFINITY GroupAffinity
    );

ULONG
KeFindFirstSetRightGroupAffinity (
    _In_ PGROUP_AFFINITY GroupAffinity
    );

//
// Support for dispatching a secondary interrupt (i.e., interrupt generated
// behind a secondary interrupt controller).
//
// N.B. This is just exposed to the HAL and not to device drivers.
//

#define SECONDARY_INTERRUPT_FLAGS_NONE (0x0)

typedef enum _KINTERRUPT_DISPATCH_STATUS {

    //
    // No ISR was invoked.  Possible causes:
    //
    // 1. There are no KINTERRUPT objects attached to the specified IDT vector.
    // 2. All KINTERRUPT objects for the vector are masked.
    // 3. An error.
    //

    IsrNotDispatched = 0,

    //
    // No ISR was synchronously invoked.  ISR(s) for this vector may be invoked
    // in an asynchronous work item (e.g. passive-level ISR when the calling
    // IRQL is too high).
    //
    // N.B. The asynchronous ISR invocation may occur before or after this
    //      status is returned.
    //

    IsrDispatchDeferred = 1,

    //
    // At least one ISR was synchronously invoked.  Note that other ISR(s) for
    // the vector may be invoked in an asynchronous work item.
    //

    IsrDispatched = 2
} KINTERRUPT_DISPATCH_STATUS, *PKINTERRUPT_DISPATCH_STATUS;

BOOLEAN
KeDispatchSecondaryInterrupt (
    _In_ ULONG Vector,
    _In_ ULONG Flags,
    __out_opt PKINTERRUPT_DISPATCH_STATUS DispatchStatus
    );

NTSTATUS
KeInitializeSecondaryInterruptServices (
    _In_ PVOID SecondaryIcExports
    );

//
// Define the firmware routine types
//

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalPowerDownRoutine,
    HalRestartRoutine,
    HalRebootRoutine,
    HalInteractiveModeRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;


_IRQL_requires_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
KeUserModeCallback (
    _In_ ULONG ApiNumber,
    _In_reads_bytes_(InputLength) PVOID InputBuffer,
    _In_ ULONG InputLength,
    _Outptr_result_bytebuffer_maybenull_(*OutputLength) PVOID *OutputBuffer,
    _Out_ PULONG OutputLength
    );


#if defined(_X86_) || defined(_ARM_)

extern DECLSPEC_CACHEALIGN volatile KSYSTEM_TIME KeTickCount;

#endif

// begin_ntminiport begin_wudfwdm
// begin_ntoshvp

typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmNonCachedUnordered,       // IA64
    MmUSWCCached,
    MmMaximumCacheType,
    MmNotMapped = -1
} MEMORY_CACHING_TYPE;

// end_ntoshvp

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
KeAreAllApcsDisabled (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeInitializeGuardedMutex (
    _Out_ PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Acquires_lock_(_Global_critical_region_)
_Requires_lock_not_held_(*Mutex)
_Acquires_lock_(*Mutex)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeAcquireGuardedMutex (
    _Inout_ PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Releases_lock_(_Global_critical_region_)
_Requires_lock_held_(*Mutex)
_Releases_lock_(*Mutex)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeReleaseGuardedMutex (
    _Inout_ PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Must_inspect_result_
_Success_(return != FALSE)
_IRQL_requires_max_(APC_LEVEL)
_Post_satisfies_(return == 1 || return == 0)
NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireGuardedMutex (
    _When_ (return, _Acquires_exclusive_lock_(*_Curr_)) _Acquires_lock_(_Global_critical_region_)
    _Inout_ PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Requires_lock_not_held_(*FastMutex)
_Acquires_lock_(*FastMutex)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeAcquireGuardedMutexUnsafe (
    _Inout_ PKGUARDED_MUTEX FastMutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Requires_lock_held_(*FastMutex)
_Releases_lock_(*FastMutex)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FASTCALL
KeReleaseGuardedMutexUnsafe (
    _Inout_ PKGUARDED_MUTEX FastMutex
    );
#endif

// end_wdm begin_nthal

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define INVALID_APIC_ID ((ULONG)-1)
#define INVALID_NODE_NUMBER ((USHORT)-1)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
KeStartDynamicProcessor (
    _In_ ULONG ProcessorId,
    _In_ ULONG ApicId,
    _In_ USHORT NsNodeNumber,
    _Out_ PULONG NtNumber
    );

#endif

// begin_wdm end_nthal

//
// Define dynamic processor add types.
//

typedef enum {
    KeProcessorAddStartNotify = 0,
    KeProcessorAddCompleteNotify,
    KeProcessorAddFailureNotify
} KE_PROCESSOR_CHANGE_NOTIFY_STATE;

typedef struct _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT {
    KE_PROCESSOR_CHANGE_NOTIFY_STATE State;
    ULONG NtNumber;
    NTSTATUS Status;

#if (NTDDI_VERSION >= NTDDI_WIN7)

    PROCESSOR_NUMBER ProcNumber;

#endif

// end_wdm
    ULONG ProcessorId;
// begin_wdm

} KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT, *PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;

typedef
_IRQL_requires_same_
_Function_class_(PROCESSOR_CALLBACK_FUNCTION)
VOID
PROCESSOR_CALLBACK_FUNCTION (
    _In_ PVOID CallbackContext,
    _In_ PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT ChangeContext,
    _Inout_ PNTSTATUS OperationStatus
    );

typedef PROCESSOR_CALLBACK_FUNCTION *PPROCESSOR_CALLBACK_FUNCTION;

#define KE_PROCESSOR_CHANGE_ADD_EXISTING 1

#if (NTDDI_VERSION >= NTDDI_WS08)
_IRQL_requires_max_(APC_LEVEL)
PVOID
KeRegisterProcessorChangeCallback (
    _In_ PPROCESSOR_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID CallbackContext,
    _In_ ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS08)
_IRQL_requires_max_(APC_LEVEL)
VOID
KeDeregisterProcessorChangeCallback (
    _In_ PVOID CallbackHandle
    );
#endif

// end_wdm

_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
KeAlertThread (
    _Inout_ PKTHREAD Thread,
    _In_ KPROCESSOR_MODE ProcessorMode
    );


#define INVALID_PROCESSOR_INDEX     0xffffffff

NTSTATUS
KeGetProcessorNumberFromIndex (
    _In_ ULONG ProcIndex,
    _Out_ PPROCESSOR_NUMBER ProcNumber
    );

ULONG
KeGetProcessorIndexFromNumber (
    _In_ PPROCESSOR_NUMBER ProcNumber
    );


typedef struct _XSTATE_SAVE {

#if defined(_AMD64_)

    struct _XSTATE_SAVE* Prev;
    struct _KTHREAD* Thread;
    UCHAR Level;
    XSTATE_CONTEXT XStateContext;

#elif defined(_ARM_) || defined(_ARM64_)

    ULONG Dummy;

#elif defined(_X86_)

    union {
        struct {
            LONG64 Reserved1;
            ULONG Reserved2;

            struct _XSTATE_SAVE* Prev;

            PXSAVE_AREA Reserved3;

            struct _KTHREAD* Thread;

            PVOID Reserved4;

            UCHAR Level;
        };

        XSTATE_CONTEXT XStateContext;
    };

#endif
} XSTATE_SAVE, *PXSTATE_SAVE;

#if (NTDDI_VERSION >= NTDDI_WIN7)

_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_When_(return>=0, _Kernel_float_saved_)
_At_(*XStateSave, _When_(return>=0, _Kernel_acquires_resource_(FloatState)))
NTKERNELAPI
NTSTATUS
NTAPI
KeSaveExtendedProcessorState (
    _In_ ULONG64 Mask,
    _Out_ PXSTATE_SAVE XStateSave
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Kernel_float_restored_
_At_(*XStateSave, _Kernel_requires_resource_held_(FloatState) _Kernel_releases_resource_(FloatState))
NTKERNELAPI
VOID
NTAPI
KeRestoreExtendedProcessorState (
    _In_ PXSTATE_SAVE XStateSave
    );

#endif


VOID
KeUpdateThreadTag (
    __in PKTHREAD Thread,
    __in KTHREAD_TAG Tag
    );


typedef struct _EXT_SET_PARAMETERS_V0 {
    ULONG Version;
    ULONG Reserved;
    LONGLONG NoWakeTolerance;
} EXT_SET_PARAMETERS, *PEXT_SET_PARAMETERS;

typedef EXT_SET_PARAMETERS KT2_SET_PARAMETERS, *PKT2_SET_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
FORCEINLINE
VOID
KeInitializeTimer2SetParameters (
    _Out_ PKT2_SET_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine initializes extended initialize timer parameters.

    N.B. This routine is inlined so that a driver that is built
         to use one version of the parameters structure
         will always set the structure's version parameter to that version.
         A downlevel driver will set the version parameter to the
         appropriate, downlevel version.

Arguments:

    Parameters - Supplies the parameters to be initialized.

Return Value:

    None.

--*/

{

    RtlZeroMemory(Parameters, sizeof(*Parameters));

    NT_ASSERT(Parameters->Version == 0);

    return;
}
#endif


#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

NTSTATUS
KeConvertAuxiliaryCounterToPerformanceCounter (
    _In_ ULONG64 AuxiliaryCounterValue,
    _Out_ PULONG64 PerformanceCounterValue,
    _Out_opt_ PULONG64 ConversionError
    );

NTSTATUS
KeConvertPerformanceCounterToAuxiliaryCounter (
    _In_ ULONG64 PerformanceCounterValue,
    _Out_ PULONG64 AuxiliaryCounterValue,
    _Out_opt_ PULONG64 ConversionError
    );

NTSTATUS
KeQueryAuxiliaryCounterFrequency (
    _Out_ PULONG64 AuxiliaryCounterFrequency
    );

#endif

// end_wdm

VOID
KeReportCacheIncoherentDevice (
    VOID
    );

//
// Define simple address range structure.
//

typedef struct _KADDRESS_RANGE {
    _Field_size_bytes_(Size) PVOID Address;
    SIZE_T Size;
} KADDRESS_RANGE, *PKADDRESS_RANGE;

typedef struct _KADDRESS_RANGE_DESCRIPTOR {
    _Field_size_(AddressRangeCount) CONST KADDRESS_RANGE *AddressRanges;
    SIZE_T AddressRangeCount;
} KADDRESS_RANGE_DESCRIPTOR, *PKADDRESS_RANGE_DESCRIPTOR;


typedef struct _KWAIT_CHAIN {
    SINGLE_LIST_ENTRY Head;
} KWAIT_CHAIN, *PKWAIT_CHAIN;



#ifndef _TRACEHANDLE_DEFINED
#define _TRACEHANDLE_DEFINED
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;
#endif

//
// Trace Provider APIs
//

#ifdef RUN_WPP

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
NTSTATUS
WmiTraceMessage (
    _In_ TRACEHANDLE LoggerHandle,
    _In_ ULONG MessageFlags,
    _In_ LPCGUID MessageGuid,
    _In_ USHORT MessageNumber,
    ...
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
NTSTATUS
WmiTraceMessageVa (
    _In_ TRACEHANDLE LoggerHandle,
    _In_ ULONG MessageFlags,
    _In_ LPCGUID MessageGuid,
    _In_ USHORT MessageNumber,
    _In_ va_list MessageArgList
    );
#endif

#endif // #ifdef RUN_WPP

#ifndef TRACE_INFORMATION_CLASS_DEFINE

typedef struct _ETW_TRACE_SESSION_SETTINGS {
    ULONG Version;
    ULONG BufferSize;
    ULONG MinimumBuffers;
    ULONG MaximumBuffers;
    ULONG LoggerMode;
    ULONG FlushTimer;
    ULONG FlushThreshold;
    ULONG ClockType;
} ETW_TRACE_SESSION_SETTINGS, *PETW_TRACE_SESSION_SETTINGS;

typedef enum _TRACE_INFORMATION_CLASS {
    TraceIdClass,
    TraceHandleClass,
    TraceEnableFlagsClass,
    TraceEnableLevelClass,
    GlobalLoggerHandleClass,
    EventLoggerHandleClass,
    AllLoggerHandlesClass,
    TraceHandleByNameClass,
    LoggerEventsLostClass,
    TraceSessionSettingsClass,
    LoggerEventsLoggedClass,
    DiskIoNotifyRoutinesClass,
    TraceInformationClassReserved1,
// end_wdm
    AllPossibleNotifyRoutinesClass = TraceInformationClassReserved1,
// begin_wdm
    FltIoNotifyRoutinesClass,
    TraceInformationClassReserved2, 
    WdfNotifyRoutinesClass,
    MaxTraceInformationClass
} TRACE_INFORMATION_CLASS;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
WmiQueryTraceInformation (
    _In_ TRACE_INFORMATION_CLASS TraceInformationClass,
    _Out_writes_bytes_(TraceInformationLength) PVOID TraceInformation,
    _In_ ULONG TraceInformationLength,
    _Out_opt_ PULONG RequiredLength,
    _In_opt_ PVOID Buffer
    );
#endif 

#define TRACE_INFORMATION_CLASS_DEFINE
#endif // TRACE_INFOPRMATION_CLASS_DEFINE


#ifndef _ETW_KM_
#define _ETW_KM_
#endif

#include <evntprov.h>


//
// Optional callback function that users provide.
//

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID
NTAPI 
ETWENABLECALLBACK (
    _In_ LPCGUID SourceId,
    _In_ ULONG ControlCode,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ PEVENT_FILTER_DESCRIPTOR FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

typedef ETWENABLECALLBACK *PETWENABLECALLBACK;

//
// Kernel Mode Registration APIs.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EtwRegister (
    _In_ LPCGUID ProviderId,
    _In_opt_ PETWENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EtwUnregister (
    _In_ REGHANDLE RegHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_THRESHOLD)
NTKERNELAPI
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EtwSetInformation(
    _In_ REGHANDLE RegHandle,
    _In_ EVENT_INFO_CLASS InformationClass,
    _In_reads_bytes_opt_(InformationLength) PVOID EventInformation,
    _In_ ULONG InformationLength
    );
#endif

//
// Kernel Mode Control (Is Enabled) APIs
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
BOOLEAN
EtwEventEnabled (
    _In_ REGHANDLE RegHandle,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
BOOLEAN
EtwProviderEnabled (
    _In_ REGHANDLE RegHandle,
    _In_ UCHAR Level,
    _In_ ULONGLONG Keyword
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_When_(ControlCode==EVENT_ACTIVITY_CTRL_CREATE_ID, _IRQL_requires_max_(HIGH_LEVEL) _At_(ActivityId, _Out_))
_When_(ControlCode==EVENT_ACTIVITY_CTRL_GET_ID, _IRQL_requires_max_(APC_LEVEL) _At_(ActivityId, _Out_))
_When_(ControlCode==EVENT_ACTIVITY_CTRL_SET_ID, _IRQL_requires_max_(APC_LEVEL) _At_(ActivityId, _In_))
_When_(ControlCode==EVENT_ACTIVITY_CTRL_GET_SET_ID, _IRQL_requires_max_(APC_LEVEL) _At_(ActivityId, _Inout_))
_When_(ControlCode==EVENT_ACTIVITY_CTRL_CREATE_SET_ID, _IRQL_requires_max_(APC_LEVEL) _At_(ActivityId, _Out_))
NTSTATUS
EtwActivityIdControl (
    _In_ ULONG ControlCode,
    _Inout_updates_bytes_(sizeof(GUID)) LPGUID ActivityId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
_IRQL_requires_max_(DISPATCH_LEVEL)
NTSTATUS
EtwActivityIdControlKernel (
    _In_ ULONG ControlCode,
    _Inout_ LPCGUID *ActivityId
    );
#endif

//
// Kernel Mode Writing (Publishing/Logging) APIs
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
NTSTATUS
EtwWrite (
    _In_ REGHANDLE RegHandle,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_ ULONG UserDataCount,
    _In_reads_opt_(UserDataCount) PEVENT_DATA_DESCRIPTOR  UserData
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
NTSTATUS
EtwWriteTransfer (
    _In_ REGHANDLE RegHandle,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_opt_ LPCGUID RelatedActivityId,
    _In_ ULONG UserDataCount,
    _In_reads_opt_(UserDataCount) PEVENT_DATA_DESCRIPTOR UserData
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
NTSTATUS
EtwWriteString (
    _In_ REGHANDLE RegHandle,
    _In_ UCHAR Level,
    _In_ ULONGLONG Keyword,
    _In_opt_ LPCGUID ActivityId,
    _In_ PCWSTR String
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
NTSTATUS
EtwWriteEx (
    _In_ REGHANDLE RegHandle,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor,
    _In_ ULONG64 Filter,
    _In_ ULONG Flags,
    _In_opt_ LPCGUID ActivityId,
    _In_opt_ LPCGUID RelatedActivityId,
    _In_ ULONG UserDataCount,
    _In_reads_opt_(UserDataCount) PEVENT_DATA_DESCRIPTOR UserData
    );
#endif

// end_wdm 

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EtwEnableTrace (
    _In_ LPCGUID ProviderId,
    _In_opt_ LPCGUID SourceId,
    _In_ TRACEHANDLE TraceHandle,
    _In_ ULONG ControlCode,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_ ULONG EnableProperty
    );
#endif 

//
// Security Provider Logging API.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EtwWriteKMSecurityEvent (
    _In_ PCEVENT_DESCRIPTOR EventDescriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_ ULONG UserDataCount,
    _In_opt_ PEVENT_DATA_DESCRIPTOR UserData
    );
#endif 

_IRQL_requires_same_
typedef
VOID
(NTAPI *PETW_CLASSIC_CALLBACK)(
    _In_ LPCGUID Guid,
    _In_ UCHAR ControlCode,
    _In_ PVOID EnableContext, 
    _In_opt_ PVOID CallbackContext
    );

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EtwRegisterClassicProvider (
    _In_ LPCGUID ProviderId,
    _In_ ULONG Type,
    _In_ PETW_CLASSIC_CALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle
    );
#endif    

_IRQL_requires_same_
typedef
VOID
(NTAPI *PETW_BUFFER_COMPLETION_ROUTINE)(
    _In_ NTSTATUS Status,
    _In_ PVOID Buffer,
    _In_opt_ PVOID Context
    );

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
_IRQL_requires_max_(HIGH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTSTATUS
EtwSendTraceBuffer (
    _In_ ULONGLONG LoggerHandle, 
    _In_ PVOID Buffer,
    _In_ ULONG EventsLost,
    _In_ PETW_BUFFER_COMPLETION_ROUTINE CompletionRoutine,
    _In_opt_ PVOID CompletionContext
    );
#endif


//
// Pool Allocation routines (in pool.c)
//
typedef _Enum_is_bitflag_ enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,

    //
    // Define base types for NonPaged (versus Paged) pool, for use in cracking
    // the underlying pool type.
    //

    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,

    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32,

} _Enum_is_bitflag_ POOL_TYPE;

#define POOL_COLD_ALLOCATION 256     // Note this cannot encode into the header.

#define POOL_NX_ALLOCATION   512     // Note this cannot encode into the header.

// end_wudfwdm

//
// POOL_NX_OPTIN_AUTO makes non-paged pool allocations non-executable by
// default without dynamically checking if this is supported by the operating
// system.  This opt-in method should only be used by drivers that are targeted
// to run on operating system versions that are known to support NX non-paged
// pool allocations.
//
// POOL_NX_OPTIN allows device drivers to dynamically opt-in to making
// non-paged pool allocations non-executable by default based on whether or not
// this is supported by the version of the operating system.  Device drivers
// must call ExInitializeDriverRuntime (DrvRtPoolNxOptIn) during driver
// initialization to dynamically opt-in.  This opt-in method should be used by
// drivers that are designed to run on versions of Windows that may or may not
// support NX non-paged pool allocations.
//
// In both cases, NonPagedPoolExecute should be used by drivers that need to
// explicitly allocate executable memory from the non-paged pool.
//
// POOL_NX_OPTOUT may be used to locally override the pool opt-in setting for a
// single source file.  It is intended to be useful as an aid for porting large
// projects to NX pool, where most source files do not contain code that needs
// to allocate executable NonPaged pool (and thus it may be convenient to set
// the opt-in define globally).  In this case, if there existed a source file
// that needed to manually control executable versus non-executable pool opt-in
// then that source file could define POOL_NX_OPTOUT to 0 in order to override
// the global default.
//

#if (!defined(_X86_) && !defined(_AMD64_) && !defined(_NTOS_)) || defined(_PREFAST_)

//
// New platforms default to NonPagedPoolNx unless explicitly overridden.  The
// exemption for _NTOS_ is there to allow NonPagedPool to be referenced when
// cracking pool types.  This is henceforth the default for platforms that
// require a recompilation.
//
// N.B.  The remapping is carefully performed with a preprocessor define such
//       that code which is NonPagedPoolNx-aware and which needs to crack the
//       pool type may undefine the symbol.
//

#undef POOL_NX_OPTIN

#define POOL_NX_OPTIN_AUTO 1

#endif // !defined(_X86_) && !defined(_AMD64_) && !defined(_NTOSP_)

#if !POOL_NX_OPTOUT

#if POOL_NX_OPTIN_AUTO
#define NonPagedPool NonPagedPoolNx
#define NonPagedPoolCacheAligned NonPagedPoolNxCacheAligned
#elif POOL_NX_OPTIN
DECLSPEC_SELECTANY POOL_TYPE ExDefaultNonPagedPoolType = NonPagedPoolExecute;
DECLSPEC_SELECTANY ULONG ExDefaultMdlProtection = 0;
#define NonPagedPool ExDefaultNonPagedPoolType
#define NonPagedPoolCacheAligned ((POOL_TYPE)(ExDefaultNonPagedPoolType + 4))
#endif // POOL_NX_OPTIN_AUTO

#endif // !POOL_NX_OPTOUT

// end_wdm end_ntndis
// begin_ntosp

//
// The following two definitions control the raising of exceptions on quota
// and allocation failures.
//

#define POOL_MM_ALLOCATION 0x80000000     // Note this cannot encode into the header.


#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE 8
#define POOL_RAISE_IF_ALLOCATION_FAILURE 16

#if (NTDDI_VERSION >= NTDDI_WIN2K)

DECLSPEC_DEPRECATED_DDK                     // Use ExAllocatePoolWithTag
__drv_preferredFunction("ExAllocatePoolWithTag",
                        "No tag interferes with debugging.")
__drv_allocatesMem(Mem)
_When_((PoolType & PagedPool) != 0, _IRQL_requires_max_(APC_LEVEL))
_When_((PoolType & PagedPool) == 0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_((PoolType & NonPagedPoolMustSucceed) != 0,
       __drv_reportError("Must succeed pool allocations are forbidden. "
                         "Allocation failures cause a system crash"))
_When_((PoolType & (NonPagedPoolMustSucceed |
                    POOL_RAISE_IF_ALLOCATION_FAILURE)) == 0,
       _Post_maybenull_ _Must_inspect_result_)
_When_((PoolType & (NonPagedPoolMustSucceed |
                    POOL_RAISE_IF_ALLOCATION_FAILURE)) != 0,
       _Post_notnull_)
_Post_writable_byte_size_(NumberOfBytes)
NTKERNELAPI
PVOID
ExAllocatePool (
    __drv_strictTypeMatch(__drv_typeExpr) _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

DECLSPEC_DEPRECATED_DDK                     // Use ExAllocatePoolWithQuotaTag
__drv_preferredFunction("ExAllocatePoolWithQuotaTag",
                        "No tag interferes with debugging.")
__drv_allocatesMem(Mem)
_When_((PoolType & PagedPool) != 0, _IRQL_requires_max_(APC_LEVEL))
_When_((PoolType & PagedPool) == 0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_((PoolType & NonPagedPoolMustSucceed) != 0,
       __drv_reportError("Must succeed pool allocations are forbidden. "
                         "Allocation failures cause a system crash"))
_When_((PoolType & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) != 0,
       _Post_maybenull_ _Must_inspect_result_)
_When_((PoolType & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) == 0, _Post_notnull_)
_Post_writable_byte_size_(NumberOfBytes)
NTKERNELAPI
PVOID
ExAllocatePoolWithQuota (
    __drv_strictTypeMatch(__drv_typeExpr) _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

__drv_allocatesMem(Mem)
_When_((PoolType & PagedPool) != 0, _IRQL_requires_max_(APC_LEVEL))
_When_((PoolType & PagedPool) == 0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_((PoolType & NonPagedPoolMustSucceed) != 0,
       __drv_reportError("Must succeed pool allocations are forbidden. "
                         "Allocation failures cause a system crash"))
_When_((PoolType & (NonPagedPoolMustSucceed |
                    POOL_RAISE_IF_ALLOCATION_FAILURE)) == 0,
       _Post_maybenull_ _Must_inspect_result_)
_When_((PoolType & (NonPagedPoolMustSucceed |
                    POOL_RAISE_IF_ALLOCATION_FAILURE)) != 0,
       _Post_notnull_)
_Post_writable_byte_size_(NumberOfBytes)
NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag (
    _In_ __drv_strictTypeMatch(__drv_typeExpr) POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Tag
    );

#endif

//
// _EX_POOL_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPoolPriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//
// SpecialPool can be specified to bound the allocation at a page end (or
// beginning).  This should only be done on systems being debugged as the
// memory cost is expensive.
//
// N.B.  These values are very carefully chosen so that the pool allocation
//       code can quickly crack the priority request.
//

typedef _Enum_is_bitflag_ enum _EX_POOL_PRIORITY {
    LowPoolPriority,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41
} EX_POOL_PRIORITY;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

__drv_allocatesMem(Mem)
_When_((PoolType & PagedPool) != 0, _IRQL_requires_max_(APC_LEVEL))
_When_((PoolType & PagedPool) == 0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_((PoolType & NonPagedPoolMustSucceed) != 0,
       __drv_reportError("Must succeed pool allocations are forbidden. "
                         "Allocation failures cause a system crash"))
_When_((PoolType & (NonPagedPoolMustSucceed |
                    POOL_RAISE_IF_ALLOCATION_FAILURE)) == 0,
       _Post_maybenull_ _Must_inspect_result_)
_When_((PoolType & (NonPagedPoolMustSucceed |
                    POOL_RAISE_IF_ALLOCATION_FAILURE)) != 0,
       _Post_notnull_)
_Post_writable_byte_size_(NumberOfBytes)
NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTagPriority (
    _In_ __drv_strictTypeMatch(__drv_typeCond) POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Tag,
    _In_ __drv_strictTypeMatch(__drv_typeExpr) EX_POOL_PRIORITY Priority
    );

#endif

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif //POOL_TAGGING

#if (NTDDI_VERSION >= NTDDI_WIN2K)

__drv_allocatesMem(Mem)
_When_((PoolType & PagedPool) != 0, _IRQL_requires_max_(APC_LEVEL))
_When_((PoolType & PagedPool) == 0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_((PoolType & NonPagedPoolMustSucceed) != 0,
       __drv_reportError("Must succeed pool allocations are forbidden. "
                         "Allocation failures cause a system crash"))
_When_((PoolType & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) != 0,
       _Post_maybenull_ _Must_inspect_result_)
_When_((PoolType & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) == 0, _Post_notnull_)
_Post_writable_byte_size_(NumberOfBytes)
NTKERNELAPI
PVOID
ExAllocatePoolWithQuotaTag (
    _In_ __drv_strictTypeMatch(__drv_typeExpr) POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Tag
    );

#endif

#ifndef POOL_TAGGING
#define ExAllocatePoolWithQuotaTag(a,b,c) ExAllocatePoolWithQuota(a,b)
#endif //POOL_TAGGING

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
NTAPI
ExFreePool (
    _Pre_notnull_ __drv_freesMem(Mem) PVOID P
    );

#endif

// end_wdm
// begin_ntddk

#if defined(POOL_TAGGING)
#define ExFreePool(a) ExFreePoolWithTag (a,0)
#endif

//
// PROTECTED_POOL is deprecated, do not use.
//

#define PROTECTED_POOL 0x0

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExFreePoolWithTag (
    _Pre_notnull_ __drv_freesMem(Mem) PVOID P,
    _In_ ULONG Tag
    );

#endif

// end_wdm

#ifndef POOL_TAGGING
#define ExFreePoolWithTag(a,b) ExFreePool (a)
#endif //POOL_TAGGING


#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
SIZE_T
ExQueryPoolBlockSize (
    _In_ PVOID PoolBlock,
    _Out_ PBOOLEAN QuotaCharged
    );

#endif


//
// Routines to support fast mutexes.
//

#define FM_LOCK_BIT          0x1 // Actual lock bit, 1 = Unlocked, 0 = Locked
#define FM_LOCK_BIT_V        0x0 // Lock bit as a bit number

FORCEINLINE
VOID
ExInitializeFastMutex (
    _Out_ PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function initializes a fast mutex object.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex object.

Return Value:

    None.

--*/

{

    WriteRaw(&FastMutex->Count, FM_LOCK_BIT);
    FastMutex->Owner = NULL;
    FastMutex->Contention = 0;
    KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);
    return;
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutexUnsafe(
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PFAST_MUTEX FastMutex
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafe(
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PFAST_MUTEX FastMutex
    );

#endif

// end_wdm

_IRQL_requires_max_(APC_LEVEL)
_Acquires_lock_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExEnterCriticalRegionAndAcquireFastMutexUnsafe(
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PFAST_MUTEX FastMutex
    );

_IRQL_requires_max_(APC_LEVEL)
_Releases_lock_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PFAST_MUTEX FastMutex
    );

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_raises_(APC_LEVEL)
_IRQL_saves_global_(OldIrql, FastMutex)
NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutex (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PFAST_MUTEX FastMutex
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_(APC_LEVEL)
_IRQL_restores_global_(OldIrql, FastMutex)
NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutex (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PFAST_MUTEX FastMutex
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_Must_inspect_result_
_Success_(return!=FALSE)
_IRQL_raises_(APC_LEVEL)
_IRQL_saves_global_(OldIrql, FastMutex)
NTKERNELAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PFAST_MUTEX FastMutex
    );

#endif

// begin_ntndis
//

#if defined(_X86_)

#ifdef __cplusplus
extern "C" {
#endif

#define ExInterlockedAddLargeStatistic(Addend, Increment) \
    (VOID)_InterlockedAddLargeStatistic((PLONGLONG)&(Addend)->QuadPart, Increment)

long
_InterlockedAddLargeStatistic (
    _Inout_ __int64 volatile *Addend,
    _In_ long Increment
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(_InterlockedAddLargeStatistic)

#else

#define ExInterlockedAddLargeStatistic(Addend, Increment) \
    (VOID)InterlockedAddNoFence64(&(Addend)->QuadPart, Increment)

#endif

// end_ntndis

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    _Inout_ PLARGE_INTEGER Addend,
    _In_ LARGE_INTEGER Increment,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
ULONG
FASTCALL
ExInterlockedAddUlong (
    _Inout_ PULONG Addend,
    _In_ ULONG Increment,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif // NTDDI_VERSION >= NTDDI_WIN2K


#if defined(_AMD64_) || defined(_ARM_) || defined(_ARM64_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    InterlockedCompareExchange64(Destination, *(Exchange), *(Comperand))

#else

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExfInterlockedCompareExchange64(Destination, Exchange, Comperand)

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64 (
    _Inout_ _Interlocked_operand_ LONGLONG volatile *Destination,
    _In_ PLONGLONG ExChange,
    _In_ PLONGLONG Comperand
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY ListEntry,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PLIST_ENTRY ListEntry,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ __drv_aliasesMem PSINGLE_LIST_ENTRY ListEntry,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif


//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables AMD64, ARM, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
//

//
// (Ex)InitializeSListHead
//

#if !defined(_WINBASE_)

#if defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
VOID
InitializeSListHead (
    _Out_ PSLIST_HEADER SListHead
    );

#else // defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

//
// Since the following function will be compiled inline for user code, the
// initialization changes for x86 will only take effect if the user code is
// recompiled with this new header. For those binaries that are recompiled with
// this new code, it will not have to go through an extra step of header
// initialization on its first push or pop operation. Note that the SLIST code
// will still work perfectly even without the changes in this initialization
// function.
//

__inline
VOID
InitializeSListHead (
    _Out_ PSLIST_HEADER SListHead
    )

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

{

    //
    // Slist headers must be 16 byte aligned.
    //

#if defined(_WIN64)

    if (((ULONG_PTR)SListHead & 0xf) != 0) {
        RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    }

#endif

    RtlZeroMemory(SListHead, sizeof(SLIST_HEADER));

    return;
}

#endif // defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

#endif // !defined(_WINBASE_)

#define ExInitializeSListHead InitializeSListHead

//
// FirstEntrySList
//

NTKERNELAPI
PSLIST_ENTRY
FirstEntrySList (
    _In_ PSLIST_HEADER SListHead
    );

//
// (Ex)QueryDepthSList
//

#if !defined(_X86_)

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
USHORT
ExQueryDepthSList (
    _In_ PSLIST_HEADER SListHead
    );

#else // (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

__inline
USHORT
ExQueryDepthSList (
    _In_ PSLIST_HEADER SListHead
    )

/*++

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

{

#if defined(_WIN64)
    return (USHORT)(SListHead->Alignment & 0xffff);
#else
    return (USHORT)SListHead->Depth;
#endif
}

#endif // (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

#else // !defined(_X86_)

#define ExQueryDepthSList(_listhead_) (_listhead_)->Depth

#endif // !defined(_X86_)

#if !defined(_WINBASE_)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

//
// ExInterlockedPopEntrySList
// ExInterlockedPushEntrySList
// ExInterlockedFlushSList
//

#if !defined(_X86_)

#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)

#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#if !defined(_WINBASE_)

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#endif // !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    _Inout_ PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    _Inout_ PSLIST_HEADER ListHead,
    _Inout_ __drv_aliasesMem PSLIST_ENTRY ListEntry
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedFlushSList (
    _Inout_ PSLIST_HEADER ListHead
    );

#else // !defined(_X86_)

#if defined(_WIN2K_COMPAT_SLIST_USAGE)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    _Inout_ PSLIST_HEADER ListHead,
    _Inout_opt_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    _Inout_ PSLIST_HEADER ListHead,
    _Inout_ __drv_aliasesMem PSLIST_ENTRY ListEntry,
    _Inout_opt_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#else // defined(_WIN2K_COMPAT_SLIST_USAGE)

#define ExInterlockedPopEntrySList(ListHead, Lock) \
    InterlockedPopEntrySList(ListHead)

#define ExInterlockedPushEntrySList(ListHead, ListEntry, Lock) \
    InterlockedPushEntrySList(ListHead, ListEntry)

#endif // defined(_WIN2K_COMPAT_SLIST_USAGE)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedFlushSList (
    _Inout_ PSLIST_HEADER ListHead
    );

#if !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    _Inout_ PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    _Inout_ PSLIST_HEADER ListHead,
    _Inout_ __drv_aliasesMem PSLIST_ENTRY ListEntry
    );

#define InterlockedFlushSList(Head) \
    ExInterlockedFlushSList(Head)

#endif // !defined(_WINBASE_)

#endif // !defined(_X86_)


#define LOOKASIDE_MINIMUM_BLOCK_SIZE  (RTL_SIZEOF_THROUGH_FIELD (SLIST_ENTRY, Next))

//
// N.B. Note that this structure is not cache aligned to enable its use
//  in a larger containing structure.
//

typedef struct _LOOKASIDE_LIST_EX {
    GENERAL_LOOKASIDE_POOL L;
} LOOKASIDE_LIST_EX, *PLOOKASIDE_LIST_EX;

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define EX_LOOKASIDE_LIST_EX_FLAGS_RAISE_ON_FAIL    0x00000001UL
#define EX_LOOKASIDE_LIST_EX_FLAGS_FAIL_NO_RAISE    0x00000002UL

#define EX_MAXIMUM_LOOKASIDE_DEPTH_BASE     256     // Base maximum depth
#define EX_MAXIMUM_LOOKASIDE_DEPTH_LIMIT    1024    // Upper limit maximum depth

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
ExInitializeLookasideListEx (
    _Out_ PLOOKASIDE_LIST_EX Lookaside,
    _In_opt_ PALLOCATE_FUNCTION_EX Allocate,
    _In_opt_ PFREE_FUNCTION_EX Free,
    _In_ POOL_TYPE PoolType,
    _In_ ULONG Flags,
    _In_ SIZE_T Size,
    _In_ ULONG Tag,
    _In_ USHORT Depth
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExDeleteLookasideListEx (
    _Inout_ PLOOKASIDE_LIST_EX Lookaside
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExFlushLookasideListEx (
    _Inout_ PLOOKASIDE_LIST_EX Lookaside
    );

__drv_allocatesMem(Mem)
_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
FORCEINLINE
PVOID
#pragma warning(suppress: 28195) // memory is not always allocated here, sometimes we reuse an entry from the list
ExAllocateFromLookasideListEx (
    _Inout_ PLOOKASIDE_LIST_EX Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a LOOKASIDE_LIST_EX structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.AllocateEx)(Lookaside->L.Type,
                                          Lookaside->L.Size,
                                          Lookaside->L.Tag,
                                          Lookaside);
    }

    return Entry;
}

_IRQL_requires_max_(DISPATCH_LEVEL)
FORCEINLINE
VOID
ExFreeToLookasideListEx (
    _Inout_ PLOOKASIDE_LIST_EX Lookaside,
    _In_ __drv_freesMem(Entry) PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a LOOKASIDE_LIST_EX structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.FreeEx)(Entry, Lookaside);

    } else {
        InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);
    }

    return;
}

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct LOOKASIDE_ALIGN _NPAGED_LOOKASIDE_LIST {

    GENERAL_LOOKASIDE L;

#if defined(_X86_)

    KSPIN_LOCK Lock__ObsoleteButDoNotDelete;

#endif

} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    _Out_ PNPAGED_LOOKASIDE_LIST Lookaside,
    _In_opt_ PALLOCATE_FUNCTION Allocate,
    _In_opt_ PFREE_FUNCTION Free,
    _In_ ULONG Flags,
    _In_ SIZE_T Size,
    _In_ ULONG Tag,
    _In_ USHORT Depth
    );

#if !POOL_NX_OPTOUT && (POOL_NX_OPTIN || POOL_NX_OPTIN_AUTO)

//
// If NX Pool Opt-In is enabled, then ExInitializeNPagedLookasideList calls are
// remapped to go through the following forceinline.
//
// N.B.  Should NX Pool Opt-In be enabled, ExInitializeDriverRuntime(...) *MUST*
//       be invoked before any calls to ExInitializeNPagedLookasideList in
//       order for Opt-In to be correctly applied.
//

FORCEINLINE
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
ExInitializeNPagedLookasideList_NXPoolOptIn (
    _Out_ PNPAGED_LOOKASIDE_LIST Lookaside,
    _In_opt_ PALLOCATE_FUNCTION Allocate,
    _In_opt_ PFREE_FUNCTION Free,
    _In_ ULONG Flags,
    _In_ SIZE_T Size,
    _In_ ULONG Tag,
    _In_ USHORT Depth
    )
{
    ExInitializeNPagedLookasideList(Lookaside,
                                    Allocate,
                                    Free,
#if POOL_NX_OPTIN_AUTO
                                    Flags | POOL_NX_ALLOCATION,
#else
                                    Flags | (ULONG) ExDefaultNonPagedPoolType,
#endif
                                    Size,
                                    Tag,
                                    Depth);

    return;
}

#define ExInitializeNPagedLookasideList ExInitializeNPagedLookasideList_NXPoolOptIn

#endif // !POOL_NX_OPTOUT && (POOL_NX_OPTIN || POOL_NX_OPTIN_AUTO)

#endif // (NTDDI_VERSION >= NTDDK_WIN2K)


#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    _Inout_ PNPAGED_LOOKASIDE_LIST Lookaside
    );

#endif

__drv_allocatesMem(Mem)
_IRQL_requires_max_(DISPATCH_LEVEL)
__inline
_Ret_maybenull_
_Post_writable_byte_size_(Lookaside->L.Size)
PVOID
#pragma warning(suppress: 28195) // memory is not always allocated here, sometimes we reuse an entry from the list
ExAllocateFromNPagedLookasideList (
    _Inout_ PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                       &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);

#endif

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

_IRQL_requires_max_(DISPATCH_LEVEL)
__inline
VOID
ExFreeToNPagedLookasideList (
    _Inout_ PNPAGED_LOOKASIDE_LIST Lookaside,
    _In_ __drv_freesMem(Mem) PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSLIST_ENTRY)Entry,
                                    &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

        InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);

#endif

    }

    return;
}

// end_ntndis

typedef struct LOOKASIDE_ALIGN _PAGED_LOOKASIDE_LIST {

    GENERAL_LOOKASIDE L;

#if defined(_X86_)

    FAST_MUTEX Lock__ObsoleteButDoNotDelete;

#endif

} PAGED_LOOKASIDE_LIST, *PPAGED_LOOKASIDE_LIST;


#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExInitializePagedLookasideList (
    _Out_ PPAGED_LOOKASIDE_LIST Lookaside,
    _In_opt_ PALLOCATE_FUNCTION Allocate,
    _In_opt_ PFREE_FUNCTION Free,
    _In_ ULONG Flags,
    _In_ SIZE_T Size,
    _In_ ULONG Tag,
    _In_ USHORT Depth
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExDeletePagedLookasideList (
    _Inout_ PPAGED_LOOKASIDE_LIST Lookaside
    );

#endif

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
ExAllocateFromPagedLookasideList (
    _Inout_ PPAGED_LOOKASIDE_LIST Lookaside
    );

#else

#pragma warning(push)
#pragma warning(disable: 28195) // memory is not always allocated here, sometimes we reuse an entry from the list
__drv_allocatesMem(Mem)
_IRQL_requires_max_(APC_LEVEL)
__inline
PVOID
ExAllocateFromPagedLookasideList (
    _Inout_ PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

#pragma warning(pop)

#endif

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExFreeToPagedLookasideList (
    _Inout_ PPAGED_LOOKASIDE_LIST Lookaside,
    _In_ PVOID Entry
    );

#else

_IRQL_requires_max_(APC_LEVEL)
__inline
VOID
ExFreeToPagedLookasideList (
    _Inout_ PPAGED_LOOKASIDE_LIST Lookaside,
    _In_ __drv_freesMem(Mem) PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {
        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);
    }

    return;
}

#endif


#if defined(_NTDDK_) || defined(_NTIFS_)

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#if defined(_PREFAST_)

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
NTAPI
ProbeForRead (
    __in_data_source(USER_MODE) _In_reads_bytes_(Length) const volatile VOID *Address,
    _In_ SIZE_T Length,
    _In_ ULONG Alignment
    );

#else

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
NTAPI
ProbeForRead (
    __in_data_source(USER_MODE) _In_reads_bytes_(Length) volatile VOID *Address,
    _In_ SIZE_T Length,
    _In_ ULONG Alignment
    );

#endif // _PREFAST_

#endif

#endif

//
// Raise status from kernel mode.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
ExRaiseStatus (
    _In_ NTSTATUS Status
    );

#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
ExRaiseDatatypeMisalignment (
    VOID
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
ExRaiseAccessViolation (
    VOID
    );

#endif

// end_ntddk

//
// Probe for read functions.
//
//++
//
// VOID
// ProbeForRead (
//     IN PVOID Address,
//     IN ULONG Length,
//     IN ULONG Alignment
//     )
//
//--
#if defined(_PREFAST_)

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
NTAPI
ProbeForRead (
    __in_data_source(USER_MODE) _In_reads_bytes_(Length) const volatile VOID *Address,
    _In_ SIZE_T Length,
    _In_ ULONG Alignment
    );

#else

#define ProbeForRead(Address, Length, Alignment) {                           \
    NT_ASSERT(((Alignment) & ((Alignment) - 1)) == 0);                       \
                                                                             \
    if ((Length) != 0) {                                                     \
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {               \
            ExRaiseDatatypeMisalignment();                                   \
        }                                                                    \
                                                                             \
        if ((((ULONG_PTR)(Address) + (Length)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS) || \
            (((ULONG_PTR)(Address) + (Length)) < (ULONG_PTR)(Address))) {    \
            WriteNoFence8((volatile CHAR * const)MM_USER_PROBE_ADDRESS, 0);  \
        }                                                                    \
    }                                                                        \
}

#endif // _PREFAST_


_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForReadSmallStructure (
    __in_data_source(USER_MODE) _In_reads_bytes_(Size) volatile VOID *Address,
    _In_ SIZE_T Size,
    _In_ ULONG Alignment
    )

/*++

Routine Description:

    Probes a structure for read access whose size is known at compile time.

    N.B. A NULL structure address is not allowed.

Arguments:

    Address - Supples a pointer to the structure.

    Size - Supplies the size of the structure.

    Alignment - Supplies the alignment of structure.

Return Value:

    None

--*/

{

    NT_ASSERT((Alignment == 1) || (Alignment == 2) ||
              (Alignment == 4) || (Alignment == 8) ||
              (Alignment == 16)  || (Alignment == 64));

    if ((Size == 0) || (Size >= 0x10000)) {

        NT_ASSERT(0);

        ProbeForRead(Address, Size, Alignment);

    } else {
        if (((ULONG_PTR)Address & (Alignment - 1)) != 0) {
            ExRaiseDatatypeMisalignment();
        }

        if ((PUCHAR)Address >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {
            Address = (UCHAR * const)MM_USER_PROBE_ADDRESS;
        }

        _ReadWriteBarrier();
        ReadNoFence8((PCHAR)Address);
    }
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
BOOLEAN
ProbeAndReadBoolean (
    _In_reads_bytes_(sizeof(BOOLEAN)) volatile CONST BOOLEAN *Address
    )

{

    C_ASSERT(sizeof(BOOLEAN) == sizeof(CHAR));

    if (Address >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {
        Address = (BOOLEAN * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return (ReadUCharNoFence(Address) != 0);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
CHAR
ProbeAndReadChar (
    _In_reads_bytes_(sizeof(CHAR)) volatile CONST CHAR *Address
    )

{

    if (Address >= (CHAR * const)MM_USER_PROBE_ADDRESS) {
        Address = (CHAR * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadNoFence8(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
UCHAR
ProbeAndReadUchar (
    _In_reads_bytes_(sizeof(UCHAR)) volatile CONST UCHAR *Address
    )

{

    if (Address >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {
        Address = (UCHAR * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadUCharNoFence(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
SHORT
ProbeAndReadShort (
    _In_reads_bytes_(sizeof(SHORT)) volatile CONST SHORT *Address
    )

{

    if (Address >= (SHORT * const)MM_USER_PROBE_ADDRESS) {
        Address = (SHORT * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadNoFence16(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
USHORT
ProbeAndReadUshort (
    _In_reads_bytes_(sizeof(USHORT)) volatile CONST USHORT *Address
    )

{

    if (Address >= (USHORT * const)MM_USER_PROBE_ADDRESS) {
        Address = (USHORT * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadUShortNoFence(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
HANDLE
ProbeAndReadHandle (
    _In_reads_bytes_(sizeof(HANDLE)) volatile CONST HANDLE *Address
    )

{

    C_ASSERT(sizeof(HANDLE) == sizeof(PVOID));

    if (Address >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {
        Address = (HANDLE * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return (HANDLE)ReadPointerNoFence((PVOID *)Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
PVOID
ProbeAndReadPointer (
    _In_reads_bytes_(sizeof(PVOID)) volatile CONST PVOID *Address
    )

{

    if (Address >= (PVOID * const)MM_USER_PROBE_ADDRESS) {
        Address = (PVOID * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadPointerNoFence(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
LONG
ProbeAndReadLong (
    _In_reads_bytes_(sizeof(LONG)) volatile CONST LONG *Address
    )

{

    if (Address >= (LONG * const)MM_USER_PROBE_ADDRESS) {
        Address = (LONG * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadNoFence(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
ULONG
ProbeAndReadUlong (
    _In_reads_bytes_(sizeof(ULONG)) volatile CONST ULONG *Address
    )

{

    if (Address >= (ULONG * const)MM_USER_PROBE_ADDRESS) {
        Address = (ULONG * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadULongNoFence(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
ULONG_PTR
ProbeAndReadUlong_ptr (
    _In_reads_bytes_(sizeof(ULONG_PTR)) volatile CONST ULONG_PTR *Address
    )

{

    if (Address >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) {
        Address = (ULONG_PTR * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    return ReadULongPtrNoFence(Address);
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
LARGE_INTEGER
ProbeAndReadLargeInteger (
    _In_reads_bytes_(sizeof(LARGE_INTEGER)) volatile CONST LARGE_INTEGER *Address
    )

{

    LARGE_INTEGER Value;

    if (Address >= (LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) {
        Address = (LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    Value.QuadPart = ReadNoFence64(&Address->QuadPart);
    return Value;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
ULARGE_INTEGER
ProbeAndReadUlargeInteger (
    _In_reads_bytes_(sizeof(ULARGE_INTEGER)) volatile CONST ULARGE_INTEGER *Address
    )

{

    ULARGE_INTEGER Value;

    if (Address >= (ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) {
        Address = (ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    Value.QuadPart = ReadULong64NoFence(&Address->QuadPart);
    return Value;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndReadUnicodeStringEx (
    _Out_writes_bytes_(sizeof(UNICODE_STRING)) PUNICODE_STRING Destination,
    _In_ volatile CONST UNICODE_STRING *Source
    )

{

    if (Source >= (UNICODE_STRING * const)MM_USER_PROBE_ADDRESS) {
        Source = (UNICODE_STRING * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();

    //
    // Copy Length and MaximumLength in one operation.
    //

    *(PLONG)Destination = ReadNoFence((PLONG)Source);
    Destination->Buffer = (PWCHAR)ReadPointerNoFence((PVOID *)&Source->Buffer);
    return;
}

#if !defined(__cplusplus)

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
UNICODE_STRING
ProbeAndReadUnicodeString (
    _In_ volatile CONST UNICODE_STRING *Source
    )

{

    UNICODE_STRING Value;

    ProbeAndReadUnicodeStringEx(&Value, Source);
    return Value;
}

#endif

#define ProbeAndReadStructure(Dst, Src, STRUCTURE)                         \
    ProbeAndReadStructureWorker(Dst, Src, sizeof(STRUCTURE))

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndReadStructureWorker (
    _Out_writes_bytes_(Size) PVOID Destination,
    _In_reads_bytes_(Size) volatile CONST VOID *Source,
    _In_ SIZE_T Size
    )

{

    if (Source >= (VOID * const)MM_USER_PROBE_ADDRESS) {
        Source = (VOID * const)MM_USER_PROBE_ADDRESS;
    }

    memcpy(Destination, (PVOID)Source, Size);
    _ReadWriteBarrier();
    return;
}

//
// Probe for write functions definitions.
//
// N.B. Most of these functions have SAL annotations which indicate that they
//      only read from their arguments. This is needed to allow probing of
//      _Inout_ parameters for write followed by reading their initial values.
//

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteBoolean (
    _In_reads_bytes_(sizeof(BOOLEAN)) volatile BOOLEAN *Address
    )

{

    if (Address >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {
        Address = (BOOLEAN * const)MM_USER_PROBE_ADDRESS;
    }

    WriteUCharNoFence(Address, ReadUCharNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteChar (
    _In_reads_bytes_(sizeof(CHAR)) volatile CHAR *Address
    )

{

    if (Address >= (CHAR * const)MM_USER_PROBE_ADDRESS) {
        Address = (CHAR * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence8(Address, ReadNoFence8(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteUchar (
    _In_reads_bytes_(sizeof(UCHAR)) PUCHAR Address
    )

{

    if (Address >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {
        Address = (UCHAR * const)MM_USER_PROBE_ADDRESS;
    }

    WriteUCharNoFence(Address, ReadUCharNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteIoStatus (
    _In_reads_bytes_(sizeof(IO_STATUS_BLOCK)) volatile IO_STATUS_BLOCK *Address
    )

{

    if (Address >= (IO_STATUS_BLOCK * const)MM_USER_PROBE_ADDRESS) {
        Address = (IO_STATUS_BLOCK * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence(&Address->Status, ReadNoFence(&Address->Status));
    return;
}

#define ProbeForWriteIoStatusEx(Address, Cookie) ProbeForWriteIoStatus(Address)

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteShort (
    _In_reads_bytes_(sizeof(SHORT)) volatile SHORT *Address
    )

{

    if (Address >= (SHORT * const)MM_USER_PROBE_ADDRESS) {
        Address = (SHORT * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence16(Address, ReadNoFence16(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteUshort (
    _In_reads_bytes_(sizeof(USHORT)) volatile USHORT *Address
    )

{

    if (Address >= (USHORT * const)MM_USER_PROBE_ADDRESS) {
        Address = (USHORT * const)MM_USER_PROBE_ADDRESS;
    }

    WriteUShortNoFence(Address, ReadUShortNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteHandle (
    _In_reads_bytes_(sizeof(HANDLE)) volatile HANDLE *Address
    )

{

    if (Address >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {
        Address = (HANDLE * const)MM_USER_PROBE_ADDRESS;
    }

    WritePointerNoFence((PVOID *)Address, ReadPointerNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndZeroHandle (
    _Out_writes_bytes_(sizeof(HANDLE)) volatile HANDLE *Address
    )

{

    if (Address >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {
        Address = (HANDLE * const)MM_USER_PROBE_ADDRESS;
    }

    WritePointerNoFence((PVOID *)Address, NULL);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWritePointer (
    _In_reads_bytes_(sizeof(PVOID)) volatile PVOID *Address
    )

{

    if (Address >= (PVOID * const)MM_USER_PROBE_ADDRESS) {
        Address = (PVOID * const)MM_USER_PROBE_ADDRESS;
    }

    WritePointerNoFence(Address, ReadPointerNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndNullPointer (
    _Out_writes_bytes_(sizeof(PVOID)) volatile PVOID *Address
    )

{

    if (Address >= (PVOID * const)MM_USER_PROBE_ADDRESS) {
        Address = (PVOID * const)MM_USER_PROBE_ADDRESS;
    }

    WritePointerNoFence(Address, NULL);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteLong (
    _In_reads_bytes_(sizeof(LONG)) volatile LONG *Address
    )

{

    if (Address >= (LONG * const)MM_USER_PROBE_ADDRESS) {
        Address = (LONG * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence(Address, ReadNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteUlong (
    _In_reads_bytes_(sizeof(ULONG)) volatile ULONG *Address
    )

{

    if (Address >= (ULONG * const)MM_USER_PROBE_ADDRESS) {
        Address = (ULONG * const)MM_USER_PROBE_ADDRESS;
    }

    WriteULongNoFence(Address, ReadULongNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteUlongAligned32 (
    _In_reads_bytes_(sizeof(ULONG)) volatile ULONG *Address
    )

{

    if (((ULONG_PTR)Address & (sizeof(ULONG) - 1)) != 0) {
        ExRaiseDatatypeMisalignment();
    }

    ProbeForWriteUlong(Address);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteUlong_ptr (
    _In_reads_bytes_(sizeof(ULONG_PTR)) volatile ULONG_PTR *Address
    )

{

    if (Address >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) {
        Address = (ULONG_PTR * const)MM_USER_PROBE_ADDRESS;
    }

    WriteULongPtrNoFence(Address, ReadULongPtrNoFence(Address));
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteQuad (
    _In_reads_bytes_(sizeof(QUAD)) volatile QUAD *Address
    )

{

    if (Address >= (QUAD * const)MM_USER_PROBE_ADDRESS) {
        Address = (QUAD * const)MM_USER_PROBE_ADDRESS;
    }


    WriteNoFence64(&Address->UseThisFieldToCopy,
                   ReadNoFence64(&Address->UseThisFieldToCopy));

    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteUquad (
    _In_reads_bytes_(sizeof(UQUAD)) volatile UQUAD *Address
    )

{

    ProbeForWriteQuad((PQUAD)Address);
    return;
}

//
// Probe and write functions definitions.
//

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteBoolean (
    _Out_writes_bytes_(sizeof(BOOLEAN)) volatile BOOLEAN *Address,
    _In_ BOOLEAN Value
    )

{

    if (Address >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {
        Address = (BOOLEAN * const)MM_USER_PROBE_ADDRESS;
    }

    WriteUCharNoFence(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteChar (
    _Out_writes_bytes_(sizeof(CHAR)) volatile CHAR *Address,
    _In_ CHAR Value
    )

{

    if (Address >= (CHAR * const)MM_USER_PROBE_ADDRESS) {
        Address = (CHAR * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence8(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteUchar (
    _Out_writes_bytes_(sizeof(UCHAR)) volatile UCHAR *Address,
    _In_ UCHAR Value
    )

{

    if (Address >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {
        Address = (UCHAR * const)MM_USER_PROBE_ADDRESS;
    }

    WriteUCharNoFence(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteShort (
    _Out_writes_bytes_(sizeof(SHORT)) volatile SHORT *Address,
    _In_ SHORT Value
    )

{

    if (Address >= (SHORT * const)MM_USER_PROBE_ADDRESS) {
        Address = (SHORT * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence16(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteUshort (
    _Out_writes_bytes_(sizeof(USHORT)) volatile USHORT *Address,
    _In_ USHORT Value
    )

{

    if (Address >= (USHORT * const)MM_USER_PROBE_ADDRESS) {
        Address = (USHORT * const)MM_USER_PROBE_ADDRESS;
    }

    WriteUShortNoFence(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteHandle (
    _Out_writes_bytes_(sizeof(HANDLE)) volatile HANDLE *Address,
    _In_ HANDLE Value
    )

{

    if (Address >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {
        Address = (HANDLE * const)MM_USER_PROBE_ADDRESS;
    }

    WritePointerNoFence((PVOID *)Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteLong (
    _Out_writes_bytes_(sizeof(LONG)) volatile LONG *Address,
    _In_ LONG Value
    )

{

    if (Address >= (LONG * const)MM_USER_PROBE_ADDRESS) {
        Address = (LONG * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteUlong (
    _Out_writes_bytes_(sizeof(ULONG)) volatile ULONG *Address,
    _In_ ULONG Value
    )

{

    if (Address >= (ULONG * const)MM_USER_PROBE_ADDRESS) {
        Address = (ULONG * const)MM_USER_PROBE_ADDRESS;
    }

    WriteULongNoFence(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteUlong_ptr (
    _Out_writes_bytes_(sizeof(ULONG_PTR)) volatile ULONG_PTR *Address,
    _In_ ULONG_PTR Value
    )

{

    if (Address >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) {
        Address = (ULONG_PTR * const)MM_USER_PROBE_ADDRESS;
    }

    WriteULongPtrNoFence(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWritePointer (
    _Out_ volatile PVOID *Address,
    _In_ PVOID Value
    )

{

    if (Address >= (PVOID * const)MM_USER_PROBE_ADDRESS) {
        Address = (PVOID * const)MM_USER_PROBE_ADDRESS;
    }

    WritePointerNoFence(Address, Value);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteQuad (
    _Out_writes_bytes_(sizeof(QUAD)) volatile QUAD *Address,
    _In_ QUAD Value
    )

{

    if (Address >= (QUAD * const)MM_USER_PROBE_ADDRESS) {
        Address = (QUAD * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence64(&Address->UseThisFieldToCopy, Value.UseThisFieldToCopy);
    return;
}

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteUquad (
    _Out_writes_bytes_(sizeof(UQUAD)) volatile UQUAD *Address,
    _In_ UQUAD Value
    )

{

    if (Address >= (UQUAD * const)MM_USER_PROBE_ADDRESS) {
        Address = (UQUAD * const)MM_USER_PROBE_ADDRESS;
    }

    WriteNoFence64(&Address->UseThisFieldToCopy, Value.UseThisFieldToCopy);
    return;
}

#define ProbeAndWriteStructure(Address, Value, STRUCTURE)                    \
    ProbeAndWriteStructureWorker(Address, &(Value), sizeof(STRUCTURE))

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeAndWriteStructureWorker (
    _Out_writes_bytes_(Size) volatile VOID *Address,
    _In_reads_bytes_(Size) PVOID Value,
    _In_ SIZE_T Size
    )

{

    if (Address >= (VOID * const)MM_USER_PROBE_ADDRESS) {
        Address = (VOID * const)MM_USER_PROBE_ADDRESS;
    }

    _ReadWriteBarrier();
    memcpy((PVOID)Address, Value, Size);
    return;
}


//
// Common probe for write functions.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
NTAPI
ProbeForWrite (
    __in_data_source(USER_MODE) _Inout_updates_bytes_(Length) volatile VOID *Address,
    _In_ SIZE_T Length,
    _In_ ULONG Alignment
    );

#endif

// begin_wudfpwdm
//
// Worker Thread
//

typedef _Enum_is_bitflag_ enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    NormalWorkQueue,
    BackgroundWorkQueue,
    RealTimeWorkQueue,
    SuperCriticalWorkQueue,
    MaximumWorkQueue,
    CustomPriorityWorkQueue = 32
} WORK_QUEUE_TYPE;

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Function_class_(WORKER_THREAD_ROUTINE)
VOID
WORKER_THREAD_ROUTINE (
    _In_ PVOID Parameter
    );

typedef WORKER_THREAD_ROUTINE *PWORKER_THREAD_ROUTINE;

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    __volatile PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

DECLSPEC_DEPRECATED_DDK                  // Use IoAllocateWorkItem
CFORCEINLINE
VOID
ExInitializeWorkItem (
    _Out_    PWORK_QUEUE_ITEM Item,
    _In_opt_ PWORKER_THREAD_ROUTINE Routine,
    _In_opt_ PVOID Context
    )
{
    Item->WorkerRoutine = Routine;
    Item->Parameter = Context;
    Item->List.Flink = NULL;
}


// end_wudfpwdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#ifdef _NTDDK_

_When_( (!__drv_defined(_DRIVER_TYPE_FILESYSTEM)
    && !__drv_defined(_DRIVER_TYPE_FILESYSTEM_FILTER))
    || NTDDI_VERSION >= NTDDI_VISTA,
    __drv_preferredFunction("IoQueueWorkItem[Ex]",
    "Obsolete in all drivers for Vista. Obsolete downlevel except for limited "
    "use in IFS. See the documentation"))

#endif

_IRQL_requires_max_(DISPATCH_LEVEL)
DECLSPEC_DEPRECATED_DDK // Use IoQueueWorkItem
NTKERNELAPI
VOID
ExQueueWorkItem(
    _Inout_ __drv_aliasesMem PWORK_QUEUE_ITEM WorkItem,
    _In_ WORK_QUEUE_TYPE QueueType
    );

#endif



#if (NTDDI_VERSION >= NTDDI_WIN8)

_IRQL_requires_max_(DISPATCH_LEVEL)
DECLSPEC_DEPRECATED_DDK // Use IoTryQueueWorkItem preferably
NTKERNELAPI
BOOLEAN
ExTryQueueWorkItem (
    _Inout_ __drv_aliasesMem PWORK_QUEUE_ITEM WorkItem,
    _In_ WORK_QUEUE_TYPE QueueType
    );

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(PASSIVE_LEVEL)
__drv_preferredFunction("nothing",
    "Drivers should not be dependent on processor features")
NTKERNELAPI
BOOLEAN
ExIsProcessorFeaturePresent(
    _In_ ULONG ProcessorFeature
    );

#endif


//
// Zone Allocation
//

typedef struct _ZONE_SEGMENT_HEADER {
    SINGLE_LIST_ENTRY SegmentList;
    PVOID Reserved;
} ZONE_SEGMENT_HEADER, *PZONE_SEGMENT_HEADER;

typedef struct _ZONE_HEADER {
    SINGLE_LIST_ENTRY FreeList;
    SINGLE_LIST_ENTRY SegmentList;
    ULONG BlockSize;
    ULONG TotalSegmentSize;
} ZONE_HEADER, *PZONE_HEADER;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

__drv_preferredFunction("lookaside lists instead", "Obsolete")
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInitializeZone(
    _Out_ PZONE_HEADER Zone,
    _In_ ULONG BlockSize,
    _Inout_ PVOID InitialSegment,
    _In_ ULONG InitialSegmentSize
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

__drv_preferredFunction("lookaside lists instead", "Obsolete")
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExExtendZone(
    _Inout_ PZONE_HEADER Zone,
    _Inout_ PVOID Segment,
    _In_ ULONG SegmentSize
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
__drv_preferredFunction("lookaside lists instead", "Obsolete")
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInterlockedExtendZone(
    _Inout_ PZONE_HEADER Zone,
    _Inout_ PVOID Segment,
    _In_ ULONG SegmentSize,
    _Inout_ _Requires_lock_not_held_(*_Curr_) PKSPIN_LOCK Lock
    );

#endif

//++
//
// PVOID
// ExAllocateFromZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExAllocateFromZone)
#endif

#define ExAllocateFromZone(Zone) \
    (PVOID)((Zone)->FreeList.Next); \
    if ( (Zone)->FreeList.Next ) (Zone)->FreeList.Next = (Zone)->FreeList.Next->Next

//++
//
// PVOID
// ExFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExFreeToZone)
#endif

#define ExFreeToZone(Zone,Block)                                    \
    ( ((PSINGLE_LIST_ENTRY)(Block))->Next = (Zone)->FreeList.Next,  \
      (Zone)->FreeList.Next = ((PSINGLE_LIST_ENTRY)(Block)),        \
      ((PSINGLE_LIST_ENTRY)(Block))->Next                           \
    )

//++
//
// BOOLEAN
// ExIsFullZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine determines if the specified zone is full or not.  A zone
//     is considered full if the free list is empty.
//
// Arguments:
//
//     Zone - Pointer to the zone header to be tested.
//
// Return Value:
//
//     TRUE if the zone is full and FALSE otherwise.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsFullZone)
#endif

#define ExIsFullZone(Zone) \
    ( (Zone)->FreeList.Next == (PSINGLE_LIST_ENTRY)NULL )

//++
//
// PVOID
// ExInterlockedAllocateFromZone(
//     IN PZONE_HEADER Zone,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//     The removal is performed with the specified lock owned for the sequence
//     to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
//     Lock - Pointer to the spin lock which should be obtained before removing
//         the entry from the allocation list.  The lock is released before
//         returning to the caller.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedAllocateFromZone)
#endif

#define ExInterlockedAllocateFromZone(Zone,Lock) \
    (PVOID) ExInterlockedPopEntryList( &(Zone)->FreeList, Lock )

//++
//
// PVOID
// ExInterlockedFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.  The insertion is performed with the lock
//     owned for the sequence to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
//     Lock - Pointer to the spin lock which should be obtained before inserting
//         the entry onto the free list.  The lock is released before returning
//         to the caller.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedFreeToZone)
#endif

#define ExInterlockedFreeToZone(Zone,Block,Lock) \
    ExInterlockedPushEntryList( &(Zone)->FreeList, ((PSINGLE_LIST_ENTRY) (Block)), Lock )


//++
//
// BOOLEAN
// ExIsObjectInFirstZoneSegment(
//     IN PZONE_HEADER Zone,
//     IN PVOID Object
//     )
//
// Routine Description:
//
//     This routine determines if the specified pointer lives in the zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         object may belong.
//
//     Object - Pointer to the object in question.
//
// Return Value:
//
//     TRUE if the Object came from the first segment of zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsObjectInFirstZoneSegment)
#endif

#define ExIsObjectInFirstZoneSegment(Zone,Object) ((BOOLEAN)     \
    (((PUCHAR)(Object) >= (PUCHAR)(Zone)->SegmentList.Next) &&   \
     ((PUCHAR)(Object) < (PUCHAR)(Zone)->SegmentList.Next +      \
                         (Zone)->TotalSegmentSize))              \
)


//
//  Define executive resource data structures.
//

typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        struct {
            ULONG IoPriorityBoosted : 1;
            ULONG OwnerReferenced   : 1;
            ULONG OwnerCount        : 30;
        };
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;

    //
    // ActiveEntries is the true, 32-bit count.  Existing code
    // checks for ActiveCount == 0, so this toggles between
    // 0 and 1 and back as ActiveEntries goes from 0 to
    // non-zero and back.
    //

    SHORT ActiveCount;
    union {
        USHORT Flag;
        struct {
            UCHAR ReservedLowFlags;
            UCHAR WaiterPriority;
        };
    };

    KWAIT_CHAIN SharedWaiters;
    __volatile PKEVENT ExclusiveWaiters;

    //
    // If the resource is owned exclusive, OwnerEntry contains the
    // resource owner.
    //
    // If the resource is owned shared, OwnerEntry may contain one
    // of the shared owners.
    //

    OWNER_ENTRY OwnerEntry;
    ULONG ActiveEntries;
    ULONG ContentionCount;
    ULONG NumberOfSharedWaiters;
    ULONG NumberOfExclusiveWaiters;

#if defined(_WIN64)

    PVOID Reserved2;

#endif

    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

//
//  Values for ERESOURCE.Flag
//

#define ResourceNeverExclusive          0x0010
#define ResourceReleaseByOtherThread    0x0020
#define ResourceOwnedExclusive          0x0080

#define RESOURCE_HASH_TABLE_SIZE 64

typedef struct _RESOURCE_HASH_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID Address;
    ULONG ContentionCount;
    ULONG Number;
} RESOURCE_HASH_ENTRY, *PRESOURCE_HASH_ENTRY;

typedef struct _RESOURCE_PERFORMANCE_DATA {
    ULONG ActiveResourceCount;
    ULONG TotalResourceCount;
    ULONG ExclusiveAcquire;
    ULONG SharedFirstLevel;
    ULONG SharedSecondLevel;
    ULONG StarveFirstLevel;
    ULONG StarveSecondLevel;
    ULONG WaitForExclusive;
    ULONG OwnerTableExpands;
    ULONG MaximumTableExpand;
    LIST_ENTRY HashTable[RESOURCE_HASH_TABLE_SIZE];
} RESOURCE_PERFORMANCE_DATA, *PRESOURCE_PERFORMANCE_DATA;

//
// Define executive resource function prototypes.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
ExInitializeResourceLite (
    _Out_ PERESOURCE Resource
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
ExReinitializeResourceLite (
    _Inout_ PERESOURCE Resource
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_When_(Wait!=0, _Post_satisfies_(return == 1))
_When_(Wait==0, _Post_satisfies_(return == 0 || return == 1) _Must_inspect_result_)
NTKERNELAPI
BOOLEAN
ExAcquireResourceSharedLite (
    _Inout_ _Requires_lock_not_held_(*_Curr_)
    _When_(return!=0, _Acquires_shared_lock_(*_Curr_))
    PERESOURCE Resource,
    _In_ BOOLEAN Wait
    );

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)

_IRQL_requires_max_(APC_LEVEL)
_Acquires_lock_(_Global_critical_region_)
NTKERNELAPI
PVOID
ExEnterCriticalRegionAndAcquireResourceShared (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_shared_lock_(*_Curr_)
    PERESOURCE Resource
    );

#endif

// end_wdm

_IRQL_requires_max_(APC_LEVEL)
_Acquires_lock_(_Global_critical_region_)
_Acquires_lock_(_Global_priority_region_)
NTKERNELAPI
PVOID
ExEnterPriorityRegionAndAcquireResourceShared (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_shared_lock_(*_Curr_)
    PERESOURCE Resource
    );

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
BOOLEAN
ExTryToAcquireResourceExclusiveLite (
    _Inout_ _Requires_lock_not_held_(*_Curr_)
    _When_(return!=0, _Acquires_exclusive_lock_(*_Curr_))
    PERESOURCE Resource
    );

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_When_(Wait!=0, _Post_satisfies_(return == 1))
_When_(Wait==0, _Post_satisfies_(return == 0 || return == 1) _Must_inspect_result_)
NTKERNELAPI
BOOLEAN
ExAcquireResourceExclusiveLite (
    _Inout_ _Requires_lock_not_held_(*_Curr_)
    _When_(return!=0, _Acquires_exclusive_lock_(*_Curr_))
    PERESOURCE Resource,
    _In_ _Literal_ BOOLEAN Wait
    );

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)

_IRQL_requires_max_(APC_LEVEL)
_Acquires_lock_(_Global_critical_region_)
NTKERNELAPI
PVOID
ExEnterCriticalRegionAndAcquireResourceExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_exclusive_lock_(*_Curr_)
    PERESOURCE Resource
    );

#endif

// end_wdm

_IRQL_requires_max_(APC_LEVEL)
_Acquires_lock_(_Global_critical_region_)
_Acquires_lock_(_Global_priority_region_)
NTKERNELAPI
PVOID
ExEnterPriorityRegionAndAcquireResourceExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_exclusive_lock_(*_Curr_)
    PERESOURCE Resource
    );

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_When_(Wait!=0, _Post_satisfies_(return == 1))
_When_(Wait==0, _Post_satisfies_(return == 0 || return == 1) _Must_inspect_result_)
NTKERNELAPI
BOOLEAN
ExAcquireSharedStarveExclusive(
    _Inout_ _Requires_lock_not_held_(*_Curr_)
    _When_(return!=0, _Acquires_shared_lock_(*_Curr_))
    PERESOURCE Resource,
    _In_ BOOLEAN Wait
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_When_(Wait!=0, _Post_satisfies_(return == 1))
_When_(Wait==0, _Post_satisfies_(return == 0 || return == 1) _Must_inspect_result_)
NTKERNELAPI
BOOLEAN
ExAcquireSharedWaitForExclusive(
    _Inout_ _Requires_lock_not_held_(*_Curr_)
    _When_(return!=0, _Acquires_lock_(*_Curr_))
    PERESOURCE Resource,
    _In_ BOOLEAN Wait
    );

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)

_IRQL_requires_max_(APC_LEVEL)
_Acquires_lock_(_Global_critical_region_)
NTKERNELAPI
PVOID
ExEnterCriticalRegionAndAcquireSharedWaitForExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PERESOURCE Resource
    );

#endif

//
//  VOID
//  ExReleaseResource(
//      IN PERESOURCE Resource
//      );
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExReleaseResource)       // Use ExReleaseResourceLite
#endif

#define ExReleaseResource(R) (ExReleaseResourceLite(R))

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_Requires_lock_held_(_Global_critical_region_)
_Requires_lock_held_(*Resource)
_Releases_lock_(*Resource)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceLite(
    _Inout_ PERESOURCE Resource
    );

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)

_IRQL_requires_max_(DISPATCH_LEVEL)
_Releases_lock_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceAndLeaveCriticalRegion(
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PERESOURCE Resource
    );

#endif

// end_wdm

_IRQL_requires_max_(DISPATCH_LEVEL)
_Releases_lock_(_Global_critical_region_)
_Releases_lock_(_Global_priority_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceAndLeavePriorityRegion(
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PERESOURCE Resource
    );

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
ExReleaseResourceForThreadLite(
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PERESOURCE Resource,
    _In_ ERESOURCE_THREAD ResourceThreadId
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExSetResourceOwnerPointer(
    _Inout_ PERESOURCE Resource,
    _In_ PVOID OwnerPointer
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExSetResourceOwnerPointerEx(
    _Inout_ PERESOURCE Resource,
    _In_ PVOID OwnerPointer,
    _In_ ULONG Flags
    );

#define FLAG_OWNER_POINTER_IS_THREAD 0x1

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExConvertExclusiveToSharedLite(
    _Inout_ _Requires_lock_held_(*_Curr_) PERESOURCE Resource
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
ExDeleteResourceLite (
    _Inout_ PERESOURCE Resource
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
ULONG
ExGetExclusiveWaiterCount (
    _In_ PERESOURCE Resource
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
ULONG
ExGetSharedWaiterCount (
    _In_ PERESOURCE Resource
    );

#endif


//
//  ERESOURCE_THREAD
//  ExGetCurrentResourceThread(
//      VOID
//      );
//

#define ExGetCurrentResourceThread() ((ULONG_PTR)PsGetCurrentThread())

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
ExIsResourceAcquiredExclusiveLite (
    _In_ PERESOURCE Resource
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
ULONG
ExIsResourceAcquiredSharedLite (
    _In_ PERESOURCE Resource
    );

#endif

//
// An acquired resource is always owned shared, as shared ownership is a subset
// of exclusive ownership.
//

#define ExIsResourceAcquiredLite ExIsResourceAcquiredSharedLite

// end_wdm
// begin_ntddk

//
//  ntddk.h stole the entrypoints we wanted so fix them up here.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInitializeResource)            // use ExInitializeResourceLite
#pragma deprecated(ExAcquireResourceShared)         // use ExAcquireResourceSharedLite
#pragma deprecated(ExAcquireResourceExclusive)      // use ExAcquireResourceExclusiveLite
#pragma deprecated(ExReleaseResourceForThread)      // use ExReleaseResourceForThreadLite
#pragma deprecated(ExConvertExclusiveToShared)      // use ExConvertExclusiveToSharedLite
#pragma deprecated(ExDeleteResource)                // use ExDeleteResourceLite
#pragma deprecated(ExIsResourceAcquiredExclusive)   // use ExIsResourceAcquiredExclusiveLite
#pragma deprecated(ExIsResourceAcquiredShared)      // use ExIsResourceAcquiredSharedLite
#pragma deprecated(ExIsResourceAcquired)            // use ExIsResourceAcquiredSharedLite
#endif
#define ExInitializeResource ExInitializeResourceLite
#define ExAcquireResourceShared ExAcquireResourceSharedLite
#define ExAcquireResourceExclusive ExAcquireResourceExclusiveLite
#define ExReleaseResourceForThread ExReleaseResourceForThreadLite
#define ExConvertExclusiveToShared ExConvertExclusiveToSharedLite
#define ExDeleteResource ExDeleteResourceLite
#define ExIsResourceAcquiredExclusive ExIsResourceAcquiredExclusiveLite
#define ExIsResourceAcquiredShared ExIsResourceAcquiredSharedLite
#define ExIsResourceAcquired ExIsResourceAcquiredSharedLite


//
// Push lock definitions
//


#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int
#endif

//
// AutoBoost flags for Push Locks.
//

//
// EX_PUSH_LOCK_FLAG_ENABLE_AUTOBOOST is now deprecated and has no effect,
// Autoboost will be enabled unless the EX_PUSH_LOCK_FLAG_DISABLE_AUTOBOOST
// flag is specified.
//

#define EX_PUSH_LOCK_FLAG_ENABLE_AUTOBOOST      0x1 // Deprecated.
#define EX_PUSH_LOCK_FLAG_DISABLE_AUTOBOOST     0x2
#define EX_PUSH_LOCK_FLAGS_VALID                0x3

typedef struct _EX_PUSH_LOCK {

//
// LOCK bit is set for both exclusive and shared acquires
//

#define EX_PUSH_LOCK_LOCK_V          ((ULONG_PTR)0x0)
#define EX_PUSH_LOCK_LOCK            ((ULONG_PTR)0x1)

//
// Waiting bit designates that the pointer has chained waiters
//

#define EX_PUSH_LOCK_WAITING         ((ULONG_PTR)0x2)

//
// Waking bit designates that we are either traversing the list
// to wake threads or optimizing the list
//

#define EX_PUSH_LOCK_WAKING          ((ULONG_PTR)0x4)

//
// Set if the lock is held shared by multiple owners and there are waiters
//

#define EX_PUSH_LOCK_MULTIPLE_SHARED ((ULONG_PTR)0x8)

//
// Total shared Acquires are incremented using this
//

#define EX_PUSH_LOCK_SHARE_INC       ((ULONG_PTR)0x10)
#define EX_PUSH_LOCK_PTR_BITS        ((ULONG_PTR)0xf)

    union {
        struct {
            ULONG_PTR Locked         : 1;
            ULONG_PTR Waiting        : 1;
            ULONG_PTR Waking         : 1;
            ULONG_PTR MultipleShared : 1;
            ULONG_PTR Shared         : sizeof(ULONG_PTR) * 8 - 4;
        };

        __volatile ULONG_PTR Value;
        __volatile PVOID Ptr;
    };

} EX_PUSH_LOCK, *PEX_PUSH_LOCK;

#define EX_CACHE_LINE_SIZE 128
#define EX_PUSH_LOCK_FANNED_COUNT (PAGE_SIZE/EX_CACHE_LINE_SIZE)

//
// Define a fan out structure for n push locks each in its own cache line
//

typedef struct _EX_PUSH_LOCK_CACHE_AWARE_LEGACY {
    PEX_PUSH_LOCK Locks[EX_PUSH_LOCK_FANNED_COUNT];
} EX_PUSH_LOCK_CACHE_AWARE_LEGACY, *PEX_PUSH_LOCK_CACHE_AWARE_LEGACY;

//
// Define structure thats a push lock padded to the size of a cache line
//

typedef struct _EX_PUSH_LOCK_CACHE_AWARE_PADDED {
    EX_PUSH_LOCK Lock;
    union {
        UCHAR Pad[EX_CACHE_LINE_SIZE - sizeof (EX_PUSH_LOCK)];
        struct {
            BOOLEAN Single;
            PVOID ParentLock;
        };
    };
} EX_PUSH_LOCK_CACHE_AWARE_PADDED, *PEX_PUSH_LOCK_CACHE_AWARE_PADDED;

//
// Define structure for auto-expanding push lock
//

#define EX_AEPL_EXPANDED       ((ULONG)0x00000001)
#define EX_AEPL_TRANSITIONING  ((ULONG)0x00000002)
#define EX_AEPL_PAGEABLE       ((ULONG)0x00000004)

#define EX_AEPL_STATE_BIT_MASK ((ULONG)(EX_AEPL_EXPANDED |      \
                                        EX_AEPL_TRANSITIONING | \
                                        EX_AEPL_PAGEABLE))

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND_STATE {
    union {
        struct {
            ULONG Expanded      : 1;
            ULONG Transitioning : 1;
            ULONG Pageable      : 1;
        };
        __volatile ULONG Value;
    };
} EX_PUSH_LOCK_AUTO_EXPAND_STATE, *PEX_PUSH_LOCK_AUTO_EXPAND_STATE;

typedef struct _EX_PUSH_LOCK_AUTO_EXPAND {
    EX_PUSH_LOCK LocalLock;
    EX_PUSH_LOCK_AUTO_EXPAND_STATE State;
    ULONG Stats;
} EX_PUSH_LOCK_AUTO_EXPAND, *PEX_PUSH_LOCK_AUTO_EXPAND;


//
// We will use the legacy force-inlined push lock functions if we are compiling
// for before Blue.
//

#if (NTDDI_VERSION < NTDDI_WINBLUE)
#ifndef EX_LEGACY_PUSH_LOCKS
#define EX_LEGACY_PUSH_LOCKS
#endif
#endif // (NTDDI_VERSION < NTDDI_WINBLUE)

//
// Before Blue + 1 we will use the legacy cache-aware push lock.
// From Blue + 1 onward we will use the auto-expand push lock.
//
// TODO: t-chrisk - Need to update < NTDDI_WINBLUE to == NTDDI_WINBLUE once
//                  the Blue + 1 constant is available.
//

#ifndef EX_LEGACY_CACHE_AWARE_LOCKS
#define EX_LEGACY_CACHE_AWARE_LOCKS
#endif

#if defined(EX_LEGACY_PUSH_LOCKS) || (NTDDI_VERSION < NTDDI_WINBLUE) || defined(EX_LEGACY_CACHE_AWARE_LOCKS)

typedef EX_PUSH_LOCK_CACHE_AWARE_LEGACY EX_PUSH_LOCK_CACHE_AWARE,
                                        *PEX_PUSH_LOCK_CACHE_AWARE;
#else

typedef EX_PUSH_LOCK_AUTO_EXPAND EX_PUSH_LOCK_CACHE_AWARE,
                                 *PEX_PUSH_LOCK_CACHE_AWARE;

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

// begin_wdm

//
// Rundown protection structure
//

typedef struct _EX_RUNDOWN_REF {

#define EX_RUNDOWN_ACTIVE      0x1
#define EX_RUNDOWN_COUNT_SHIFT 0x1
#define EX_RUNDOWN_COUNT_INC   (1<<EX_RUNDOWN_COUNT_SHIFT)

    union {
        __volatile ULONG_PTR Count;
        __volatile PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

//
//  Opaque cache-aware rundown ref structure
//

typedef struct _EX_RUNDOWN_REF_CACHE_AWARE  *PEX_RUNDOWN_REF_CACHE_AWARE;

// end_wdm

#define EX_CARR_EXPANDED           ((ULONG)0x00000001)
#define EX_CARR_TRANSITIONING      ((ULONG)0x00000002)
#define EX_CARR_EXPANSION_DISABLED ((ULONG)0x00000004)
#define EX_CARR_PAGEABLE           ((ULONG)0x00000008)

//
// Bits that need to be masked off to extract the handle.
// Pageable bit is only valid when unexpanded so it doesn't need to be
// masked off.
//

#define EX_CARR_STATE_BIT_MASK     ((ULONG)(EX_CARR_EXPANDED | \
                                            EX_CARR_TRANSITIONING | \
                                            EX_CARR_EXPANSION_DISABLED))

typedef struct _EX_RUNDOWN_REF_CACHE_AWARE_STATE {
    union {
        struct {

            //
            // These bits are always valid.
            //

            ULONG Expanded          : 1;
            ULONG Transitioning     : 1;
            ULONG ExpansionDisabled : 1;

            //
            // This bit is only valid when Expanded == 0.
            //

            ULONG Pageable          : 1;
        };

        __volatile ULONG Value;
    };
} EX_RUNDOWN_REF_CACHE_AWARE_STATE, *PEX_RUNDOWN_REF_CACHE_AWARE_STATE;

typedef struct _EX_RUNDOWN_REF_CACHE_AWARE {

    //
    //  Pointer to array of cache-line aligned rundown ref structures
    //

    PEX_RUNDOWN_REF RunRefs;

    //
    //  Points to pool of per-proc rundown refs that needs to be freed
    //

    PVOID PoolToFree;

    //
    //  Size of each padded rundown ref structure
    //

    ULONG RunRefSize;

    //
    //  Indicates # of entries in the array of rundown ref structures
    //

    ULONG Number;
} EX_RUNDOWN_REF_CACHE_AWARE, *PEX_RUNDOWN_REF_CACHE_AWARE;

//
//  The Ex/Ob handle table interface package (in handle.c)
//

//
//  The Ex/Ob handle table package uses a common handle definition.  The actual
//  type definition for a handle is a pvoid and is declared in sdk/inc.  This
//  package uses only the low 32 bits of the pvoid pointer.
//
//  For simplicity we declare a new typedef called an exhandle
//
//  The 2 bits of an EXHANDLE is available to the application and is
//  ignored by the system.  The next 24 bits store the handle table entry
//  index and is used to refer to a particular entry in a handle table.
//
//  Note that this format is immutable because there are outside programs with
//  hardwired code that already assumes the format of a handle.
//

typedef struct _EXHANDLE {

    union {

        struct {

            //
            //  Application available tag bits
            //

            ULONG TagBits : 2;

            //
            //  The handle table entry index
            //

            ULONG Index : 30;

        };

        HANDLE GenericHandleOverlay;

#define HANDLE_VALUE_INC 4 // Amount to increment the Value to get to the next handle

        ULONG_PTR Value;
    };

} EXHANDLE, *PEXHANDLE;


//
// Get previous mode
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
KPROCESSOR_MODE
ExGetPreviousMode(
    VOID
    );

#endif


_Maybe_raises_SEH_exception_
_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
VOID
ProbeForWriteSmallStructure (
    __in_data_source(USER_MODE) _In_reads_bytes_(Size)
    PVOID Address,
    _In_ SIZE_T Size,
    _In_ ULONG Alignment
    )

/*++

Routine Description:

    Probes a structure for write access whose size is known at compile time.

Arguments:

    Address - Supples a pointer to the structure.

    Size - Supplies the size of the structure.

    Alignment - Supplies the alignment of structure.

Return Value:

    None

--*/

{

#if !defined(_AMD64_)

    PCHAR Target;

#endif

    NT_ASSERT((Alignment == 1) || (Alignment == 2) ||
              (Alignment == 4) || (Alignment == 8) ||
              (Alignment == 16) || (Alignment == 64));

    //
    // If the size of the structure is > 4k then call the standard routine.
    //

    if ((Size == 0) || (Size >= 0x1000)) {

        NT_ASSERT(0);

        ProbeForWrite(Address, Size, Alignment);

    } else {
        if (((ULONG_PTR)(Address) & (Alignment - 1)) != 0) {
            ExRaiseDatatypeMisalignment();
        }

#if defined(_AMD64_)

        if ((ULONG_PTR)(Address) >= (ULONG_PTR)MM_USER_PROBE_ADDRESS) {
             Address = (UCHAR * const)MM_USER_PROBE_ADDRESS;
        }

        ((volatile UCHAR *)(Address))[0] = ((volatile UCHAR *)(Address))[0];
        ((volatile UCHAR *)(Address))[Size - 1] = ((volatile UCHAR *)(Address))[Size - 1];

#else

        if ((ULONG_PTR)(Address) >= (ULONG_PTR)MM_USER_PROBE_ADDRESS) {
             WriteNoFence8((volatile CHAR * const)MM_USER_PROBE_ADDRESS, 0);
        }

        Target = (PCHAR)Address;
        WriteNoFence8(Target, ReadNoFence8(Target));
        if (Size > Alignment) {
            Target += (Size - 1) & ~(SIZE_T)(Alignment - 1);
            WriteNoFence8(Target, ReadNoFence8(Target));
        }

#endif

    }
}

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
__analysis_noreturn
NTSTATUS
ExRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_ ULONG UnicodeStringParameterMask,
    _In_reads_opt_(NumberOfParameters) PULONG_PTR Parameters,
    _In_ ULONG ValidResponseOptions,
    _Out_ PULONG Response
    );

_IRQL_requires_max_(APC_LEVEL)
int
ExSystemExceptionFilter(
    VOID
    );

NTKERNELAPI
VOID
ExGetCurrentProcessorCpuUsage(
    _Out_ PULONG CpuUsage
    );

NTKERNELAPI
VOID
ExGetCurrentProcessorCounts(
    _Out_ PULONG IdleCount,
    _Out_ PULONG KernelAndUser,
    _Out_ PULONG Index
    );


//
// Set timer resolution.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
ULONG
ExSetTimerResolution (
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution
    );

#endif

//
// Query timer resolution.
//

#if (NTDDI_VERSION >= NTDDI_WIN8)

NTKERNELAPI
VOID
ExQueryTimerResolution (
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime
    );

#endif

//
// Subtract time zone bias from system time to get local time.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
ExSystemTimeToLocalTime (
    _In_ PLARGE_INTEGER SystemTime,
    _Out_ PLARGE_INTEGER LocalTime
    );

#endif

//
// Add time zone bias to local time to get system time.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTKERNELAPI
VOID
ExLocalTimeToSystemTime (
    _In_ PLARGE_INTEGER LocalTime,
    _Out_ PLARGE_INTEGER SystemTime
    );

#endif


typedef struct _EX_TIMER *PEX_TIMER;

_Function_class_(EXT_CALLBACK)
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
VOID
EXT_CALLBACK (
    _In_ PEX_TIMER Timer,
    _In_opt_ PVOID Context
    );

typedef EXT_CALLBACK *PEXT_CALLBACK;

_Function_class_(EXT_DELETE_CALLBACK)
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
VOID
EXT_DELETE_CALLBACK (
    _In_opt_ PVOID Context
    );

typedef EXT_DELETE_CALLBACK *PEXT_DELETE_CALLBACK;
typedef PVOID PEXT_CANCEL_PARAMETERS;
typedef struct _EXT_DELETE_PARAMETERS {
    ULONG Version;
    ULONG Reserved;
    PEXT_DELETE_CALLBACK DeleteCallback;
    PVOID DeleteContext;
} EXT_DELETE_PARAMETERS, *PEXT_DELETE_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

#define EX_TIMER_HIGH_RESOLUTION 0x4
#define EX_TIMER_NO_WAKE 0x8
#define EX_TIMER_UNLIMITED_TOLERANCE ((LONGLONG)-1)
#define EX_TIMER_NOTIFICATION (1UL << 31)

NTKERNELAPI
PEX_TIMER
ExAllocateTimer (
    _In_opt_ PEXT_CALLBACK Callback,
    _In_opt_ PVOID CallbackContext,
    _In_ ULONG Attributes
    );

NTKERNELAPI
BOOLEAN
ExSetTimer (
    _In_ PEX_TIMER Timer,
    _In_ LONGLONG DueTime,
    _In_ LONGLONG Period,
    _In_opt_ PEXT_SET_PARAMETERS Parameters
    );

NTKERNELAPI
BOOLEAN
ExCancelTimer (
    _Inout_ PEX_TIMER Timer,
    _In_opt_ PEXT_CANCEL_PARAMETERS Parameters
    );

NTKERNELAPI
BOOLEAN
ExDeleteTimer (
    _In_ PEX_TIMER Timer,
    _In_ BOOLEAN Cancel,
    _In_ BOOLEAN Wait,
    _In_opt_ PEXT_DELETE_PARAMETERS Parameters
    );

FORCEINLINE
VOID
ExInitializeSetTimerParameters (
    _Out_ PEXT_SET_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine initializes extended set timer parameters.

    N.B. This routine is inlined so that a driver that is built
         to use one version of the parameters structure
         will always set the structure's version parameter to that version.
         A downlevel driver will set the version parameter to the
         appropriate, downlevel version.

Arguments:

    Parameters - Supplies the parameters to be initialized.

Return Value:

    None.

--*/

{

    KeInitializeTimer2SetParameters(Parameters);
    return;
}

FORCEINLINE
VOID
ExInitializeDeleteTimerParameters (
    _Out_ PEXT_DELETE_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine initializes extended delete timer parameters.

    N.B. This routine is inlined so that a driver that is built
         to use one version of the parameters structure
         will always set the structure's version parameter to that version.
         A downlevel driver will set the version parameter to the
         appropriate, downlevel version.

Arguments:

    Parameters - Supplies the parameters to be initialized.

Return Value:

    None.

--*/

{

    RtlZeroMemory(Parameters, sizeof(*Parameters));

    NT_ASSERT(Parameters->Version == 0);

    return;
}

// end_wdm

#define EX_TIMER_IDLE_RESILIENT 0x2

NTKERNELAPI
PEX_TIMER
ExAllocateTimerInternal (
    _In_ PEXT_CALLBACK Callback,
    _In_opt_ PVOID CallbackContext,
    _When_(((_Curr_ & EX_TIMER_IDLE_RESILIENT) != 0),
            __drv_reportError("Use of EX_TIMER_IDLE_RESILIENT is"
                              " strictly restricted."))
    _In_ ULONG Attributes
    );


#endif


//
// Define the type for Callback function.
//

typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

typedef
_IRQL_requires_same_
_Function_class_(CALLBACK_FUNCTION)
VOID
CALLBACK_FUNCTION (
    _In_opt_ PVOID CallbackContext,
    _In_opt_ PVOID Argument1,
    _In_opt_ PVOID Argument2
    );

typedef CALLBACK_FUNCTION *PCALLBACK_FUNCTION;


#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
ExCreateCallback (
    _Outptr_ PCALLBACK_OBJECT *CallbackObject,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN Create,
    _In_ BOOLEAN AllowMultipleCallbacks
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
ExRegisterCallback (
    _Inout_ PCALLBACK_OBJECT CallbackObject,
    _In_ PCALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID CallbackContext
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExUnregisterCallback (
    _Inout_ PVOID CallbackRegistration
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExNotifyCallback (
    _In_ PVOID CallbackObject,
    _In_opt_ PVOID Argument1,
    _In_opt_ PVOID Argument2
    );

#endif


typedef
_IRQL_requires_same_
_Function_class_(WIN32_GLOBALATOMTABLE_CALLOUT)
PVOID
WIN32_GLOBALATOMTABLE_CALLOUT (
    VOID
    );

typedef WIN32_GLOBALATOMTABLE_CALLOUT *PKWIN32_GLOBALATOMTABLE_CALLOUT;

extern PKWIN32_GLOBALATOMTABLE_CALLOUT ExGlobalAtomTableCallout;


//
// UUID Generation
//

typedef GUID UUID;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
ExUuidCreate(
    _Out_ UUID *Uuid
    );

#endif


//
//  Rundown Locks
//

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
VOID
FASTCALL
ExInitializeRundownProtection (
    _Out_ PEX_RUNDOWN_REF RunRef
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtection (
    _Inout_ PEX_RUNDOWN_REF RunRef
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

_Must_inspect_result_
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtection (
    _Inout_ PEX_RUNDOWN_REF RunRef
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP2 || NTDDI_VERSION >= NTDDI_WS03)

_Must_inspect_result_
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx (
    _Inout_ PEX_RUNDOWN_REF RunRef,
    _In_ ULONG Count
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtection (
    _Inout_ PEX_RUNDOWN_REF RunRef
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP2 || NTDDI_VERSION >= NTDDI_WS03)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx (
    _Inout_ PEX_RUNDOWN_REF RunRef,
    _In_ ULONG Count
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

NTKERNELAPI
VOID
FASTCALL
ExRundownCompleted (
    _Out_ PEX_RUNDOWN_REF RunRef
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionRelease (
    _Inout_ PEX_RUNDOWN_REF RunRef
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PEX_RUNDOWN_REF_CACHE_AWARE
ExAllocateCacheAwareRundownProtection(
    __drv_strictTypeMatch(__drv_typeExpr) _In_ POOL_TYPE PoolType,
    _In_ ULONG PoolTag
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
SIZE_T
ExSizeOfRundownProtectionCacheAware(
    VOID
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExInitializeRundownProtectionCacheAware(
    _Out_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
    _In_ SIZE_T RunRefSize
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExFreeCacheAwareRundownProtection(
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

_Must_inspect_result_
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAware (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAware (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

_Must_inspect_result_
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAwareEx (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
    _In_ ULONG Count
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAwareEx (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRef,
    _In_ ULONG Count
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionReleaseCacheAware (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRef
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtectionCacheAware (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
VOID
FASTCALL
ExRundownCompletedCacheAware (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );

#endif

//
// TODO: t-chrisk - Need to update this to the Blue + 1 constant once available.
//

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

#define EX_CARR_ALLOCATE_PAGED_POOL         0x00000000
#define EX_CARR_ALLOCATE_NONPAGED_POOL      0x00000001

#define EX_CARR_DISABLE_EXPANSION           0x00000002

#define EX_CARR_VALID_FLAGS                 (EX_CARR_ALLOCATE_NONPAGED_POOL | \
                                             EX_CARR_DISABLE_EXPANSION)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExInitializeRundownProtectionCacheAwareEx (
    _Out_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
    _In_ ULONG Flags
    );

#endif

//
// TODO: t-chrisk - Need to update this to the Blue + 1 constant once available.
//

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExCleanupRundownProtectionCacheAware (
    _Inout_ PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );

#endif


#if !defined(NONTOSPINTERLOCK)

#pragma warning (push)
#pragma warning (disable:4028) // parameter mismatch: intentional type change

FORCEINLINE
VOID
ExInitializePushLock (
    _Out_ PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Initialize a push lock structure

Arguments:

    PushLock - Push lock to be initialized

Return Value:

    None

--*/

{

    PushLock->Value = 0;
}

#pragma warning (pop)

#if defined(_WIN64)

#define EX_TRY_ACQUIRE_PUSH_LOCK_EXCLUSIVE_OP(PUSHLOCK) \
    InterlockedBitTestAndSet64Acquire((LONG64 *)&(PUSHLOCK)->Value, EX_PUSH_LOCK_LOCK_V)

#else

#define EX_TRY_ACQUIRE_PUSH_LOCK_EXCLUSIVE_OP(PUSHLOCK) \
    InterlockedBitTestAndSetAcquire((LONG *)&(PUSHLOCK)->Value, EX_PUSH_LOCK_LOCK_V)

#endif

#endif  // // !defined(NONTOSPINTERLOCK)

#if !defined(NONTOSPINTERLOCK)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    );

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
VOID
FASTCALL
ExfAcquirePushLockShared (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExfReleasePushLock (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExfReleasePushLockShared (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExfReleasePushLockExclusive (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    );

_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExfTryAcquirePushLockShared (
    _Inout_ _Requires_lock_not_held_(*_Curr_)
    _When_(return==1, _Acquires_lock_(*_Curr_))
    PEX_PUSH_LOCK PushLock
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExfTryToWakePushLock (
    _Inout_ PEX_PUSH_LOCK PushLock
    );


#define ExAcquirePushLockSharedAssumeNoOwner ExAcquirePushLockShared
#define ExReleasePushLockSharedAssumeSingleOwner ExReleasePushLockShared

#if !defined(EX_LEGACY_PUSH_LOCKS)

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExAcquirePushLockExclusiveEx (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExAcquirePushLockSharedEx (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExTryAcquirePushLockExclusiveEx (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
    _Inout_ PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExTryAcquirePushLockSharedEx (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
    _Inout_ PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleasePushLockEx (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleasePushLockExclusiveEx (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleasePushLockSharedEx (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExTryConvertPushLockSharedToExclusiveEx (
    _Inout_ _Requires_lock_held_(*_Curr_)
    PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

#undef EX_DEFAULT_PUSH_LOCK_FLAGS

#if !defined(AB_TRACKING_DISABLED)
#define EX_DEFAULT_PUSH_LOCK_FLAGS      0
#else
#define EX_DEFAULT_PUSH_LOCK_FLAGS      EX_PUSH_LOCK_FLAG_DISABLE_AUTOBOOST
#endif // !defined(AB_TRACKING_DISABLED)

#define ExAcquirePushLockExclusive(Lock)   \
        ExAcquirePushLockExclusiveEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExAcquirePushLockShared(Lock)   \
        ExAcquirePushLockSharedEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExTryAcquirePushLockExclusive(Lock) \
        ExTryAcquirePushLockExclusiveEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExTryAcquirePushLockShared(Lock) \
        ExTryAcquirePushLockSharedEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExReleasePushLock(Lock) \
        ExReleasePushLockEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExReleasePushLockExclusive(Lock) \
        ExReleasePushLockExclusiveEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExReleasePushLockShared(Lock) \
        ExReleasePushLockSharedEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExTryConvertPushLockSharedToExclusive(Lock) \
        ExTryConvertPushLockSharedToExclusiveEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#else // EX_LEGACY_PUSH_LOCKS

#pragma warning (push)
#pragma prefast(disable: __WARNING_FAILING_TO_ACQUIRE_MEDIUM_CONFIDENCE, "Prefast doesn't know that the success return from InterlockedCompareExchange in the ExAcquire* functions here actually acquires the pushlock.");

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
FORCEINLINE
VOID
ExAcquirePushLockExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/

{

    if (EX_TRY_ACQUIRE_PUSH_LOCK_EXCLUSIVE_OP(PushLock)) {

        ExfAcquirePushLockExclusive(PushLock);
    }

    NT_ASSERT(PushLock->Locked);

    return;
}

_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_Post_satisfies_(return == 0 || return == 1)
CFORCEINLINE
BOOLEAN
ExTryAcquirePushLockExclusive (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
    _Inout_ PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Try and acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    BOOLEAN - TRUE: Acquire was successful, FALSE: Lock was already acquired

--*/

{

    if (!EX_TRY_ACQUIRE_PUSH_LOCK_EXCLUSIVE_OP(PushLock)) {

        NT_ASSERT(PushLock->Locked);

        return TRUE;

    } else {

        return FALSE;

    }
}

_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_Post_satisfies_(return == 0 || return == 1)
FORCEINLINE
BOOLEAN
ExTryAcquirePushLockShared (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
    _Inout_ PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Try to Acquire a push lock shared.

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    BOOLEAN - TRUE: Acquire was successful, FALSE: Lock was already acquired exclusively.

--*/

{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue.Value = 0;
    NewValue.Value = EX_PUSH_LOCK_SHARE_INC | EX_PUSH_LOCK_LOCK;

    if (InterlockedCompareExchangePointerAcquire(&PushLock->Ptr,
                                                 NewValue.Ptr,
                                                 OldValue.Ptr) != OldValue.Ptr) {

        if (!ExfTryAcquirePushLockShared(PushLock)) {
            return FALSE;
        }
    }

#if DBG

    OldValue.Ptr = ReadPointerNoFence(&PushLock->Ptr);

    NT_ASSERT(OldValue.Locked);

    NT_ASSERT(OldValue.Waiting || OldValue.Shared > 0);

#endif

    return TRUE;
}

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
FORCEINLINE
VOID
ExAcquirePushLockShared (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Acquire a push lock shared with AutoBoost tracking enabled.

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/

{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue.Value = 0;
    NewValue.Value = EX_PUSH_LOCK_SHARE_INC | EX_PUSH_LOCK_LOCK;
    if (InterlockedCompareExchangePointerAcquire(&PushLock->Ptr,
                                                 NewValue.Ptr,
                                                 OldValue.Ptr) != OldValue.Ptr) {

        ExfAcquirePushLockShared(PushLock);
    }

#if DBG

    OldValue.Ptr = ReadPointerNoFence(&PushLock->Ptr);

    NT_ASSERT(OldValue.Locked);

    NT_ASSERT(OldValue.Waiting || OldValue.Shared > 0);

#endif

    return;
}

#pragma warning (pop)

#pragma warning (push)
#pragma prefast(disable: __WARNING_FAILING_TO_RELEASE_MEDIUM_CONFIDENCE, "Prefast doesn't know that the success return from InterlockedCompareExchange in the ExRelease* functions here actually releases the pushlock.");

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
FORCEINLINE
VOID
ExReleasePushLock (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Release a push lock that was acquired exclusively or shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/

{

    EX_PUSH_LOCK OldValue, NewValue;

    PrefetchForWrite(PushLock);
    OldValue.Ptr = ReadPointerNoFence(&PushLock->Ptr);

    NT_ASSERT(OldValue.Locked);

    if (OldValue.Shared > 1) {
        NewValue.Value = OldValue.Value - EX_PUSH_LOCK_SHARE_INC;

    } else {
        NewValue.Value = 0;
    }

    if (OldValue.Waiting ||
        InterlockedCompareExchangePointerRelease(&PushLock->Ptr,
                                                 NewValue.Ptr,
                                                 OldValue.Ptr) != OldValue.Ptr) {

        ExfReleasePushLock(PushLock);
    }

    return;
}

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
FORCEINLINE
VOID
ExReleasePushLockExclusive (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Release a push lock that was acquired exclusively

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/

{

    EX_PUSH_LOCK OldValue;

#if DBG

    PrefetchForWrite(PushLock);
    OldValue.Ptr = ReadPointerNoFence(&PushLock->Ptr);

    NT_ASSERT(OldValue.Locked);

    NT_ASSERT(OldValue.Waiting || OldValue.Shared == 0);

#endif

#if defined(_WIN64)

    OldValue.Value = InterlockedExchangeAddRelease64((PLONG64)&PushLock->Value, -(LONG64)EX_PUSH_LOCK_LOCK);

#else

    OldValue.Value = InterlockedExchangeAddRelease((PLONG)&PushLock->Value, -(LONG)EX_PUSH_LOCK_LOCK);

#endif

    _Analysis_assume_lock_held_ (PushLock);
    _Analysis_assume_lock_released_ (PushLock);

    NT_ASSERT(OldValue.Locked);

    NT_ASSERT(OldValue.Waiting || OldValue.Shared == 0);

    if (!OldValue.Waiting || OldValue.Waking) {
        return;
    }

    ExfTryToWakePushLock(PushLock);
    return;
}

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
FORCEINLINE
VOID
ExReleasePushLockShared (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Release a push lock that was acquired shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/

{

    EX_PUSH_LOCK OldValue, NewValue;

#if DBG

    PrefetchForWrite(PushLock);
    OldValue.Ptr = ReadPointerNoFence(&PushLock->Ptr);

    NT_ASSERT(OldValue.Locked);

    NT_ASSERT(OldValue.Waiting || OldValue.Shared > 0);

#endif

    OldValue.Value = EX_PUSH_LOCK_SHARE_INC | EX_PUSH_LOCK_LOCK;
    NewValue.Value = 0;
    if (InterlockedCompareExchangePointerRelease(&PushLock->Ptr,
                                                 NewValue.Ptr,
                                                 OldValue.Ptr) != OldValue.Ptr) {

        ExfReleasePushLockShared(PushLock);

    } else {
        _Analysis_assume_lock_held_ (PushLock);
        _Analysis_assume_lock_released_ (PushLock);
    }

    return;
}

#pragma warning (pop)

_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
_Post_satisfies_(return == 0 || return == 1)
FORCEINLINE
BOOLEAN
ExTryConvertPushLockSharedToExclusive (
    _Inout_ _Requires_lock_held_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Attempts to convert a shared acquire to exclusive. If other sharers or waiters are present
    the function fails.

Arguments:

    PushLock - Push lock to be converted

Return Value:

    BOOLEAN - TRUE: Conversion worked ok, FALSE: The conversion could not be achieved

--*/

{

    if (InterlockedCompareExchangePointer(&PushLock->Ptr,
                                          (PVOID) EX_PUSH_LOCK_LOCK,
                                          (PVOID) (EX_PUSH_LOCK_SHARE_INC | EX_PUSH_LOCK_LOCK)) ==
                                            (PVOID)(EX_PUSH_LOCK_SHARE_INC | EX_PUSH_LOCK_LOCK)) {

        NT_ASSERT(PushLock->Locked);

        return TRUE;

    } else {
        return FALSE;
    }
}

#endif // !EX_LEGACY_PUSH_LOCKS

//
// ISSUE-for-govm-:  Define to Blue+1 once constant is available.
//

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

//
// As of Blue + 1 the Auto-Expand push lock is available.
//

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PEX_PUSH_LOCK_AUTO_EXPAND
ExAllocateAutoExpandPushLock (
     _In_ ULONG Flags
     );

#define EX_AEPL_ALLOCATE_PAGED_POOL       0x00000000
#define EX_AEPL_ALLOCATE_NONPAGED_POOL    0x00000001

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExFreeAutoExpandPushLock (
     _Inout_ PEX_PUSH_LOCK_AUTO_EXPAND PushLock
     );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExAcquireAutoExpandPushLockExclusive (
    _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    _Inout_ PEX_PUSH_LOCK_AUTO_EXPAND AutoExpandPushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExReleaseAutoExpandPushLockExclusive (
    _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    _Inout_ PEX_PUSH_LOCK_AUTO_EXPAND AutoExpandPushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
PVOID
FASTCALL
ExAcquireAutoExpandPushLockShared (
    _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    _Inout_ PEX_PUSH_LOCK_AUTO_EXPAND AutoExpandPushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleaseAutoExpandPushLockShared (
    _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    _Inout_ PVOID PushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExInitializeAutoExpandPushLock (
    _Out_ PEX_PUSH_LOCK_AUTO_EXPAND AutoExpandPushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
SIZE_T
ExSizeOfAutoExpandPushLock (
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExCleanupAutoExpandPushLock (
    _Inout_ PEX_PUSH_LOCK_AUTO_EXPAND AutoExpandPushLock
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
FASTCALL
ExTryAcquireAutoExpandPushLockExclusive (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
     _Inout_ PEX_PUSH_LOCK_AUTO_EXPAND AutoExpandPushLock,
     _In_ ULONG Flags
     );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
FASTCALL
ExTryAcquireAutoExpandPushLockShared (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
    _Inout_ PEX_PUSH_LOCK_AUTO_EXPAND AutoExpandPushLock,
    _In_ ULONG Flags
    );

#endif

#if defined(EX_LEGACY_PUSH_LOCKS)

//
// If we are using legacy push locks then shared acquire/release functions for
// cache-aware push locks are force-inlined.
//

#pragma warning (push)
#pragma prefast(disable: __WARNING_NEED_LOCKING_SIDE_EFFECT, "Prefast doesn't know that acquiring any processor's pushlock shared provides the equivalent semantic for obtaining the argument pushlock shared.");

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
FORCEINLINE
PEX_PUSH_LOCK
ExAcquireCacheAwarePushLockShared (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE_LEGACY CacheAwarePushLock
    )

/*++

Routine Description:

    Acquire a cache aware push lock shared.

Arguments:

    PushLock - Cache aware push lock to be acquired

Return Value:

    None

--*/

{

    PEX_PUSH_LOCK PushLock;
    ULONG ProcIndex;

    //
    // Take a single one of the slots in shared mode.
    // Exclusive acquires must obtain all the slots exclusive.
    //

#if (NTDDI_VERSION >= NTDDI_WIN7)

    ProcIndex = KeGetCurrentProcessorNumberEx(NULL);

#else

    ProcIndex = KeGetCurrentProcessorNumber();

#endif

    PushLock = CacheAwarePushLock->Locks[ProcIndex % EX_PUSH_LOCK_FANNED_COUNT];
    ExAcquirePushLockSharedAssumeNoOwner(PushLock);
    return PushLock;
}

#pragma warning (pop)

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
FORCEINLINE
VOID
ExReleaseCacheAwarePushLockShared (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock
    )

/*++

Routine Description:

    Release a cache aware push lock that was acquired shared.

Arguments:

    PushLock - Part of cache aware push lock returned by ExAcquireCacheAwarePushLockShared

Return Value:

    None

--*/

{

    ExReleasePushLockSharedAssumeSingleOwner(PushLock);
    return;
}

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PEX_PUSH_LOCK_CACHE_AWARE
ExAllocateCacheAwarePushLock (
     _In_ ULONG Flags
     );

#define EX_CAPLFL_ALLOCATE_PAGED_POOL       0x00000000
#define EX_CAPLFL_ALLOCATE_NONPAGED_POOL    0x00000001

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExFreeCacheAwarePushLock (
     _Inout_ PEX_PUSH_LOCK_CACHE_AWARE_LEGACY PushLock
     );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExAcquireCacheAwarePushLockExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE_LEGACY CacheAwarePushLock
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExReleaseCacheAwarePushLockExclusive (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE_LEGACY CacheAwarePushLock
    );

//
// TODO: t-chrisk - This check should be == NTDDI_WINBLUE once the Blue + 1
//                  constants have been defined.
//

#elif ((NTDDI_VERSION < NTDDI_WINBLUE) || defined(EX_LEGACY_CACHE_AWARE_LOCKS)) // EX_LEGACY_PUSH_LOCKS

//
// If we are compiling for WINBLUE or earlier then the cache-aware push lock
// functions should be used.
//

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PEX_PUSH_LOCK_CACHE_AWARE_LEGACY
ExAllocateCacheAwarePushLock (
     _In_ ULONG Flags
     );

#define EX_CAPLFL_ALLOCATE_PAGED_POOL       0x00000000
#define EX_CAPLFL_ALLOCATE_NONPAGED_POOL    0x00000001

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExFreeCacheAwarePushLock (
     _Inout_ PEX_PUSH_LOCK_CACHE_AWARE_LEGACY PushLock
     );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExAcquireCacheAwarePushLockExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExReleaseCacheAwarePushLockExclusive (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExAcquireCacheAwarePushLockExclusiveEx (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE_LEGACY CacheAwarePushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FASTCALL
ExReleaseCacheAwarePushLockExclusiveEx (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE_LEGACY CacheAwarePushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
PEX_PUSH_LOCK
FASTCALL
ExAcquireCacheAwarePushLockSharedEx (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_PUSH_LOCK_CACHE_AWARE_LEGACY CacheAwarePushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
_Requires_lock_held_(_Global_critical_region_)
NTKERNELAPI
VOID
FASTCALL
ExReleaseCacheAwarePushLockSharedEx (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_PUSH_LOCK PushLock,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
FASTCALL
ExTryAcquireCacheAwarePushLockExclusiveEx (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
     _Inout_ PEX_PUSH_LOCK_CACHE_AWARE_LEGACY AutoExpandPushLock,
     _In_ ULONG Flags
     );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
FASTCALL
ExTryAcquireCacheAwarePushLockSharedEx (
    _When_(return!=0, _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_))
    _Inout_ PEX_PUSH_LOCK_CACHE_AWARE_LEGACY AutoExpandPushLock,
    _In_ ULONG Flags
    );

#define ExAcquireCacheAwarePushLockShared(Lock) \
        ExAcquireCacheAwarePushLockSharedEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExReleaseCacheAwarePushLockShared(Lock) \
        ExReleaseCacheAwarePushLockSharedEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#else // !EX_LEGACY_PUSHLOCKS && (NTDDI_VERSION <= NTDDI_WINBLUE)

//
// If we are compiling for Blue + 1 or later, the cache-aware push lock should
// be replaced by the auto-expand push lock, so we will not define its functions
// and instead redirect the function calls to the corresponding auto-expand
// push lock apis.
//


#define EX_CAPLFL_ALLOCATE_PAGED_POOL       0x00000000
#define EX_CAPLFL_ALLOCATE_NONPAGED_POOL    0x00000001

#define ExAllocateCacheAwarePushLock(Flags) \
        ExAllocateAutoExpandPushLock(Flags)

#define ExFreeCacheAwarePushLock(Lock) \
        ExFreeAutoExpandPushLock(Lock)

#define ExAcquireCacheAwarePushLockShared(Lock) \
        ExAcquireAutoExpandPushLockShared(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExReleaseCacheAwarePushLockShared(Lock) \
        ExReleaseAutoExpandPushLockShared(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExAcquireCacheAwarePushLockSharedEx(Lock, Flags) \
        ExAcquireAutoExpandPushLockShared(Lock, Flags)

#define ExReleaseCacheAwarePushLockSharedEx(Lock, Flags) \
        ExReleaseAutoExpandPushLockShared(Lock, Flags)

#define ExAcquireCacheAwarePushLockExclusive(Lock) \
        ExAcquireAutoExpandPushLockExclusive(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExReleaseCacheAwarePushLockExclusive(Lock) \
        ExReleaseAutoExpandPushLockExclusive(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExAcquireCacheAwarePushLockExclusiveEx(Lock, Flags) \
        ExAcquireAutoExpandPushLockExclusive(Lock, Flags)

#define ExReleaseCacheAwarePushLockExclusiveEx(Lock, Flags) \
        ExReleaseAutoExpandPushlockExclusive(Lock, Flags)

#define ExTryAcquireCacheAwarePushLockExclusive(Lock) \
        ExTryAcquireAutoExpandPushLockExclusive(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExTryAcquireCacheAwarePushLockShared(Lock) \
        ExTryAcquireAutoExpandPushLockShared(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExTryAcquireCacheAwarePushLockExclusiveEx(Lock, Flags) \
        ExTryAcquireAutoExpandPushLockExclusive(Lock, Flags)

#define ExTryAcquireCacheAwarePushLockSharedEx(Lock, Flags) \
        ExTryAcquireAutoExpandPushLockShared(Lock, Flags)

#endif // !EX_LEGACY_PUSHLOCKS && (NTDDI_VERSION > NTDDI_WINBLUE)


#define EX_AEPL_ALLOCATE_PAGED_POOL        0x00000000
#define EX_AEPL_ALLOCATE_NONPAGED_POOL     0x00000001

#endif // !defined(NONTOSPINTERLOCK)


#if !defined(NONTOSPINTERLOCK)

NTKERNELAPI
NTSTATUS
FASTCALL
ExBlockOnAddressPushLock (
     _Inout_ PEX_PUSH_LOCK PushLock,
     _In_reads_bytes_(AddressSize) volatile VOID *Address,
     _In_reads_bytes_(AddressSize) PVOID CompareAddress,
     _In_ SIZE_T AddressSize,
     _In_opt_ PLARGE_INTEGER Timeout
     );

NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock (
     _Inout_ PEX_PUSH_LOCK PushLock,
     _Inout_opt_ PVOID WaitBlock
     );

#if !defined(EX_LEGACY_PUSH_LOCKS)

NTKERNELAPI
VOID
FASTCALL
ExUnblockPushLockEx (
     _Inout_ PEX_PUSH_LOCK PushLock,
     _In_ ULONG Flags
     );

NTKERNELAPI
VOID
FASTCALL
ExUnblockOnAddressPushLockEx (
     _Inout_ PEX_PUSH_LOCK PushLock,
     _In_ ULONG Flags
     );

#define ExUnblockPushLock(Lock) \
        ExUnblockPushLockEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#define ExUnblockOnAddressPushLock(Lock) \
        ExUnblockOnAddressPushLockEx(Lock, EX_DEFAULT_PUSH_LOCK_FLAGS)

#else // !defined(EX_LEGACY_PUSH_LOCKS)

FORCEINLINE
NTKERNELAPI
VOID
ExUnblockPushLock (
     _Inout_ PEX_PUSH_LOCK PushLock
     )

{

    KeMemoryBarrier ();
    if (PushLock->Ptr != NULL) {
        ExfUnblockPushLock (PushLock, NULL);
    }

    return;
}

FORCEINLINE
NTKERNELAPI
VOID
ExUnblockOnAddressPushLock (
     _Inout_ PEX_PUSH_LOCK PushLock
     )

{

    ExUnblockPushLock (PushLock);
    return;
}

#endif // !defined(EX_LEGACY_PUSH_LOCKS)


#endif // !defined(NONTOSPINTERLOCK)


#if (NTDDI_VERSION >= NTDDI_WINBLUE)

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
ExShareAddressSpaceWithDevice (
    _In_ struct _DEVICE_OBJECT *PhysicalDeviceObject,
    _Out_ PULONG ReturnedAsid
    );

#endif

// begin_wdm

//
// Define shared spinlock type and function prototypes.
//

typedef volatile LONG EX_SPIN_LOCK, *PEX_SPIN_LOCK;
#define ALIGNED_EX_SPINLOCK DECLSPEC_CACHEALIGN EX_SPIN_LOCK

#if (NTDDI_VERSION >= NTDDI_VISTASP1)

_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExAcquireSpinLockSharedAtDpcLevel (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock
    );

_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
NTKERNELAPI
KIRQL
ExAcquireSpinLockShared (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock
    );

_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExReleaseSpinLockSharedFromDpcLevel (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock
    );

_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExReleaseSpinLockShared (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock,
    _In_ _IRQL_restores_ KIRQL OldIrql
    );

_Must_inspect_result_
_IRQL_requires_(DISPATCH_LEVEL)
_Post_satisfies_(return == 0 || return == 1)
NTKERNELAPI
LOGICAL
ExTryConvertSharedSpinLockExclusive (
    _Inout_ PEX_SPIN_LOCK SpinLock
    );

_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExAcquireSpinLockExclusiveAtDpcLevel (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock
    );

_IRQL_saves_
_IRQL_raises_(DISPATCH_LEVEL)
NTKERNELAPI
KIRQL
ExAcquireSpinLockExclusive (
    _Inout_ _Requires_lock_not_held_(*_Curr_) _Acquires_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock
    );

_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExReleaseSpinLockExclusiveFromDpcLevel (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock
    );

_IRQL_requires_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
ExReleaseSpinLockExclusive (
    _Inout_ _Requires_lock_held_(*_Curr_) _Releases_lock_(*_Curr_)
    PEX_SPIN_LOCK SpinLock,
    _In_ _IRQL_restores_ KIRQL OldIrql
    );

#endif //#if (NTDDI_VERSION >= NTDDI_VISTASP1)

// begin_wdm

//
// Define a block to hold the actual routine registration.
//

typedef
_IRQL_requires_same_
_Function_class_(EX_CALLBACK_FUNCTION)
NTSTATUS
EX_CALLBACK_FUNCTION (
    _In_ PVOID CallbackContext,
    _In_opt_ PVOID Argument1,
    _In_opt_ PVOID Argument2
    );

typedef EX_CALLBACK_FUNCTION *PEX_CALLBACK_FUNCTION;

// end_wdm

//
// Licensing tamper states
//

typedef enum _LICENSING_TAMPER_STATE {
    LicensingTamperNone,
    LicensingTamperTrustedStore,
    LicensingTamperServiceStopped,
    LicensingTamperModuleAuthentication,
    LicensingTamperCacheData,
    LicensingTamperOther
} LICENSING_TAMPER_STATE, *PLICENSING_TAMPER_STATE;

//
// Licensing interfaces
//

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
ExUpdateLicenseData(
    _In_ ULONG MemCacheDataSize,
    _In_reads_bytes_(MemCacheDataSize) PVOID MemCacheData
    );


_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ExSetLicenseTamperState(
    _In_ LICENSING_TAMPER_STATE LicensingTamperState
    );

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
ExGetLicenseTamperState(
    _Out_opt_ PLICENSING_TAMPER_STATE LicensingTamperState
    );

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
ExFetchLicenseData(
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize
    );

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
ExHandleSPCall2(
    _In_ KPROCESSOR_MODE PreviousMode,
    _In_ volatile SYSTEM_POLICY_INFORMATION* SPCall2Information
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
ExQueryFastCacheDevLicense(
    VOID
    );

//
// Note: This enum corresponds to WS_APP_ORIGIN
//

enum {
    FAST_CACHE_APP_ORIGIN_UNKNOWN        = 0,
    FAST_CACHE_APP_ORIGIN_UNSIGNED,
    FAST_CACHE_APP_ORIGIN_INBOX,
    FAST_CACHE_APP_ORIGIN_APP_STORE,
    FAST_CACHE_APP_ORIGIN_DEV_UNSIGNED,
    FAST_CACHE_APP_ORIGIN_DEV_SIGNED,
    FAST_CACHE_APP_ORIGIN_LINE_OF_BUSINESS
};

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
ExQueryFastCacheAppOrigin(
    _In_ PUNICODE_STRING PackageFullName,
    _Out_ ULONG* AppOrigin
    );

// begin_ntosifs

#define EX_PCW_EXTENSION_ID              1
#define EX_AUTH_EXTENSION_ID             2
#define EX_BCRYPT_EXTENSION_ID           3
#define EX_NET_RATE_CONTROL_EXTENSION_ID 4
#define EX_IO_QOS_EXTENSION_ID           5

#define EX_PCW_EXTENSION_VERSION              1
#define EX_AUTH_EXTENSION_VERSION             1
#define EX_BCRYPT_EXTENSION_VERSION           1
#define EX_NET_RATE_CONTROL_EXTENSION_VERSION 1
#define EX_IO_QOS_EXTENSION_VERSION           1

typedef struct _EX_EXTENSION *PEX_EXTENSION;

typedef struct _EX_EXTENSION_REGISTRATION_1 {

    //
    // Identifier and version of this extension.
    //

    USHORT ExtensionId;
    USHORT ExtensionVersion;

    //
    // Number of functions present in the function table.
    //

    USHORT FunctionCount;

    //
    // Pointer to table of functions supplied by this extension.
    //

    const VOID *FunctionTable;

    //
    // Optional pointer that will receive the function table supplied by the
    // host.
    //

    PVOID *HostTable;

    //
    // Pointer to the driver object that is registering extension.
    //

    PVOID DriverObject;
} EX_EXTENSION_REGISTRATION_1, *PEX_EXTENSION_REGISTRATION_1;

#define EX_EXTENSION_REGISTRATION_VERSION_1 0x10000

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
NTSTATUS
ExRegisterExtension (
    _Outptr_ PEX_EXTENSION *Extension,
    _In_ ULONG RegistrationVersion,
    _In_ PVOID RegistrationInfo
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
ExUnregisterExtension (
    _Inout_ PEX_EXTENSION Extension
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN8)

//
// External boot support data structures and routines
//

#define EX_BOOT_DEVICE_REGISTRATION_VERSION_1 1
#define EX_BOOT_DEVICE_REGISTRATION_VERSION EX_BOOT_DEVICE_REGISTRATION_VERSION_1

DECLARE_HANDLE(EX_BOOT_DEVICE_HANDLE);

typedef
BOOLEAN
(*PEX_IS_BOOT_DEVICE_READY) (
    _In_ struct _DEVICE_OBJECT *PhysicalDeviceObject,
    _In_opt_ PVOID Context);

typedef struct _EX_BOOT_DEVICE_REGISTRATION {
    ULONG Version;
    ULONG Flags; //reserved; must be 0
    struct _DRIVER_OBJECT *DriverObject; //mandatory
    struct _DEVICE_OBJECT *DeviceObject; //optional
    PEX_IS_BOOT_DEVICE_READY IsBootDeviceReady; //mandatory
    PVOID Context; //optional
} EX_BOOT_DEVICE_REGISTRATION, *PEX_BOOT_DEVICE_REGISTRATION;

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
ExRegisterBootDevice(
    _In_ PEX_BOOT_DEVICE_REGISTRATION Registration,
    _Out_ EX_BOOT_DEVICE_HANDLE *Handle);

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
ExNotifyBootDeviceRemoval(
    _In_ EX_BOOT_DEVICE_HANDLE Handle);


#endif //#if (NTDDI_VERSION >= NTDDI_WIN8)


//
// Define the structure of boot driver list.  If the load status is not a
// success status, then the no associated driver has been loaded into memory
// and the list entry is provided for informational purposes only.
//

#define LOAD_INFORMATION_IMAGE_HASH_INVALID           0x00000001
#define LOAD_INFORMATION_MALFORMED_DRIVER_PATH        0x00000002
#define LOAD_INFORMATION_IMPORT_LOAD_FAILED           0x00000004
#define LOAD_INFORMATION_EMBEDDED_SIGNED              0x00000008
#define LOAD_INFORMATION_CATALOG_SIGNED               0x00000010
#define LOAD_INFORMATION_POLICY_VIOLATION             0x00000020
#define LOAD_INFORMATION_IMAGE_BOOT_SCENARIO_AWARE    0x00000040
#define LOAD_INFORMATION_IMAGE_BOOT_SCENARIO_AGNOSTIC 0x00000080

typedef struct _BOOT_DRIVER_LIST_ENTRY {
    LIST_ENTRY Link;
    UNICODE_STRING FilePath;
    UNICODE_STRING RegistryPath;
    PBLDR_DATA_TABLE_ENTRY LdrEntry;
    NTSTATUS LoadStatus;
    ULONG LoadInformation;
} BOOT_DRIVER_LIST_ENTRY, *PBOOT_DRIVER_LIST_ENTRY;


//
// Registry kernel mode callbacks
//

//
// Hook selector
//
typedef enum _REG_NOTIFY_CLASS {
    RegNtDeleteKey,
    RegNtPreDeleteKey = RegNtDeleteKey,
    RegNtSetValueKey,
    RegNtPreSetValueKey = RegNtSetValueKey,
    RegNtDeleteValueKey,
    RegNtPreDeleteValueKey = RegNtDeleteValueKey,
    RegNtSetInformationKey,
    RegNtPreSetInformationKey = RegNtSetInformationKey,
    RegNtRenameKey,
    RegNtPreRenameKey = RegNtRenameKey,
    RegNtEnumerateKey,
    RegNtPreEnumerateKey = RegNtEnumerateKey,
    RegNtEnumerateValueKey,
    RegNtPreEnumerateValueKey = RegNtEnumerateValueKey,
    RegNtQueryKey,
    RegNtPreQueryKey = RegNtQueryKey,
    RegNtQueryValueKey,
    RegNtPreQueryValueKey = RegNtQueryValueKey,
    RegNtQueryMultipleValueKey,
    RegNtPreQueryMultipleValueKey = RegNtQueryMultipleValueKey,
    RegNtPreCreateKey,
    RegNtPostCreateKey,
    RegNtPreOpenKey,
    RegNtPostOpenKey,
    RegNtKeyHandleClose,
    RegNtPreKeyHandleClose = RegNtKeyHandleClose,
    //
    // .Net only
    //    
    RegNtPostDeleteKey,
    RegNtPostSetValueKey,
    RegNtPostDeleteValueKey,
    RegNtPostSetInformationKey,
    RegNtPostRenameKey,
    RegNtPostEnumerateKey,
    RegNtPostEnumerateValueKey,
    RegNtPostQueryKey,
    RegNtPostQueryValueKey,
    RegNtPostQueryMultipleValueKey,
    RegNtPostKeyHandleClose,
    RegNtPreCreateKeyEx,
    RegNtPostCreateKeyEx,
    RegNtPreOpenKeyEx,
    RegNtPostOpenKeyEx,
    //
    // new to Windows Vista
    //
    RegNtPreFlushKey,
    RegNtPostFlushKey,
    RegNtPreLoadKey,
    RegNtPostLoadKey,
    RegNtPreUnLoadKey,
    RegNtPostUnLoadKey,
    RegNtPreQueryKeySecurity,
    RegNtPostQueryKeySecurity,
    RegNtPreSetKeySecurity,
    RegNtPostSetKeySecurity,
    //
    // per-object context cleanup
    //
    RegNtCallbackObjectContextCleanup,
    //
    // new in Vista SP2 
    //
    RegNtPreRestoreKey,
    RegNtPostRestoreKey,
    RegNtPreSaveKey,
    RegNtPostSaveKey,
    RegNtPreReplaceKey,
    RegNtPostReplaceKey,
    //
    // new to Windows 10
    //
    RegNtPreQueryKeyName,
    RegNtPostQueryKeyName,

    MaxRegNtNotifyClass //should always be the last enum
} REG_NOTIFY_CLASS;

//
// Parameter description for each notify class
//
typedef struct _REG_DELETE_KEY_INFORMATION {
    PVOID    Object;                      // IN
    PVOID    CallContext;  // new to Windows Vista
    PVOID    ObjectContext;// new to Windows Vista
    PVOID    Reserved;     // new to Windows Vista
} REG_DELETE_KEY_INFORMATION, *PREG_DELETE_KEY_INFORMATION
#if (NTDDI_VERSION >= NTDDI_VISTA)
, REG_FLUSH_KEY_INFORMATION, *PREG_FLUSH_KEY_INFORMATION
#endif // NTDDI_VERSION >= NTDDI_VISTA
;

typedef struct _REG_SET_VALUE_KEY_INFORMATION {
    PVOID               Object;                         // IN
    PUNICODE_STRING     ValueName;                      // IN
    ULONG               TitleIndex;                     // IN
    ULONG               Type;                           // IN
    PVOID               Data;                           // IN
    ULONG               DataSize;                       // IN
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_SET_VALUE_KEY_INFORMATION, *PREG_SET_VALUE_KEY_INFORMATION;

typedef struct _REG_DELETE_VALUE_KEY_INFORMATION {
    PVOID               Object;                         // IN
    PUNICODE_STRING     ValueName;                      // IN
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_DELETE_VALUE_KEY_INFORMATION, *PREG_DELETE_VALUE_KEY_INFORMATION;

typedef struct _REG_SET_INFORMATION_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    KEY_SET_INFORMATION_CLASS   KeySetInformationClass; // IN
    PVOID                       KeySetInformation;      // IN
    ULONG                       KeySetInformationLength;// IN
    PVOID                       CallContext;  // new to Windows Vista
    PVOID                       ObjectContext;// new to Windows Vista
    PVOID                       Reserved;     // new to Windows Vista
} REG_SET_INFORMATION_KEY_INFORMATION, *PREG_SET_INFORMATION_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    ULONG                       Index;                  // IN
    KEY_INFORMATION_CLASS       KeyInformationClass;    // IN
    PVOID                       KeyInformation;         // IN
    ULONG                       Length;                 // IN
    PULONG                      ResultLength;           // OUT
    PVOID                       CallContext;  // new to Windows Vista
    PVOID                       ObjectContext;// new to Windows Vista
    PVOID                       Reserved;     // new to Windows Vista
} REG_ENUMERATE_KEY_INFORMATION, *PREG_ENUMERATE_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_VALUE_KEY_INFORMATION {
    PVOID                           Object;                     // IN
    ULONG                           Index;                      // IN
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;   // IN
    PVOID                           KeyValueInformation;        // IN
    ULONG                           Length;                     // IN
    PULONG                          ResultLength;               // OUT
    PVOID                           CallContext;  // new to Windows Vista
    PVOID                           ObjectContext;// new to Windows Vista
    PVOID                           Reserved;     // new to Windows Vista
} REG_ENUMERATE_VALUE_KEY_INFORMATION, *PREG_ENUMERATE_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    KEY_INFORMATION_CLASS       KeyInformationClass;    // IN
    PVOID                       KeyInformation;         // IN
    ULONG                       Length;                 // IN
    PULONG                      ResultLength;           // OUT
    PVOID                       CallContext;  // new to Windows Vista
    PVOID                       ObjectContext;// new to Windows Vista
    PVOID                       Reserved;     // new to Windows Vista
} REG_QUERY_KEY_INFORMATION, *PREG_QUERY_KEY_INFORMATION;

typedef struct _REG_QUERY_VALUE_KEY_INFORMATION {
    PVOID                           Object;                     // IN
    PUNICODE_STRING                 ValueName;                  // IN
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;   // IN
    PVOID                           KeyValueInformation;        // IN
    ULONG                           Length;                     // IN
    PULONG                          ResultLength;               // OUT
    PVOID                           CallContext;  // new to Windows Vista
    PVOID                           ObjectContext;// new to Windows Vista
    PVOID                           Reserved;     // new to Windows Vista
} REG_QUERY_VALUE_KEY_INFORMATION, *PREG_QUERY_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
    PVOID               Object;                 // IN
    PKEY_VALUE_ENTRY    ValueEntries;           // IN
    ULONG               EntryCount;             // IN
    PVOID               ValueBuffer;            // IN
    PULONG              BufferLength;           // IN OUT
    PULONG              RequiredBufferLength;   // OUT
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION, *PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;

typedef struct _REG_RENAME_KEY_INFORMATION {
    PVOID            Object;    // IN
    PUNICODE_STRING  NewName;   // IN
    PVOID            CallContext;  // new to Windows Vista
    PVOID            ObjectContext;// new to Windows Vista
    PVOID            Reserved;     // new to Windows Vista
} REG_RENAME_KEY_INFORMATION, *PREG_RENAME_KEY_INFORMATION;


typedef struct _REG_KEY_HANDLE_CLOSE_INFORMATION {
    PVOID               Object;         // IN
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_KEY_HANDLE_CLOSE_INFORMATION, *PREG_KEY_HANDLE_CLOSE_INFORMATION;

/* .Net Only */
typedef struct _REG_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName; // IN
    PVOID               RootObject;   // IN
    PVOID               ObjectType;   // new to Windows Vista
    ULONG               CreateOptions;// new to Windows Vista
    PUNICODE_STRING     Class;        // new to Windows Vista
    PVOID               SecurityDescriptor;// new to Windows Vista
    PVOID               SecurityQualityOfService;// new to Windows Vista
    ACCESS_MASK         DesiredAccess;// new to Windows Vista
    ACCESS_MASK         GrantedAccess;// new to Windows Vista
                                      // to be filled in by callbacks 
                                      // when bypassing native code
    PULONG              Disposition;  // new to Windows Vista
                                      // on pass through, callback should fill 
                                      // in disposition
    PVOID               *ResultObject;// new to Windows Vista
                                      // on pass through, callback should return 
                                      // object to be used for the return handle
    PVOID               CallContext;  // new to Windows Vista
    PVOID               RootObjectContext;  // new to Windows Vista
    PVOID               Transaction;  // new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista

} REG_CREATE_KEY_INFORMATION, REG_OPEN_KEY_INFORMATION,*PREG_CREATE_KEY_INFORMATION, *PREG_OPEN_KEY_INFORMATION;

typedef struct _REG_CREATE_KEY_INFORMATION_V1 {
    PUNICODE_STRING     CompleteName; // IN
    PVOID               RootObject;   // IN
    PVOID               ObjectType;   // new to Windows Vista
    ULONG               Options;      // new to Windows Vista
    PUNICODE_STRING     Class;        // new to Windows Vista
    PVOID               SecurityDescriptor;// new to Windows Vista
    PVOID               SecurityQualityOfService;// new to Windows Vista
    ACCESS_MASK         DesiredAccess;// new to Windows Vista
    ACCESS_MASK         GrantedAccess;// new to Windows Vista
                                      // to be filled in by callbacks 
                                      // when bypassing native code
    PULONG              Disposition;  // new to Windows Vista
                                      // on pass through, callback should fill 
                                      // in disposition
    PVOID               *ResultObject;// new to Windows Vista
                                      // on pass through, callback should return 
                                      // object to be used for the return handle
    PVOID               CallContext;  // new to Windows Vista
    PVOID               RootObjectContext;  // new to Windows Vista
    PVOID               Transaction;  // new to Windows Vista

    ULONG_PTR           Version;      // following is new to Windows 7
    PUNICODE_STRING     RemainingName;// the true path left to parse
    ULONG               Wow64Flags;   // Wow64 specific flags gotten from DesiredAccess input
    ULONG               Attributes;   // ObjectAttributes->Attributes
    KPROCESSOR_MODE     CheckAccessMode;  // mode used for the securiry checks

} REG_CREATE_KEY_INFORMATION_V1, REG_OPEN_KEY_INFORMATION_V1,*PREG_CREATE_KEY_INFORMATION_V1, *PREG_OPEN_KEY_INFORMATION_V1;



typedef struct _REG_POST_OPERATION_INFORMATION {
    PVOID               Object;         // IN
    NTSTATUS            Status;         // IN
    PVOID               PreInformation; // new to Windows Vista; identical with the pre information that was sent
                                        // in the pre notification
    NTSTATUS            ReturnStatus;   // new to Windows Vista; callback can now change the outcome of the operation
                                        // during post by returning the new staus here
    PVOID               CallContext;    // new to Windows Vista
    PVOID               ObjectContext;  // new to Windows Vista
    PVOID               Reserved;       // new to Windows Vista
} REG_POST_OPERATION_INFORMATION,*PREG_POST_OPERATION_INFORMATION;
/* end .Net Only */

/* XP only */
typedef struct _REG_PRE_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName;   // IN
} REG_PRE_CREATE_KEY_INFORMATION, REG_PRE_OPEN_KEY_INFORMATION,*PREG_PRE_CREATE_KEY_INFORMATION, *PREG_PRE_OPEN_KEY_INFORMATION;;

typedef struct _REG_POST_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName;   // IN
    PVOID               Object;         // IN
    NTSTATUS            Status;         // IN
} REG_POST_CREATE_KEY_INFORMATION,REG_POST_OPEN_KEY_INFORMATION, *PREG_POST_CREATE_KEY_INFORMATION, *PREG_POST_OPEN_KEY_INFORMATION;
/* end XP only */

/* new to Windows Vista */
#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _REG_LOAD_KEY_INFORMATION {
    PVOID               Object;
    PUNICODE_STRING     KeyName;
    PUNICODE_STRING     SourceFile;
    ULONG               Flags;
    PVOID               TrustClassObject;
    PVOID               UserEvent;
    ACCESS_MASK         DesiredAccess;
    PHANDLE             RootHandle;
    PVOID               CallContext;  
    PVOID               ObjectContext;
    PVOID               Reserved;     
} REG_LOAD_KEY_INFORMATION, *PREG_LOAD_KEY_INFORMATION;

typedef struct _REG_UNLOAD_KEY_INFORMATION {
    PVOID    Object;                      
    PVOID    UserEvent;
    PVOID    CallContext;  
    PVOID    ObjectContext;
    PVOID    Reserved;     
} REG_UNLOAD_KEY_INFORMATION, *PREG_UNLOAD_KEY_INFORMATION;

typedef struct _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION {
    PVOID   Object;
    PVOID   ObjectContext;  
    PVOID   Reserved;     
} REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION, *PREG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;

typedef struct _REG_QUERY_KEY_SECURITY_INFORMATION {
    PVOID                   Object;
    PSECURITY_INFORMATION   SecurityInformation;  // IN
    PSECURITY_DESCRIPTOR    SecurityDescriptor;   // INOUT  
    PULONG                  Length;               // INOUT  
    PVOID                   CallContext;  
    PVOID                   ObjectContext;
    PVOID                   Reserved;     
} REG_QUERY_KEY_SECURITY_INFORMATION, *PREG_QUERY_KEY_SECURITY_INFORMATION;

typedef struct _REG_SET_KEY_SECURITY_INFORMATION {
    PVOID                   Object;
    PSECURITY_INFORMATION   SecurityInformation;  // IN
    PSECURITY_DESCRIPTOR    SecurityDescriptor;   // IN
    PVOID                   CallContext;  
    PVOID                   ObjectContext;
    PVOID                   Reserved;     
} REG_SET_KEY_SECURITY_INFORMATION, *PREG_SET_KEY_SECURITY_INFORMATION;

/* new in Vista SP2 - Restore, Save, Replace */
typedef struct _REG_RESTORE_KEY_INFORMATION {
    PVOID               Object;
    HANDLE              FileHandle;
    ULONG               Flags;
    PVOID               CallContext;  
    PVOID               ObjectContext;
    PVOID               Reserved;     
} REG_RESTORE_KEY_INFORMATION, *PREG_RESTORE_KEY_INFORMATION;

typedef struct _REG_SAVE_KEY_INFORMATION {
    PVOID               Object;
    HANDLE              FileHandle;
    ULONG               Format;
    PVOID               CallContext;  
    PVOID               ObjectContext;
    PVOID               Reserved;     
} REG_SAVE_KEY_INFORMATION, *PREG_SAVE_KEY_INFORMATION;

typedef struct _REG_REPLACE_KEY_INFORMATION {
    PVOID               Object;
    PUNICODE_STRING     OldFileName;
    PUNICODE_STRING     NewFileName;
    PVOID               CallContext;  
    PVOID               ObjectContext;
    PVOID               Reserved;     
} REG_REPLACE_KEY_INFORMATION, *PREG_REPLACE_KEY_INFORMATION;
#endif // NTDDI_VERSION >= NTDDI_VISTA

typedef struct _REG_QUERY_KEY_NAME {
    PVOID                       Object;
    POBJECT_NAME_INFORMATION    ObjectNameInfo;
    ULONG                       Length;
    PULONG                      ReturnLength;
    PVOID                       CallContext;
    PVOID                       ObjectContext;
    PVOID                       Reserved;
} REG_QUERY_KEY_NAME, *PREG_QUERY_KEY_NAME;

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
CmRegisterCallback(_In_     PEX_CALLBACK_FUNCTION Function,
                   _In_opt_ PVOID                 Context,
                   _Out_    PLARGE_INTEGER        Cookie
                    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
CmUnRegisterCallback(_In_ LARGE_INTEGER    Cookie);

#endif // NTDDI_VERSION >= NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
CmRegisterCallbackEx (  _In_        PEX_CALLBACK_FUNCTION   Function,
                        _In_        PCUNICODE_STRING        Altitude,
                        _In_        PVOID                   Driver, //PDRIVER_OBJECT
                        _In_opt_    PVOID                   Context,
                        _Out_       PLARGE_INTEGER          Cookie,
                        _Reserved_  PVOID                   Reserved
                    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID 
CmGetCallbackVersion (  _Out_opt_   PULONG  Major,
                        _Out_opt_   PULONG  Minor
                        );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
CmSetCallbackObjectContext (_Inout_     PVOID           Object,
                            _In_        PLARGE_INTEGER  Cookie,
                            _In_        PVOID           NewContext,
                            _Out_opt_   PVOID           *OldContext
                           );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
CmCallbackGetKeyObjectID (  _In_            PLARGE_INTEGER      Cookie,
                            _In_            PVOID               Object,
                            _Out_opt_       PULONG_PTR          ObjectID,
                            _Outptr_opt_ PCUNICODE_STRING    *ObjectName
                           );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
CmGetBoundTransaction(_In_  PLARGE_INTEGER  Cookie,
                      _In_  PVOID           Object );

#endif // NTDDI_VERSION >= NTDDI_VISTA

#if (NTDDI_VERSION >= NTDDI_WIN8)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
CmCallbackGetKeyObjectIDEx (
    _In_ PLARGE_INTEGER Cookie,
    _In_ PVOID Object,
    _Out_opt_ PULONG_PTR ObjectID,
    _Outptr_opt_ PCUNICODE_STRING *ObjectName,
    _In_ ULONG Flags
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
CmCallbackReleaseKeyObjectIDEx (
    _In_ PCUNICODE_STRING ObjectName
    );

#endif // NTDDI_VERSION >= NTDDI_WIN8

// end_wdm

#define IDLE_TRANSITION 0x80000000

NTKERNELAPI
NTSTATUS
KdPowerTransition (
    _In_ DEVICE_POWER_STATE newDeviceState
    );

NTSTATUS
KdCallPowerHandlers (
    __in DEVICE_POWER_STATE PowerState
    );

// end_nthal

VOID
KdMarkHiberPhase (
    VOID
    );


//
// Define the number of debugging devices we support
//

#define MAX_DEBUGGING_DEVICES_SUPPORTED 2


NTKERNELAPI
NTSTATUS
KdSystemDebugControl (
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength,
    _In_ KPROCESSOR_MODE PreviousMode
    );

NTKERNELAPI
NTSTATUS
KdSecureEnableDebugger (
    VOID
    );

//
// Define external data.
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_NTOSP_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     *KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT *KdDebuggerNotPresent

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT KdDebuggerNotPresent

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
KdDisableDebugger(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
KdEnableDebugger(
    VOID
    );
#endif

//
// KdRefreshDebuggerPresent attempts to communicate with
// the debugger host machine to refresh the state of
// KdDebuggerNotPresent.  It returns the state of
// KdDebuggerNotPresent while the kd locks are held.
// KdDebuggerNotPresent may immediately change state
// after the kd locks are released so it may not
// match the return value.
//

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
KdRefreshDebuggerNotPresent(
    VOID
    );
#endif

typedef enum _KD_OPTION {
    KD_OPTION_SET_BLOCK_ENABLE,
} KD_OPTION;

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSTATUS
KdChangeOption(
    _In_ KD_OPTION Option,
    _In_ ULONG InBufferBytes OPTIONAL,
    _In_ PVOID InBuffer,
    _In_ ULONG OutBufferBytes OPTIONAL,
    _Out_ PVOID OutBuffer,
    _Out_ PULONG OutBufferNeeded OPTIONAL
    );
#endif

// end_wdm

typedef
NTSTATUS
(*PKD_SET_POWER) (
    __in DEVICE_POWER_STATE PowerState,
    __in PVOID Context
    );

typedef struct _KD_POWER_HANDLER {
    LIST_ENTRY List;
    PKD_SET_POWER SetPower;
    PVOID Context;
} KD_POWER_HANDLER, *PKD_POWER_HANDLER;

NTSTATUS
KdRegisterPowerHandler (
    __in PKD_SET_POWER PowerCallback,
    __in PVOID Context,
    __out PHANDLE CallbackHandle
    );

NTSTATUS
KdDeregisterPowerHandler (
    __in HANDLE CallbackHandle
    );

//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0


//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

// end_ntifs

//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

// begin_ntifs
//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

// end_ntifs
//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

// begin_ntifs
//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

// end_ntifs
//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

// end_ntddk end_wdm
// end_wudfwdm
//
// Priority increment used when satisfying a wait on an executive mutant
// (NtReleaseMutant)
//

#define MUTANT_INCREMENT                1

// begin_wudfwdm
// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

// begin_wudfwdm
//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_wudfwdm
// end_wdm end_ntndis
// begin_ntddk
//
// Directory control minor function codes
//

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02

//
// File system control minor function codes.  Note that "user request" is
// assumed to be zero by both the I/O system and file systems.  Do not change
// this value.
//

#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04    // To be obsoleted soon
#define IRP_MN_KERNEL_CALL              0x04

//
// Lock control minor function codes
//

#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04

//
// Flush minor function codes
//

#define IRP_MN_FLUSH_AND_PURGE          0x01
#if (NTDDI_VERSION >= NTDDI_WIN8)
#define IRP_MN_FLUSH_DATA_ONLY          0x02    //see FLUSH_FLAGS_FILE_DATA_ONLY for definition of how this works
#define IRP_MN_FLUSH_NO_SYNC            0x03    //see FLUSH_FLAGS_NO_SYNC for definition of how this works
#endif

//
// Read and Write minor function codes for file systems supporting Lan Manager
// software.  All of these subfunction codes are invalid if the file has been
// opened with FO_NO_INTERMEDIATE_BUFFERING.  They are also invalid in combi-
// nation with synchronous calls (Irp Flag or file open option).
//
// Note that "normal" is assumed to be zero by both the I/O system and file
// systems.  Do not change this value.
//

#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08

#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)

// end_ntddk
// begin_wdm begin_wudfpwdm
//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// PNP minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define IRP_MN_DEVICE_ENUMERATED            0x19
#endif

// end_wdm end_wudfpwdm
// begin_ntddk
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
// end_ntddk
// begin_wdm begin_wudfpwdm

//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03

// begin_ntminiport
//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09
// Minor code 0x0a is reserved
#define IRP_MN_REGINFO_EX                   0x0b
// Minor code 0x0c is reserved

// end_ntminiport

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1


#define IO_CHECK_CREATE_PARAMETERS      0x0200
#define IO_ATTACH_DEVICE                0x0400

//
//  This flag is only meaningful to IoCreateFileSpecifyDeviceObjectHint.
//  FileHandles created using IoCreateFileSpecifyDeviceObjectHint with this
//  flag set will bypass ShareAccess checks on this file.
//

#define IO_IGNORE_SHARE_ACCESS_CHECK    0x0800  // Ignores share access checks on opens.

typedef
VOID
(*PSTALL_ROUTINE) (
    _In_ ULONG Delay
    );

//
// Define the interfaces for the dump driver's routines.
//

typedef
BOOLEAN
(*PDUMP_DRIVER_OPEN) (
    _In_ LARGE_INTEGER PartitionOffset
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE) (
    _In_ PLARGE_INTEGER DiskByteOffset,
    _In_ PMDL Mdl
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_READ) (
    _In_ LONG   Action,
    _In_ PLARGE_INTEGER DiskByteOffset,
    _In_ PMDL Mdl
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_GET_TELEMETRY) (
    _In_ ULONG  Flags,
    _In_ ULONG  Level,
    _Out_ PVOID Buffer,
    _In_ ULONG  BufferSize
    );


//
// Actions accepted by DUMP IO routines (read and write)
//
#define IO_DUMP_FULFILL   0   // fulfill IO request as if DRIVER_WAIT
#define IO_DUMP_START     1   // start new IO
#define IO_DUMP_QUERY     2   // query pending IO
#define IO_DUMP_FINISH    3   // finish pending IO
#define IO_DUMP_INIT      4   // initialize locals

//
// Actions accepted by DRIVER_WRITE_PENDING.. Remove after constants are not used anymore.
//
#define IO_DUMP_WRITE_FULFILL   IO_DUMP_FULFILL
#define IO_DUMP_WRITE_START     IO_DUMP_START
#define IO_DUMP_WRITE_RESUME    IO_DUMP_QUERY
#define IO_DUMP_WRITE_FINISH    IO_DUMP_FINISH
#define IO_DUMP_WRITE_INIT      IO_DUMP_INIT

// size of data used by WRITE_PENDING that should be preserved
// between the calls
#define IO_DUMP_WRITE_DATA_PAGES 2
#define IO_DUMP_WRITE_DATA_SIZE (IO_DUMP_WRITE_DATA_PAGES << PAGE_SHIFT)

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE_PENDING) (
    _In_ LONG Action,
    _In_ PLARGE_INTEGER DiskByteOffset,
    _In_ PMDL Mdl,
    _In_ PVOID LocalData
    );


typedef
VOID
(*PDUMP_DRIVER_FINISH) (
    VOID
    );

typedef
VOID
(*PDUMP_DRIVER_GET_TRANSFER_SIZES) (
    _Out_opt_ PULONG Minimum,
    _Out_opt_ PULONG Maximum
    );

//
// Event notifications that may be sent to dump port drivers
//
typedef enum _DUMP_EVENTS {

    DUMP_EVENT_NONE = 0,
    DUMP_EVENT_HIBER_RESUME,
    DUMP_EVENT_HIBER_RESUME_END

} DUMP_EVENTS, *PDUMP_EVENTS;

typedef
VOID
(*PDUMP_NOTIFY)(
    _In_     DUMP_EVENTS Event,
    _In_opt_ PVOID Context,
    _In_     ULONG Arg
    );

struct _ADAPTER_OBJECT;

// Maximum number of context values passed to disk stack
#define DUMP_INIT_TC_MAX_PARAMS 16

//
// Number of pages in MemoryBlock to not mark as discarded.
// Some dump port driver uses MemoryBlock for device extension
// and there are information that we want to persist across
// hibernation and resume.
//
#define DUMP_MEMORY_BLOCK_BOOT_PAGES 2

//
// This is the information passed from the system to the disk dump driver
// during the driver's initialization.
//

typedef struct _DUMP_INITIALIZATION_CONTEXT {
    ULONG Length;
    ULONG Reserved;             // Was MBR Checksum. Should be zero now.
    PVOID MemoryBlock;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PSTALL_ROUTINE StallRoutine;
    PDUMP_DRIVER_OPEN OpenRoutine;
    PDUMP_DRIVER_WRITE WriteRoutine;
    PDUMP_DRIVER_FINISH FinishRoutine;
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID PortConfiguration;
    BOOLEAN CrashDump;
    BOOLEAN MarkMemoryOnly;
    BOOLEAN HiberResume;
    BOOLEAN Reserved1;
    ULONG MaximumTransferSize;
    ULONG CommonBufferSize;
    PVOID TargetAddress; //Opaque pointer to target address structure
    PDUMP_DRIVER_WRITE_PENDING WritePendingRoutine;
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;
        struct {
            GUID DiskId;
        } Gpt;
    } DiskInfo;

    //
    // Following fields were added in Win8
    //
    PDUMP_DRIVER_READ   ReadRoutine;

    //
    // Get device telemetry entry point and parameters
    //
    PDUMP_DRIVER_GET_TELEMETRY  GetDriveTelemetryRoutine;                   // Get telemetry entry point
    ULONG                       LogSectionTruncateSize;                     // Truncation limit for one collected section
    ULONG                       Parameters[DUMP_INIT_TC_MAX_PARAMS];        // Set of individual parameters

    //
    // Get transfer sizes
    //
    PDUMP_DRIVER_GET_TRANSFER_SIZES GetTransferSizesRoutine;

    //
    // Dump event notification
    //
    PDUMP_NOTIFY DumpNotifyRoutine;

} DUMP_INITIALIZATION_CONTEXT, *PDUMP_INITIALIZATION_CONTEXT;


#if (NTDDI_VERSION >= NTDDI_WINBLUE)

//
// Define structures and routines for Live Dump
//

//
// Live Dump related functions and structures definitions.
//

#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable:4214) // nonstandard extension used : bit field types other than int

//
// Flags specified by the caller to control certain aspects of the live dump operation.
//
typedef union _IO_LIVEDUMP_CONTROL_FLAGS {

    struct {

        //
        // When set: use dump storage stack to write out live dump data to device.
        // When clear: use regular storage stack to write out live dump data to device.
        //
        // Note: Using dump storage stack option is not currently supported.
        //
        ULONG UseDumpStorageStack: 1;

        //
        // When set: writes out memory pages data in compressed form to the dump file.
        //
        // Note: Compression is not currently supported.
        //
        ULONG CompressMemoryPagesData: 1;

        //
        // When set: Include user space memory pages in the live dump file, in addition
        //           to kernel space memory pages.
        //
        // Note: When clear, only kernel space memory pages are included.
        //
        ULONG IncludeUserSpaceMemoryPages: 1;

        //
        // When set: Capture dump data only. Writing to dump file will happen
        //           when callers later call IoWriteDeferredLiveDumpData().
        //
        //           If callers later decide not to write the captured dump data to
        //           the dump file, callers need to call IoDiscardDeferredLiveDumpData().
        //
        // Note: When clear, dump data will be written to dump file before
        //       IoCaptureLiveDump() returns.
        //
        ULONG DeferDumpFileWrite: 1;

        //
        // When set: Abort Livedump if memory allocation made causes memory
        //           pressure on system. Memory pressure is defined as either
        //           high non-paged pool or physical memory usage.
        //
        ULONG AbortIfMemoryPressure : 1;

        //
        // Reserved for future use.
        //
        ULONG Reserved: 27;
    };

    ULONG AsUlong;

} IO_LIVEDUMP_CONTROL_FLAGS, *PIO_LIVEDUMP_CONTROL_FLAGS;


typedef union _IO_LIVEDUMP_CONTROL_ADDPAGES {

    struct {

        //
        // When set, capture hypervisor pages.
        //
        ULONG HypervisorPages: 1;

        ULONG Reserved: 31;
    };

    ULONG AsUlong;

} IO_LIVEDUMP_CONTROL_ADDPAGES, *PIO_LIVEDUMP_CONTROL_ADDPAGES;

//
// Secondary data block descriptor
//
typedef struct _IO_LIVEDUMP_SECONDARY_DATA {

    // GUID respresenting this secondary dump data blob.
    GUID Identifier;

    // Pointer to a buffer containing secondary data.
    PVOID Data;

    // Size of the Data buffer.
    ULONG Size;

    // Reserved
    ULONG Reserved;

    // Pointer to next secondary dump data blob.
    struct _IO_LIVEDUMP_SECONDARY_DATA *Next;

} IO_LIVEDUMP_SECONDARY_DATA, *PIO_LIVEDUMP_SECONDARY_DATA;

//
// Secondary data block header
//
typedef struct _IO_LIVEDUMP_SECONDARY_DATA_HEADER {

    // Flags.
    // Note: This field is for future use. Currently it is not in use.
    ULONG Flags;

    // Reserved
    ULONG Reserved;

    // Pointer to start of the linked list of secondary dump data blob.
    PIO_LIVEDUMP_SECONDARY_DATA Data;

} IO_LIVEDUMP_SECONDARY_DATA_HEADER, *PIO_LIVEDUMP_SECONDARY_DATA_HEADER;

#define IO_LIVEDUMP_CONTROL_VERSION_1   (ULONG)1

typedef _Struct_size_bytes_(Size)
struct _IO_LIVEDUMP_CONTROL {

  // Structure version
  // See defines in IO_LIVEDUMP_CONTROL_VERSION_* above.
  ULONG Version;

  // Size of the structure.
  ULONG Size;

  // Handle of dump file where the dump data will be written to.
  HANDLE DumpFileHandle;

  // Dispatcher object that will be signaled by caller if it needs to cancel
  // the request to generate live dump.
  // The object should be one of the following types:
  //     EventNotificationObject
  //     ProcessObject
  //     ThreadObject
  //     TimerNotificationObject
  //
  // Optional parameter. It should be set to NULL when it is not specified.
  PVOID CancelObject;

  // A bit-field flag denoting properties of the live dump request.
  IO_LIVEDUMP_CONTROL_FLAGS Flags;

  // A bit-field flag denoting controls for including additional pages in the dump file.
  IO_LIVEDUMP_CONTROL_ADDPAGES AddPagesControl;

  // Secondary dump data
  IO_LIVEDUMP_SECONDARY_DATA_HEADER SecondaryData;

} IO_LIVEDUMP_CONTROL, *PIO_LIVEDUMP_CONTROL;

_At_(*LiveDumpContext, _When_(return == STATUS_MORE_PROCESSING_REQUIRED, _Out_))
_At_(*LiveDumpContext, _When_(return != STATUS_MORE_PROCESSING_REQUIRED, _Out_opt_))
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
IoCaptureLiveDump (
    _In_ ULONG BugcheckCode,
    _In_ ULONG_PTR BugCheckParameter1,
    _In_ ULONG_PTR BugCheckParameter2,
    _In_ ULONG_PTR BugCheckParameter3,
    _In_ ULONG_PTR BugCheckParameter4,
    _In_ PIO_LIVEDUMP_CONTROL Control,
    PVOID *LiveDumpContext
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
IoWriteDeferredLiveDumpData(
    _In_ PVOID LiveDumpContext
    );

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
IoDiscardDeferredLiveDumpData(
    _In_ PVOID LiveDumpContext
    );

#endif // NTDDI_VERSION >= NTDDI_WINBLUE



// begin_ntddk
//
// Define callout routine type for use in IoQueryDeviceDescription().
//

typedef NTSTATUS (*PIO_QUERY_DEVICE_ROUTINE)(
    _In_ PVOID Context,
    _In_ PUNICODE_STRING PathName,
    _In_ INTERFACE_TYPE BusType,
    _In_ ULONG BusNumber,
    _In_ PKEY_VALUE_FULL_INFORMATION *BusInformation,
    _In_ CONFIGURATION_TYPE ControllerType,
    _In_ ULONG ControllerNumber,
    _In_ PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    _In_ CONFIGURATION_TYPE PeripheralType,
    _In_ ULONG PeripheralNumber,
    _In_ PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );


// Defines the order of the information in the array of
// PKEY_VALUE_FULL_INFORMATION.
//

typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
    IoQueryDeviceIdentifier = 0,
    IoQueryDeviceConfigurationData,
    IoQueryDeviceComponentInformation,
    IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT, *PIO_QUERY_DEVICE_DATA_FORMAT;

// end_ntddk
// begin_wdm
//
// Define the objects that can be created by IoCreateFile.
//

typedef enum _CREATE_FILE_TYPE {
    CreateFileTypeNone,
    CreateFileTypeNamedPipe,
    CreateFileTypeMailslot
} CREATE_FILE_TYPE;

//
// Define the named pipe create parameters structure used for internal calls
// to IoCreateFile when a named pipe is being created.  This structure allows
// code invoking this routine to pass information specific to this function
// when creating a named pipe.
//

typedef struct _NAMED_PIPE_CREATE_PARAMETERS {
    ULONG NamedPipeType;
    ULONG ReadMode;
    ULONG CompletionMode;
    ULONG MaximumInstances;
    ULONG InboundQuota;
    ULONG OutboundQuota;
    LARGE_INTEGER DefaultTimeout;
    BOOLEAN TimeoutSpecified;
} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;

//
// Define the mailslot create parameters structure used for internal calls
// to IoCreateFile when a mailslot is being created.  This structure allows
// code invoking this routine to pass information specific to this function
// when creating a mailslot.
//

typedef struct _MAILSLOT_CREATE_PARAMETERS {
    ULONG MailslotQuota;
    ULONG MaximumMessageSize;
    LARGE_INTEGER ReadTimeout;
    BOOLEAN TimeoutSpecified;
} MAILSLOT_CREATE_PARAMETERS, *PMAILSLOT_CREATE_PARAMETERS;

//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;

struct _FILE_OBJECT;

// begin_wudfwdm

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

// end_wudfwdm

struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCATTER_GATHER_LIST;

//
// Define the I/O version of a DPC routine.
//

_Function_class_(IO_DPC_ROUTINE)
_IRQL_always_function_min_(DISPATCH_LEVEL)
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
VOID
IO_DPC_ROUTINE (
    _In_ PKDPC Dpc,
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp,
    _In_opt_ PVOID Context
    );

typedef IO_DPC_ROUTINE *PIO_DPC_ROUTINE;

//
// Define driver timer routine type.
//

_Function_class_(IO_TIMER_ROUTINE)
_IRQL_requires_same_
typedef
VOID
IO_TIMER_ROUTINE (
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _In_opt_ PVOID Context
    );

typedef IO_TIMER_ROUTINE *PIO_TIMER_ROUTINE;

// begin_wudfwdm
//
// Define driver initialization routine type.
//
_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
typedef
NTSTATUS
DRIVER_INITIALIZE (
    _In_ struct _DRIVER_OBJECT *DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    );

typedef DRIVER_INITIALIZE *PDRIVER_INITIALIZE;

// end_wudfwdm
// end_wdm
// begin_ntddk
//
// Define driver reinitialization routine type.
//

typedef
VOID
DRIVER_REINITIALIZE (
    _In_ struct _DRIVER_OBJECT *DriverObject,
    _In_opt_ PVOID Context,
    _In_ ULONG Count
    );

typedef DRIVER_REINITIALIZE *PDRIVER_REINITIALIZE;

// end_ntddk
// begin_wdm begin_ntndis
//
// Define driver cancel routine type.
//

_Function_class_(DRIVER_CANCEL)
_Requires_lock_held_(_Global_cancel_spin_lock_)
_Releases_lock_(_Global_cancel_spin_lock_)
_IRQL_requires_min_(DISPATCH_LEVEL)
_IRQL_requires_(DISPATCH_LEVEL)
typedef
VOID
DRIVER_CANCEL (
    _Inout_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ _IRQL_uses_cancel_ struct _IRP *Irp
    );

typedef DRIVER_CANCEL *PDRIVER_CANCEL;

//
// Define driver dispatch routine type.
// The default is that it can be called <= DISPATCH
// because it might be called from another driver.
// See also below.
//

_Function_class_(DRIVER_DISPATCH)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
NTSTATUS
DRIVER_DISPATCH (
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp
    );

typedef DRIVER_DISPATCH *PDRIVER_DISPATCH;

// Convenience typedef to indicate that the IRQL level
// of the function has been considered, and that it might
// be called at DISPATCH_LEVEL.
typedef DRIVER_DISPATCH DRIVER_DISPATCH_RAISED;

// Use this variant when there is no possibility of the
// dispatch function being called at raised IRQL, as in
// a top-level only driver.  This is preferred when it is
// safe because it enables more paged code.
// (There may be reasons not to page a dispatch routine
// that meets that criterion, but it can still use this
// definition.)
//
_Function_class_(DRIVER_DISPATCH)
_IRQL_requires_max_(PASSIVE_LEVEL)
_IRQL_requires_same_
typedef
NTSTATUS
DRIVER_DISPATCH_PAGED (
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp
    );

typedef DRIVER_DISPATCH_PAGED *PDRIVER_DISPATCH_PAGED;

//
// Define driver start I/O routine type.
//

_Function_class_(DRIVER_STARTIO)
_IRQL_always_function_min_(DISPATCH_LEVEL)
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
typedef
VOID
DRIVER_STARTIO (
    _Inout_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp
    );

typedef DRIVER_STARTIO *PDRIVER_STARTIO;

//
// Define driver unload routine type.
//
_Function_class_(DRIVER_UNLOAD)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
typedef
VOID
DRIVER_UNLOAD (
    _In_ struct _DRIVER_OBJECT *DriverObject
    );

typedef DRIVER_UNLOAD *PDRIVER_UNLOAD;

//
// Define driver AddDevice routine type.
//

_Function_class_(DRIVER_ADD_DEVICE)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_When_(return>=0, _Kernel_clear_do_init_(__yes))
typedef
NTSTATUS
DRIVER_ADD_DEVICE (
    _In_ struct _DRIVER_OBJECT *DriverObject,
    _In_ struct _DEVICE_OBJECT *PhysicalDeviceObject
    );

typedef DRIVER_ADD_DEVICE *PDRIVER_ADD_DEVICE;


//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

_Function_class_(FAST_IO_CHECK_IF_POSSIBLE)
_IRQL_requires_same_
_Success_(return != FALSE)
typedef
BOOLEAN
FAST_IO_CHECK_IF_POSSIBLE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _In_ BOOLEAN CheckForReadOperation,
    _Pre_notnull_
    _When_(return != FALSE, _Post_equal_to_(_Old_(IoStatus)))
    _When_(return == FALSE, _Post_valid_)
    PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_CHECK_IF_POSSIBLE *PFAST_IO_CHECK_IF_POSSIBLE;

_Function_class_(FAST_IO_READ)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_READ (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _Out_ PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_READ *PFAST_IO_READ;

_Function_class_(FAST_IO_WRITE)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_WRITE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _In_ PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_WRITE *PFAST_IO_WRITE;

//
// Fast I/O query basic and standard information procedures.
//

_Function_class_(FAST_IO_QUERY_BASIC_INFO)
_IRQL_requires_same_
_Success_(return != FALSE)
typedef
BOOLEAN
FAST_IO_QUERY_BASIC_INFO (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ BOOLEAN Wait,
    _Out_ PFILE_BASIC_INFORMATION Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_BASIC_INFO *PFAST_IO_QUERY_BASIC_INFO;

_Function_class_(FAST_IO_QUERY_STANDARD_INFO)
_IRQL_requires_same_
_Success_(return != FALSE)
typedef
BOOLEAN
FAST_IO_QUERY_STANDARD_INFO (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ BOOLEAN Wait,
    _Out_ PFILE_STANDARD_INFORMATION Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_STANDARD_INFO *PFAST_IO_QUERY_STANDARD_INFO;

//
// Fast I/O lock and unlock procedures.
//

_Function_class_(FAST_IO_LOCK)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_LOCK (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ PEPROCESS ProcessId,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_LOCK *PFAST_IO_LOCK;

_Function_class_(FAST_IO_UNLOCK_SINGLE)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_UNLOCK_SINGLE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ PEPROCESS ProcessId,
    _In_ ULONG Key,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_UNLOCK_SINGLE *PFAST_IO_UNLOCK_SINGLE;

_Function_class_(FAST_IO_UNLOCK_ALL)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_UNLOCK_ALL (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PEPROCESS ProcessId,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_UNLOCK_ALL *PFAST_IO_UNLOCK_ALL;

_Function_class_(FAST_IO_UNLOCK_ALL_BY_KEY)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_UNLOCK_ALL_BY_KEY (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PVOID ProcessId,
    _In_ ULONG Key,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_UNLOCK_ALL_BY_KEY *PFAST_IO_UNLOCK_ALL_BY_KEY;

//
// Fast I/O device control procedure.
//

_Function_class_(FAST_IO_DEVICE_CONTROL)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_DEVICE_CONTROL (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ BOOLEAN Wait,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _In_ ULONG IoControlCode,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_DEVICE_CONTROL *PFAST_IO_DEVICE_CONTROL;

//
// Define callbacks for NtCreateSection to synchronize correctly with
// the file system.  It pre-acquires the resources that will be needed
// when calling to query and set file/allocation size in the file system.
//

_Function_class_(FAST_IO_ACQUIRE_FILE)
_IRQL_requires_same_
typedef
VOID
FAST_IO_ACQUIRE_FILE (
    _In_ struct _FILE_OBJECT *FileObject
    );

typedef FAST_IO_ACQUIRE_FILE *PFAST_IO_ACQUIRE_FILE;

_Function_class_(FAST_IO_RELEASE_FILE)
_IRQL_requires_same_
typedef
VOID
FAST_IO_RELEASE_FILE (
    _In_ struct _FILE_OBJECT *FileObject
    );

typedef FAST_IO_RELEASE_FILE *PFAST_IO_RELEASE_FILE;

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

_Function_class_(FAST_IO_DETACH_DEVICE)
_IRQL_requires_same_
typedef
VOID
FAST_IO_DETACH_DEVICE (
    _In_ struct _DEVICE_OBJECT *SourceDevice,
    _In_ struct _DEVICE_OBJECT *TargetDevice
    );

typedef FAST_IO_DETACH_DEVICE *PFAST_IO_DETACH_DEVICE;

//
// This structure is used by the server to quickly get the information needed
// to service a server open call.  It is takes what would be two fast io calls
// one for basic information and the other for standard information and makes
// it into one call.
//

_Function_class_(FAST_IO_QUERY_NETWORK_OPEN_INFO)
_IRQL_requires_same_
_Success_(return != FALSE)
typedef
BOOLEAN
FAST_IO_QUERY_NETWORK_OPEN_INFO (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ BOOLEAN Wait,
    _Out_ struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    _Out_ struct _IO_STATUS_BLOCK *IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_NETWORK_OPEN_INFO *PFAST_IO_QUERY_NETWORK_OPEN_INFO;

//
//  Define Mdl-based routines for the server to call
//

_Function_class_(FAST_IO_MDL_READ)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_MDL_READ (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ ULONG LockKey,
    _Out_ PMDL *MdlChain,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_READ *PFAST_IO_MDL_READ;

_Function_class_(FAST_IO_MDL_READ_COMPLETE)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_MDL_READ_COMPLETE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PMDL MdlChain,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_READ_COMPLETE *PFAST_IO_MDL_READ_COMPLETE;

_Function_class_(FAST_IO_PREPARE_MDL_WRITE)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_PREPARE_MDL_WRITE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ ULONG LockKey,
    _Out_ PMDL *MdlChain,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_PREPARE_MDL_WRITE *PFAST_IO_PREPARE_MDL_WRITE;

_Function_class_(FAST_IO_MDL_WRITE_COMPLETE)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_MDL_WRITE_COMPLETE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ PMDL MdlChain,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_WRITE_COMPLETE *PFAST_IO_MDL_WRITE_COMPLETE;

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

_Function_class_(FAST_IO_ACQUIRE_FOR_MOD_WRITE)
_IRQL_requires_same_
typedef
NTSTATUS
FAST_IO_ACQUIRE_FOR_MOD_WRITE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER EndingOffset,
    _Out_ struct _ERESOURCE **ResourceToRelease,
    _In_ struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_ACQUIRE_FOR_MOD_WRITE *PFAST_IO_ACQUIRE_FOR_MOD_WRITE;

_Function_class_(FAST_IO_RELEASE_FOR_MOD_WRITE)
_IRQL_requires_same_
typedef
NTSTATUS
FAST_IO_RELEASE_FOR_MOD_WRITE (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ struct _ERESOURCE *ResourceToRelease,
    _In_ struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_RELEASE_FOR_MOD_WRITE *PFAST_IO_RELEASE_FOR_MOD_WRITE;

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

_Function_class_(FAST_IO_ACQUIRE_FOR_CCFLUSH)
_IRQL_requires_same_
typedef
NTSTATUS
FAST_IO_ACQUIRE_FOR_CCFLUSH (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_ACQUIRE_FOR_CCFLUSH *PFAST_IO_ACQUIRE_FOR_CCFLUSH;

_Function_class_(FAST_IO_RELEASE_FOR_CCFLUSH)
_IRQL_requires_same_
typedef
NTSTATUS
FAST_IO_RELEASE_FOR_CCFLUSH (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_RELEASE_FOR_CCFLUSH *PFAST_IO_RELEASE_FOR_CCFLUSH;

_Function_class_(FAST_IO_READ_COMPRESSED)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_READ_COMPRESSED (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ ULONG LockKey,
    _Out_ PVOID Buffer,
    _Out_ PMDL *MdlChain,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _Out_ struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    _In_ ULONG CompressedDataInfoLength,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_READ_COMPRESSED *PFAST_IO_READ_COMPRESSED;

_Function_class_(FAST_IO_WRITE_COMPRESSED)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_WRITE_COMPRESSED (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ ULONG LockKey,
    _In_ PVOID Buffer,
    _Out_ PMDL *MdlChain,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    _In_ ULONG CompressedDataInfoLength,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_WRITE_COMPRESSED *PFAST_IO_WRITE_COMPRESSED;

_Function_class_(FAST_IO_MDL_READ_COMPLETE_COMPRESSED)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_MDL_READ_COMPLETE_COMPRESSED (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PMDL MdlChain,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_READ_COMPLETE_COMPRESSED *PFAST_IO_MDL_READ_COMPLETE_COMPRESSED;

_Function_class_(FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED (
    _In_ struct _FILE_OBJECT *FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ PMDL MdlChain,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED *PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;

_Function_class_(FAST_IO_QUERY_OPEN)
_IRQL_requires_same_
typedef
BOOLEAN
FAST_IO_QUERY_OPEN (
    _Inout_ struct _IRP *Irp,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    _In_ struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_OPEN *PFAST_IO_QUERY_OPEN;

//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
    PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
    PFAST_IO_QUERY_OPEN FastIoQueryOpen;
    PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
    PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
    PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

//
// Define device driver adapter/controller execution routine.
//

typedef
_Function_class_(DRIVER_CONTROL)
_IRQL_requires_same_
IO_ALLOCATION_ACTION
DRIVER_CONTROL (
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _Inout_ struct _IRP *Irp,
    _In_ PVOID MapRegisterBase,
    _In_ PVOID Context
    );
typedef DRIVER_CONTROL *PDRIVER_CONTROL;

// begin_wudfpwdm
//
// Define the I/O system's security context type for use by file system's
// when checking access to volumes, files, and directories.
//

typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
    ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010
#define VPB_DIRECT_WRITES_ALLOWED       0x00000020


//
// Volume Parameter Block (VPB)
//

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;


#if defined(_WIN64) || defined(_ARM_)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && ( defined(_NTDDK_) || defined(_NTDRIVER_) || defined(_NTOSP_))

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

#elif defined(_WDM_INCLUDED_)

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

#else

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; // ntndis

#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_ || _NTOSP_)

//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    union {
        KDEVICE_QUEUE_ENTRY WaitQueueEntry;
        struct {
            LIST_ENTRY DmaWaitEntry;
            ULONG NumberOfChannels;
            ULONG SyncCallback : 1;
            ULONG DmaContext : 1;
            ULONG Reserved : 30;
        };
    };
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

// end_wdm
// begin_ntddk

typedef struct _CONTROLLER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PVOID ControllerExtension;
    KDEVICE_QUEUE DeviceWaitQueue;

    ULONG Spare1;
    LARGE_INTEGER Spare2;

} CONTROLLER_OBJECT, *PCONTROLLER_OBJECT;

// end_ntddk
// begin_wdm begin_wudfpwdm
//
// Define Device Object (DO) flags
//
// end_wdm end_wudfpwdm

#define DO_VERIFY_VOLUME                    0x00000002      // ntddk nthal ntifs wdm wudfpwdm
#define DO_BUFFERED_IO                      0x00000004      // ntddk nthal ntifs wdm wudfpwdm
#define DO_EXCLUSIVE                        0x00000008      // ntddk nthal ntifs wdm wudfpwdm
#define DO_DIRECT_IO                        0x00000010      // ntddk nthal ntifs wdm wudfpwdm
#define DO_MAP_IO_BUFFER                    0x00000020      // ntddk nthal ntifs wdm wudfpwdm
#define DO_DEVICE_HAS_NAME                  0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING              0x00000080      // ntddk nthal ntifs wdm wudfpwdm
#define DO_SYSTEM_BOOT_PARTITION            0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS               0x00000200      // ntddk nthal ntifs
#define DO_HIGH_PRIORITY_FILESYSTEM         0x00000200      // ntosifs
#define DO_NEVER_LAST_DEVICE                0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED              0x00000800      // ntddk nthal ntifs wdm wudfpwdm
#define DO_BUS_ENUMERATED_DEVICE            0x00001000      // ntddk nthal ntifs wdm wudfpwdm
#define DO_POWER_PAGABLE                    0x00002000      // ntddk nthal ntifs wdm wudfpwdm
#define DO_POWER_INRUSH                     0x00004000      // ntddk nthal ntifs wdm wudfpwdm
#define DO_POWER_NOOP                       0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM          0x00010000      // ntddk nthal ntifs
#define DO_SUPPORTS_PERSISTENT_ACLS         0x00020000      // ntifs
#define DO_SUPPORTS_TRANSACTIONS            0x00040000      // ntddk nthal ntifs
#define DO_FORCE_NEITHER_IO                 0x00080000      // ntddk nthal ntifs
#define DO_VOLUME_DEVICE_OBJECT             0x00100000      // ntddk nthal ntifs
#define DO_SYSTEM_SYSTEM_PARTITION          0x00200000      // ntddk nthal ntifs
#define DO_SYSTEM_CRITICAL_PARTITION        0x00400000      // ntddk nthal ntifs
#define DO_DISALLOW_EXECUTE                 0x00800000      // ntddk nthal ntifs
// begin_ntddk
// @@BEGIN_DDKSPLIT
#define DO_PRIORITY_CALLBACK_ENABLED        0x01000000
#define DO_DEVICE_USED_BY_DEBUGGER          0x02000000
// @@END_DDKSPLIT
// end_ntddk
#define DO_DEVICE_TO_BE_RESET               0x04000000      // ntddk nthal ntifs wdm wudfpwdm
#define DO_DEVICE_IRP_REQUIRES_EXTENSION    0x08000000      // ntddk nthal ntifs

// begin_wdm
//
// Device Object structure definition
//

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    __volatile PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;

} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


struct  _DEVICE_OBJECT_POWER_EXTENSION;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    //
    // The remaining fields are reserved for system use.
    //

// end_wdm

    //
    // Universal Power Data - all device objects must have this
    //
    // see ntos\po\pop.h
    // WARNING: Access via PO macros
    // and with PO locking rules ONLY.

    ULONG           PowerFlags;                             // wdm

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;  // wdm

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;                                   // wdm

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;                             // wdm

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;                             // wdm

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    // Used to keep track of number of pending start ios.
    __volatile LONG StartIoCount;                           // wdm
    // Next startio key
    LONG           StartIoKey;                              // wdm
    // Start Io Flags. Need a separate flag so that it can be accessed without locks
    ULONG          StartIoFlags;                            // wdm
    // If not NULL contains the VPB of the mounted volume.
    PVPB           Vpb;                                     // wdm
    // Set in the filesystem's volume device object.
    // This is a reverse VPB pointer.

    //
    // Dependency Relations, used internally by PNP.
    //

    PVOID DependencyNode;                                   // wdm

    //
    // Interrupt Connection Information, used internally when
    // connecting a device's interrupt
    //

    PVOID InterruptContext;                                 // wdm

    //
    // Driver Verifier specific context.
    //

    // begin_wdm

    __volatile PVOID VerifierContext;

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
// end_wdm
// begin_ntddk
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// begin_wdm

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PDRIVER_ADD_DEVICE AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

    //
    // Note: any new shared fields get added here.
    //


} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis



//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

// begin_wudfpwdm
//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
#define FO_ALERTABLE_IO                 0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FO_WRITE_THROUGH                0x00000010
#define FO_SEQUENTIAL_ONLY              0x00000020
#define FO_CACHE_SUPPORTED              0x00000040
#define FO_NAMED_PIPE                   0x00000080
#define FO_STREAM_FILE                  0x00000100
#define FO_MAILSLOT                     0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
#define FO_QUEUE_IRP_TO_THREAD          FO_GENERATE_AUDIT_ON_CLOSE
#define FO_DIRECT_DEVICE_OPEN           0x00000800
#define FO_FILE_MODIFIED                0x00001000
#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
#define FO_TEMPORARY_FILE               0x00008000
#define FO_DELETE_ON_CLOSE              0x00010000
#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000
#define FO_RANDOM_ACCESS                0x00100000
#define FO_FILE_OPEN_CANCELLED          0x00200000
#define FO_VOLUME_OPEN                  0x00400000
#define FO_REMOTE_ORIGIN                0x01000000
#define FO_DISALLOW_EXCLUSIVE           0x02000000
#define FO_SKIP_COMPLETION_PORT         FO_DISALLOW_EXCLUSIVE
#define FO_SKIP_SET_EVENT               0x04000000
#define FO_SKIP_SET_FAST_IO             0x08000000
#define FO_INDIRECT_WAIT_OBJECT         0x10000000
#define FO_SECTION_MINSTORE_TREATMENT   0x20000000

// end_wudfpwdm
//
// This mask allows us to re-use flags that are not present during a create
// operation for uses that are only valid for the duration of the create.
//
#define FO_FLAGS_VALID_ONLY_DURING_CREATE FO_DISALLOW_EXCLUSIVE

// end_wdm
// begin_ntosifs
#define FO_KEEPALIVE_COUNTS_ACTIVE      FO_SECTION_MINSTORE_TREATMENT
// end_ntosifs
// begin_wdm

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    __volatile ULONG Waiters;
    __volatile ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    __volatile PIO_COMPLETION_CONTEXT CompletionContext;
    KSPIN_LOCK IrpListLock;
    LIST_ENTRY IrpList;
    __volatile PVOID FileObjectExtension;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000

// end_wdm

#define IRP_UM_DRIVER_INITIATED_IO      0x00400000  
//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08


#define IRP_BACKPOCKET_POSSIBLE         0x20
#define IRP_BACKPOCKET_IRP              (IRP_BACKPOCKET_POSSIBLE | IRP_QUOTA_CHARGED)
#define IRP_EXTENSION_ALLOCATED         0x40
#define IRP_EXTENSION_GENERIC_ONLY      0x80
// end_ntosifs
// begin_wdm

//
// I/O Request Packet (IRP) definition
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP {
    CSHORT Type;
    USHORT Size;

// end_wdm
#if defined(_WIN64)

    USHORT AllocationProcessorNumber;
    USHORT Reserved;

#endif
// begin_wdm

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        __volatile LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            union {
                PIO_APC_ROUTINE UserApcRoutine;
                PVOID IssuingProcess;
            };
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    __volatile PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;
// end_wdm
            PVOID IrpExtension;
// begin_wdm

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP;

typedef IRP *PIRP;

// begin_wudfpwdm
//
// Define completion routine types for use in stack locations in an IRP
//

_Function_class_(IO_COMPLETION_ROUTINE)
_IRQL_requires_same_
_IRQL_requires_max_(DISPATCH_LEVEL)
typedef
NTSTATUS
IO_COMPLETION_ROUTINE (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp,
    _In_reads_opt_(_Inexpressible_("varies")) PVOID Context
    );

typedef IO_COMPLETION_ROUTINE *PIO_COMPLETION_ROUTINE;

// end_wudfpwdm
//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_ERROR_RETURNED               0x02
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe (IRP_MJ_CREATE/IRP_MJ_CREATE_NAMED_PIPE)
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_PAGING_FILE             0x02
#define SL_OPEN_TARGET_DIRECTORY        0x04
#define SL_STOP_ON_SYMLINK              0x08


#define SL_CASE_SENSITIVE               0x80

//
// Read / Write (IRP_MJ_READ/IRP_MJ_WRITE)
//

#define SL_KEY_SPECIFIED                0x01
#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_WRITE_THROUGH                0x04
#define SL_FT_SEQUENTIAL_WRITE          0x08
#define SL_FORCE_DIRECT_WRITE           0x10
#define SL_REALTIME_STREAM              0x20

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

#define SL_READ_ACCESS_GRANTED          0x01
#define SL_WRITE_ACCESS_GRANTED         0x04    // Gap for SL_OVERRIDE_VERIFY_VOLUME

//
// Lock (IRP_MJ_LOCK_CONTROL)
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

//
// QueryDirectory / QueryEa / QueryQuota (IRP_MJ_DIRECTORY_CONTROL/IRP_MJ_QUERY_EA/IRP_MJ_QUERY_QUOTA))
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// NotifyDirectory (IRP_MJ_DIRECTORY_CONTROL)
//

#define SL_WATCH_TREE                   0x01

//
// FileSystemControl (IRP_MJ_FILE_SYSTEM_CONTROL)
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

// begin_wudfpwdm

//
//  SetInformationFile (IRP_MJ_SET_INFORMATION)
//
//      Rename/Link Information
//

#define SL_BYPASS_ACCESS_CHECK          0x01

//
// Define PNP/POWER types required by IRP_MJ_PNP/IRP_MJ_POWER.
//

typedef enum _DEVICE_RELATION_TYPE {
    BusRelations,
    EjectionRelations,
    PowerRelations,
    RemovalRelations,
    TargetDeviceRelation,
    SingleBusRelations,
    TransportRelations
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef struct _DEVICE_RELATIONS {
    ULONG Count;
    _Field_size_(Count) PDEVICE_OBJECT Objects[1];  // variable length
} DEVICE_RELATIONS, *PDEVICE_RELATIONS;

//
// IRP_MN_DEVICE_USAGE_NOTIFICATION types
//
// DeviceUsageTypePostDisplay - The POST display adapter must be sent this IRP
//     before IRP_MN_START_DEVICE, and with Parameters.UsageNotification.InPath
//     set to TRUE.  After that, the adapter cannot be sent an
//     IRP_MN_DEVICE_USAGE_NOTIFICATION with InPath set to FALSE.
//
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined,
    DeviceUsageTypePaging,
    DeviceUsageTypeHibernation,
    DeviceUsageTypeDumpFile,
    DeviceUsageTypeBoot,
    DeviceUsageTypePostDisplay
} DEVICE_USAGE_NOTIFICATION_TYPE;

// begin_ntminiport

// workaround overloaded definition (rpc generated headers all define INTERFACE
// to match the class name).
#undef INTERFACE

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

// end_ntminiport

typedef _Struct_size_bytes_(Size) struct _DEVICE_CAPABILITIES {
    _Field_range_(==, sizeof(struct _DEVICE_CAPABILITIES)) USHORT Size;
    USHORT Version;  // the version documented here is version 1
    ULONG DeviceD1:1;
    ULONG DeviceD2:1;
    ULONG LockSupported:1;
    ULONG EjectSupported:1; // Ejectable in S0
    ULONG Removable:1;
    ULONG DockDevice:1;
    ULONG UniqueID:1;
    ULONG SilentInstall:1;
    ULONG RawDeviceOK:1;
    ULONG SurpriseRemovalOK:1;
    ULONG WakeFromD0:1;
    ULONG WakeFromD1:1;
    ULONG WakeFromD2:1;
    ULONG WakeFromD3:1;
    ULONG HardwareDisabled:1;
    ULONG NonDynamic:1;
    ULONG WarmEjectSupported:1;
    ULONG NoDisplayInUI:1;
    ULONG Reserved1:1;
    ULONG WakeFromInterrupt:1;
    ULONG Reserved:12;

    ULONG Address;
    ULONG UINumber;

    DEVICE_POWER_STATE DeviceState[POWER_SYSTEM_MAXIMUM];
    _Field_range_(PowerSystemUnspecified, PowerSystemHibernate) SYSTEM_POWER_STATE SystemWake;
    _Field_range_(PowerDeviceUnspecified, PowerDeviceD3) DEVICE_POWER_STATE DeviceWake;
    ULONG D1Latency;
    ULONG D2Latency;
    ULONG D3Latency;
} DEVICE_CAPABILITIES, *PDEVICE_CAPABILITIES;

typedef struct _POWER_SEQUENCE {
    ULONG SequenceD1;
    ULONG SequenceD2;
    ULONG SequenceD3;
} POWER_SEQUENCE, *PPOWER_SEQUENCE;

typedef enum {
    BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
    BusQueryHardwareIDs = 1,    // Hardware ids
    BusQueryCompatibleIDs = 2,  // compatible device ids
    BusQueryInstanceID = 3,     // persistent id for this instance of the device
    BusQueryDeviceSerialNumber = 4,   // serial number for this device
    BusQueryContainerID = 5     // unique id of the device's physical container
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef ULONG PNP_DEVICE_STATE, *PPNP_DEVICE_STATE;

#define PNP_DEVICE_DISABLED                      0x00000001
#define PNP_DEVICE_DONT_DISPLAY_IN_UI            0x00000002
#define PNP_DEVICE_FAILED                        0x00000004
#define PNP_DEVICE_REMOVED                       0x00000008
#define PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED 0x00000010
#define PNP_DEVICE_NOT_DISABLEABLE               0x00000020
#define PNP_DEVICE_DISCONNECTED                  0x00000040

typedef enum {
    DeviceTextDescription = 0,            // DeviceDesc property
    DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;

// end_wudfpwdm
//
// Define I/O Request Packet (IRP) stack locations
//

#if !defined(_AMD64_) && !defined(_ARM_) && !defined(_ARM64_)
#include "pshpack4.h"
#endif

// begin_ntndis

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

// end_ntndis

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            ULONG POINTER_ALIGNMENT EaLength;
        } Create;

        //
        // System service parameters for:  NtCreateNamedPipeFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT Reserved;
            USHORT ShareAccess;
            PNAMED_PIPE_CREATE_PARAMETERS Parameters;
        } CreatePipe;

        //
        // System service parameters for:  NtCreateMailslotFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT Reserved;
            USHORT ShareAccess;
            PMAILSLOT_CREATE_PARAMETERS Parameters;
        } CreateMailslot;

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Write;

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            ULONG Length;
            PUNICODE_STRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
            ULONG POINTER_ALIGNMENT FileIndex;
        } QueryDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT CompletionFilter;
        } NotifyDirectory;

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                ULONG ClusterCount;
                HANDLE DeleteHandle;
            };
        } SetFile;


        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;

        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
            PVOID Type3InputBuffer;
        } FileSystemControl;
        //
        // System service parameters for:  NtLockFile/NtUnlockFile
        //

        struct {
            PLARGE_INTEGER Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } LockControl;

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //


        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG POINTER_ALIGNMENT Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;

        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device control.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;


        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
            PVOID InterfaceSpecificData;
        } QueryInterface;

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG POINTER_ALIGNMENT Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        // Parameters for IRP_MN_QUERY_DEVICE_TEXT
        //

        struct {
            DEVICE_TEXT_TYPE DeviceTextType;
            LCID POINTER_ALIGNMENT LocaleId;
        } QueryDeviceText;

        //
        // Parameters for IRP_MN_DEVICE_USAGE_NOTIFICATION
        //

        struct {
            BOOLEAN InPath;
            BOOLEAN Reserved[3];
            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
        } UsageNotification;

        //
        // Parameters for IRP_MN_WAIT_WAKE
        //

        struct {
            SYSTEM_POWER_STATE PowerState;
        } WaitWake;

        //
        // Parameter for IRP_MN_POWER_SEQUENCE
        //

        struct {
            PPOWER_SEQUENCE PowerSequence;
        } PowerSequence;

        //
        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
        //

#if (NTDDI_VERSION >= NTDDI_VISTA)
        struct {
            union {
                ULONG SystemContext;
                SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext;
            };
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;
#else
        struct {
            ULONG SystemContext;
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

        //
        // Parameters for StartDevice
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
            PCM_RESOURCE_LIST AllocatedResourcesTranslated;
        } StartDevice;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            ULONG_PTR ProviderId;
            PVOID DataPath;
            ULONG BufferSize;
            PVOID Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    // request.
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#if !defined(_AMD64_) && !defined(_ARM_) && !defined(_ARM64_)
#include "poppack.h"
#endif

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

// end_wdm
// begin_ntddk

//
// The following structure is used by drivers that are initializing to
// determine the number of devices of a particular type that have already
// been initialized.  It is also used to track whether or not the AtDisk
// address range has already been claimed.  Finally, it is used by the
// NtQuerySystemInformation system service to return device type counts.
//

typedef struct _CONFIGURATION_INFORMATION {

    //
    // This field indicates the total number of disks in the system.  This
    // number should be used by the driver to determine the name of new
    // disks.  This field should be updated by the driver as it finds new
    // disks.
    //

    ULONG DiskCount;                // Count of hard disks thus far
    ULONG FloppyCount;              // Count of floppy disks thus far
    ULONG CdRomCount;               // Count of CD-ROM drives thus far
    ULONG TapeCount;                // Count of tape drives thus far
    ULONG ScsiPortCount;            // Count of SCSI port adapters thus far
    ULONG SerialCount;              // Count of serial devices thus far
    ULONG ParallelCount;            // Count of parallel devices thus far

    //
    // These next two fields indicate ownership of one of the two IO address
    // spaces that are used by WD1003-compatable disk controllers.
    //

    BOOLEAN AtDiskPrimaryAddressClaimed;    // 0x1F0 - 0x1FF
    BOOLEAN AtDiskSecondaryAddressClaimed;  // 0x170 - 0x17F

    //
    // Indicates the structure version, as anything value belong this will have been added.
    // Use the structure size as the version.
    //

    ULONG Version;

    //
    // Indicates the total number of medium changer devices in the system.
    // This field will be updated by the drivers as it determines that
    // new devices have been found and will be supported.
    //

    ULONG MediumChangerCount;

} CONFIGURATION_INFORMATION, *PCONFIGURATION_INFORMATION;

//
// Public I/O routine definitions
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Acquires_lock_(_Global_cancel_spin_lock_)
_Requires_lock_not_held_(_Global_cancel_spin_lock_)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_raises_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    _Out_ _At_(*Irql, _IRQL_saves_) PKIRQL Irql
    );
#endif

// end_wdm
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoAcquireVpbSpinLock(
    _Out_ PKIRQL Irql
    );
#endif

// end_ntifs
// begin_ntddk
#if !(defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
__drv_preferredFunction("AllocateAdapterChannel","obsolete")
NTKERNELAPI
NTSTATUS
IoAllocateAdapterChannel(
    _In_ PADAPTER_OBJECT AdapterObject,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG NumberOfMapRegisters,
    _In_ PDRIVER_CONTROL ExecutionRoutine,
    _In_ PVOID Context
    );
#endif

#endif // !(defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoAllocateController(
    _In_ PCONTROLLER_OBJECT ControllerObject,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PDRIVER_CONTROL ExecutionRoutine,
    _In_opt_ PVOID Context
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Ret_range_(<=, 0)
NTKERNELAPI
NTSTATUS
IoAllocateDriverObjectExtension(
    _In_  PDRIVER_OBJECT DriverObject,
    _In_  PVOID ClientIdentificationAddress,
    _In_  ULONG DriverObjectExtensionSize,
    // When successful, this always allocates already-aliased memory.
    _Post_ _At_(*DriverObjectExtension, _When_(return==0,
    __drv_aliasesMem __drv_allocatesMem(Mem) _Post_notnull_))
    _When_(return == 0, _Outptr_result_bytebuffer_(DriverObjectExtensionSize))
    PVOID *DriverObjectExtension
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
IoAllocateErrorLogEntry(
    _In_ PVOID IoObject,
    _In_ UCHAR EntrySize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PIRP
IoAllocateIrp(
    _In_ CCHAR StackSize,
    _In_ BOOLEAN ChargeQuota
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PIRP
IoAllocateIrpEx(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ CCHAR StackSize,
    _In_ BOOLEAN ChargeQuota
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PMDL
IoAllocateMdl(
    _In_opt_ __drv_aliasesMem PVOID VirtualAddress,
    _In_ ULONG Length,
    _In_ BOOLEAN SecondaryBuffer,
    _In_ BOOLEAN ChargeQuota,
    _Inout_opt_ PIRP Irp
    );
#endif

// end_wdm
// begin_ntddk
//++
//
// VOID
// IoAssignArcName(
//     _In_ PUNICODE_STRING ArcName,
//     _In_ PUNICODE_STRING DeviceName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers of bootable media to create a symbolic
//     link between the ARC name of their device and its NT name.  This allows
//     the system to determine which device in the system was actually booted
//     from since the ARC firmware only deals in ARC names, and NT only deals
//     in NT names.
//
// Arguments:
//
//     ArcName - Supplies the Unicode string representing the ARC name.
//
//     DeviceName - Supplies the name to which the ARCname refers.
//
// Return Value:
//
//     None.
//
//--

#define IoAssignArcName( ArcName, DeviceName ) (  \
    IoCreateSymbolicLink( (ArcName), (DeviceName) ) )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReprtDetectedDevice
__drv_preferredFunction("(see documentation)", "Obsolete")
NTKERNELAPI
NTSTATUS
IoAssignResources (
    _In_ PUNICODE_STRING RegistryPath,
    _In_opt_ PUNICODE_STRING DriverClassName,
    _In_ PDRIVER_OBJECT DriverObject,
    _In_opt_ PDEVICE_OBJECT DeviceObject,
    _In_opt_ PIO_RESOURCE_REQUIREMENTS_LIST RequestedResources,
    _Inout_ PCM_RESOURCE_LIST *AllocatedResources
    );
#endif

typedef enum _IO_PAGING_PRIORITY {
    IoPagingPriorityInvalid,        // Returned if a non-paging IO IRP is passed.
    IoPagingPriorityNormal,         // For regular paging IO
    IoPagingPriorityHigh,           // For high priority paging IO
    IoPagingPriorityReserved1,      // Reserved for future use.
    IoPagingPriorityReserved2       // Reserved for future use.
} IO_PAGING_PRIORITY;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
_Ret_range_(<=, 0)
NTKERNELAPI
NTSTATUS
IoAttachDevice(
    _In_ _When_(return==0, __drv_aliasesMem)
    PDEVICE_OBJECT SourceDevice,
    _In_  PUNICODE_STRING TargetDevice,
    _Out_ PDEVICE_OBJECT *AttachedDevice
    );
#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoAttachDeviceToDeviceStack
__drv_preferredFunction("IoAttachDeviceToDeviceStack", "Obsolete")
NTKERNELAPI
NTSTATUS
IoAttachDeviceByPointer(
    _In_ PDEVICE_OBJECT SourceDevice,
    _In_ PDEVICE_OBJECT TargetDevice
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    _In_ _When_(return!=0, __drv_aliasesMem)
    PDEVICE_OBJECT SourceDevice,
    _In_ PDEVICE_OBJECT TargetDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
__drv_aliasesMem
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    _In_ ULONG MajorFunction,
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_opt_ PVOID Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PLARGE_INTEGER StartingOffset,
    _In_opt_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
__drv_aliasesMem
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    _In_  ULONG IoControlCode,
    _In_  PDEVICE_OBJECT DeviceObject,
    _In_opt_  PVOID InputBuffer,
    _In_  ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _In_ BOOLEAN InternalDeviceIoControl,
    _In_opt_ PKEVENT Event,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoBuildPartialMdl(
    _In_ PMDL SourceMdl,
    _Inout_ PMDL TargetMdl,
    _Inout_ PVOID VirtualAddress,
    _In_ ULONG Length
    );
#endif

typedef struct _BOOTDISK_INFORMATION {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
} BOOTDISK_INFORMATION, *PBOOTDISK_INFORMATION;

//
// This structure should follow the previous structure field for field.
//
typedef struct _BOOTDISK_INFORMATION_EX {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
    GUID BootDeviceGuid;
    GUID SystemDeviceGuid;
    BOOLEAN BootDeviceIsGpt;
    BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_EX, *PBOOTDISK_INFORMATION_EX;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct _LOADER_PARTITION_INFORMATION_EX {
    ULONG PartitionStyle;
    ULONG PartitionNumber;
    union {
        ULONG Signature;
        GUID DeviceId;
    };
    ULONG Flags;
} LOADER_PARTITION_INFORMATION_EX, *PLOADER_PARTITION_INFORMATION_EX;

typedef struct _BOOTDISK_INFORMATION_LITE {
    ULONG NumberEntries;
    LOADER_PARTITION_INFORMATION_EX Entries[1];
} BOOTDISK_INFORMATION_LITE, *PBOOTDISK_INFORMATION_LITE;
#else

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _BOOTDISK_INFORMATION_LITE {
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
    GUID BootDeviceGuid;
    GUID SystemDeviceGuid;
    BOOLEAN BootDeviceIsGpt;
    BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_LITE, *PBOOTDISK_INFORMATION_LITE;
#endif // NTDDI_VERSION >= NTDDI_VISTA

#endif // NTDDI_VERSION >= NTDDI_VISTA

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoGetBootDiskInformation(
    _Inout_ PBOOTDISK_INFORMATION BootDiskInformation,
    _In_ ULONG Size
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoGetBootDiskInformationLite(
    _Outptr_ PBOOTDISK_INFORMATION_LITE *BootDiskInformation
    );

// end_wdm
NTKERNELAPI
NTSTATUS
IoCreateArcName(
    _In_ PDEVICE_OBJECT DeviceObject
    );
// begin_wdm
#endif // NTDDI_VERSION >= NTDDI_VISTA


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_When_(MajorFunction == IRP_MJ_WRITE, _At_(Buffer, _In_))
_When_(MajorFunction == IRP_MJ_READ, _At_(Buffer, _Out_))
_When_(MajorFunction != IRP_MJ_READ && MajorFunction != IRP_MJ_WRITE, _At_(Buffer, _Pre_null_))
_Must_inspect_result_
__drv_aliasesMem
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    _In_  ULONG MajorFunction,
    _In_  PDEVICE_OBJECT DeviceObject,
    PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER StartingOffset,
    _In_  PKEVENT Event,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Success_(TRUE)
NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ __drv_aliasesMem PIRP Irp
    );
#endif

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
IoCancelIrp(
    _In_ PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG DesiredShareAccess,
    _Inout_ PFILE_OBJECT FileObject,
    _Inout_ PSHARE_ACCESS ShareAccess,
    _In_ BOOLEAN Update
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoCheckShareAccessEx(
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG DesiredShareAccess,
    _Inout_ PFILE_OBJECT FileObject,
    _Inout_ PSHARE_ACCESS ShareAccess,
    _In_ BOOLEAN Update,
    _In_ PBOOLEAN WritePermission
    );
#endif

//
// This value should be returned from completion routines to continue
// completing the IRP upwards. Otherwise, STATUS_MORE_PROCESSING_REQUIRED
// should be returned.
//
#define STATUS_CONTINUE_COMPLETION      STATUS_SUCCESS  // wudfpwdm

//
// Completion routines can also use this enumeration in place of status codes.
//
typedef enum _IO_COMPLETION_ROUTINE_RESULT {

    ContinueCompletion = STATUS_CONTINUE_COMPLETION,
    StopCompletion = STATUS_MORE_PROCESSING_REQUIRED

} IO_COMPLETION_ROUTINE_RESULT, *PIO_COMPLETION_ROUTINE_RESULT;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    _In_ PIRP Irp,
    _In_ CCHAR PriorityBoost
    );
#endif

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoConnectInterrupt(
    _Out_ PKINTERRUPT *InterruptObject,
    _In_  PKSERVICE_ROUTINE ServiceRoutine,
    _In_opt_ PVOID ServiceContext,
    _In_opt_ PKSPIN_LOCK SpinLock,
    _In_  ULONG Vector,
    _In_  KIRQL Irql,
    _In_  KIRQL SynchronizeIrql,
    _In_  KINTERRUPT_MODE InterruptMode,
    _In_  BOOLEAN ShareVector,
    _In_  KAFFINITY ProcessorEnableMask,
    _In_  BOOLEAN FloatingSave
    );
#endif

//
// Interrupt message information table entry definition
//

typedef struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {

    //
    // Message address - indicates the address the device should use to
    // generate this message signaled interrupt.
    //

    PHYSICAL_ADDRESS MessageAddress;

    //
    // Target processor set - indicates the set of processors that this
    // message in allowed to interrupt.
    //

    KAFFINITY TargetProcessorSet;

    //
    // Interrupt object - holds a pointer to the interrupt object associated
    // with this interrupt message.  This structure is opaque to drivers.
    //

    PKINTERRUPT InterruptObject;

    //
    // Message data - supplies the value that the device should write to the
    // message address in order to generate this interrupt message.
    //

    ULONG MessageData;

    //
    // The remaining fields indicate the system interrupt vector, IRQL,
    // trigger mode, and interrupt polarity associated with this interrupt
    // message.  These first three values are suitable for use in a fully
    // specified connection parameter structure in a call to
    // IoConnectInterruptEx.
    //

    ULONG Vector;
    KIRQL Irql;
    KINTERRUPT_MODE Mode;
    KINTERRUPT_POLARITY Polarity;

} IO_INTERRUPT_MESSAGE_INFO_ENTRY, *PIO_INTERRUPT_MESSAGE_INFO_ENTRY;

//
// Interrupt message information table definition
//

typedef struct _IO_INTERRUPT_MESSAGE_INFO {

    //
    // Unified IRQL - indicates the IRQL that will be used when calling a
    // message service routine associated with any of the interrupt messages
    // in this table.  Such a unified IRQL will only exist in cases where 1) a
    // driver provides a spinlock to IoConnectInterruptEx with the intent of
    // serializing delivery of all of the messages listed in this table or 2)
    // the driver provides a synchronization IRQL, and no spinlock, with the
    // intent of blocking any message service routine associated with this
    // table from directly preempting another one.  If neither of these cases
    // applies, then the different messages in this table are allowed to be
    // delivered in parallel and at different IRQLs.  In this case this field
    // will be set to zero.
    //

    KIRQL UnifiedIrql;

    //
    // Message count - indicates the number of entries contained in this
    // message information table.
    //

    ULONG MessageCount;

    //
    // Message info - lies at the start of a variable size array of
    // information table entries, with the size of the array dictated by the
    // message count associated with this table.  Each entry describes a
    // different interrupt message that has been allocated to this device.
    //

    IO_INTERRUPT_MESSAGE_INFO_ENTRY MessageInfo[1];

} IO_INTERRUPT_MESSAGE_INFO, *PIO_INTERRUPT_MESSAGE_INFO;

//
// Define the connection parameters associated with a fully specified
// interrupt connection request.
//

typedef struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {

    //
    // PhysicalDeviceObject - Supplies the physical device object associated
    //     with the interrupt being connected.  This is normally the physical
    //     device object associated with the device that generates the given
    //     interrupt.
    //

    _In_ PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // InterruptObject - Supplies a pointer to the location that will be used
    //     to return a pointer to the interrupt object allocated in
    //     association with the interrupt being connected.
    //

    _Out_ PKINTERRUPT *InterruptObject;

    //
    // ServiceRoutine - Supplies the address of the interrupt service routine
    //     (ISR) that should be executed when the interrupt occurs.
    //

    _In_ PKSERVICE_ROUTINE ServiceRoutine;

    //
    // ServiceContext - Supplies an opaque pointer to the driver context
    //     information that should be passed to the ISR.
    //

    _In_ PVOID ServiceContext;

    //
    // SpinLock - Supplies an optional pointer to a spin lock that will be
    //     acquired before every call to the ISR.  After providing a spin
    //     lock, the driver can synchronize with the ISR by acquiring the spin
    //     lock at the synchronization IRQL associated with the interrupt.  If
    //     this parameter is not provided, then an internal spin lock will be
    //     acquired before each call to the ISR.  The driver can use
    //     KeSynchronizeExecution to acquire this internal spin lock at the
    //     appropriate IRQL and thus synchronize with the ISR.
    //

    _In_opt_ PKSPIN_LOCK SpinLock;

    //
    // SynchronizeIrql - Supplies the IRQL at which the interrupt spin lock
    //     should be acquired and at which the ISR should be executed.  This
    //     parameter must be greater than or equal to the IRQL associated with
    //     the interrupt.  This parameter is most often used in conjunction
    //     with a caller provided spin lock to serialize ISR execution across
    //     multiple interrupts, however it can also be used without a spin
    //     lock to block this ISR from directly preempting or being directly
    //     preempted by some other ISR.
    //

    _In_ KIRQL SynchronizeIrql;

    //
    // FloatingSave - Supplies an indication of whether or not the machine's
    //     floating point state should be saved before invoking the ISR.
    //

    _In_ BOOLEAN FloatingSave;

    //
    // ShareVector - Supplies an indication of whether this interrupt vector
    //     can be shared with other interrupt objects.  This value is usually
    //     passed to a driver as part of the translated resources sent along
    //     with IRP_MN_START_DEVICE.
    //

    _In_ BOOLEAN ShareVector;

    //
    // Vector - Supplies the system interrupt vector associated with the
    //     interrupt being connected.  This value is usually passed to a
    //     driver as part of the translated resources sent along with
    //     IRP_MN_START_DEVICE.
    //

    _In_ ULONG Vector;

    //
    // Irql - Supplies the IRQL associated with the interrupt being connected.
    //     This value is usually passed to a driver as part of its translated
    //     resources sent along with IRP_MN_START_DEVICE.
    //

    _In_ KIRQL Irql;

    //
    // InterruptMode - Supplies the trigger mode of the interrupt being
    //     connected.  This parameter must be LevelSensitive for level
    //     triggered interrupts and Latched for edge triggered interrupts.
    //     This value is usually passed to a driver as part of its translated
    //     resources sent along with IRP_MN_START_DEVICE.
    //

    _In_ KINTERRUPT_MODE InterruptMode;

    //
    // ProcessorEnableMask - Supplies an affinity mask indicating the set of
    //     processors on which delivery of the interrupt should be allowed.
    //     This value is usually passed to a driver as part of its translated
    //     resources sent along with IRP_MN_START_DEVICE.
    //

    _In_ KAFFINITY ProcessorEnableMask;

    //
    // Group - Supplies a group number indicating the group of the processors
    //     on which delivery of the interrupt should be allowed. This value
    //     is usually passed to a driver as part of its translated resources
    //     sent along with IRP_MN_START_DEVICE. This value is ignored if the
    //     the version CONNECT_FULLY_SPECIFIED is used, in which case the
    //     group number is always 0.
    //

    _In_ USHORT Group;

} IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;

//
// Define the connection parameters associated with a line based interrupt
// connection request.
//

typedef struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {

    //
    // PhysicalDeviceObject - Supplies the physical device object associated
    //     with the line based interrupt being connected.  In order to
    //     correctly determine the interrupt to connect, this is generally
    //     required to be the physical device object associated with the
    //     device that generates the interrupt of interest.
    //

    _In_ PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // InterruptObject - Supplies a pointer to the location that will be used
    //     to return a pointer to the interrupt object allocated in
    //     association with the interrupt being connected.
    //

    _Out_ PKINTERRUPT *InterruptObject;

    //
    // ServiceRoutine - Supplies the address of the interrupt service routine
    //     (ISR) that should be executed when the interrupt occurs.
    //

    _In_ PKSERVICE_ROUTINE ServiceRoutine;

    //
    // ServiceContext - Supplies an opaque pointer to the driver context
    //     information that should be passed to the ISR.
    //

    _In_ PVOID ServiceContext;

    //
    // SpinLock - Supplies an optional pointer to a spin lock that will be
    //     acquired before every call to the ISR.  After providing a spin
    //     lock, the driver can synchronize with the ISR by acquiring the spin
    //     lock at the synchronization IRQL associated with the interrupt.  If
    //     this parameter is not provided, then an internal spin lock will be
    //     acquired before each call to the ISR.  The driver can use
    //     KeSynchronizeExecution to acquire this internal spin lock at the
    //     appropriate IRQL and thus synchronize with the ISR.
    //

    _In_opt_ PKSPIN_LOCK SpinLock;

    //
    // SynchronizeIrql - Supplies an optional IRQL at which the interrupt spin
    //     lock should be acquired and at which the ISR should be executed.
    //     If a nonzero value is provided for this parameter, it must be
    //     greater than or equal to the IRQL associated with the interrupt.
    //     This parameter is most often used in conjunction with a caller
    //     provided spin lock to serialize ISR execution across multiple
    //     interrupts, however it can also be used without a spin lock to
    //     block this ISR from directly preempting or being directly preempted
    //     by some other ISR.  If this parameter is omitted then the IRQL of
    //     the interrupt being connected is used as the sychronization IRQL,
    //     both in the case where the caller provides a spin lock and in the
    //     case where the spin lock is omitted.
    //

    _In_opt_ KIRQL SynchronizeIrql;

    //
    // FloatingSave - Supplies an indication of whether or not the machine's
    //     floating point state should be saved before invoking the ISR.
    //

    _In_ BOOLEAN FloatingSave;

} IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;

//
// Define the connection parameters associated with a message signaled
// interrupt connection request.
//

typedef struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {

    //
    // PhysicalDeviceObject - Supplies the physical device object associated
    //     with the interrupt messages being connected.  In order to correctly
    //     determine the set of messages to connect, this is generally
    //     required to be the physical device object associated with the
    //     device that generates the interrupt messages of interest.
    //

    _In_ PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // ConnectionContext - Supplies a union containing a pointer to the
    //     location that will be used to return the interrupt connection
    //     context to the caller.  If message based interrupt connection is
    //     successful, then the connection context is a pointer to the
    //     associated interrupt message information table.  If connection
    //     succeeds only after falling back on the associated line based
    //     interrupt, then the connection context is a pointer to the
    //     associated interrupt object.
    //

    union {
        _Out_ PVOID *Generic;
        _Out_ PIO_INTERRUPT_MESSAGE_INFO *InterruptMessageTable;
        _Out_ PKINTERRUPT *InterruptObject;
    } ConnectionContext;

    //
    // MessageServiceRoutine - Supplies the interrupt message service routine
    //     (IMSR) that should be executed every time any one of the interrupt
    //     messages being connected is signaled.
    //

    _In_ PKMESSAGE_SERVICE_ROUTINE MessageServiceRoutine;

    //
    // ServiceContext - Supplies an opaque pointer to the driver context
    //     information that should be passed to the IMSR.
    //

    _In_ PVOID ServiceContext;

    //
    // SpinLock - Supplies an optional pointer to a spin lock that will be
    //     acquired before every call to the IMSR.  After providing a spin
    //     lock, the driver can synchronize with the IMSR by acquiring the
    //     spin lock at the synchronization IRQL associated with the IMSR.
    //     Note that providing a spin lock will serialize processing of all of
    //     the interrupt messages being connected.  In other words, providing
    //     a spin lock implies that no two interrupt messages out of the set
    //     being connected can ever be serviced in parallel by the IMSR.
    //
    //     If this parameter is not provided, then an internal spin lock will
    //     be acquired before each call to the IMSR.  This internal spin lock
    //     is associated with the interrupt object corresponding to the actual
    //     message that caused us to execute the IMSR, meaning that the IMSR
    //     can run on multiple processors and potentially at multiple IRQLs in
    //     this case.  KeSynchronizeExecution can be used to acquire this
    //     internal spin lock at the appropriate IRQL, thus synchronizing with
    //     IMSR execution associated with a specific interrupt message while
    //     still allowing all other messages to be serviced as they are
    //     signaled.
    //

    _In_opt_ PKSPIN_LOCK SpinLock;

    //
    // SynchronizeIrql - Supplies an optional IRQL at which the interrupt spin
    //     lock should be acquired and at which the IMSR should be executed.
    //     If a nonzero value is provided for this parameter, it must be
    //     greater than or equal to the maximum IRQL associated with any of
    //     the interrupt messages being connected.
    //
    //     This parameter is most often used in conjunction with a caller
    //     provided spin lock to serialize IMSR execution across multiple
    //     messages.  If a spin lock is provided and this parameter is
    //     omitted, then the synchronization IRQL will be set to the maximum
    //     IRQL associated with any of the interrupt messages.
    //
    //     This parameter can be used without a spin lock to block this IMSR
    //     from directly preempting or being directly preempted by itself,
    //     some other IMSR, or some other line based interrupt service
    //     routine.  If this parameter is omitted and the spin lock is also
    //     omitted, then the IMSR will be executed at the IRQL associated with
    //     the individual message being serviced.  In this case it is possible
    //     for the IMSR to preempt itself if it is connected to multiple
    //     messages with different associated IRQLs.
    //

    _In_opt_ KIRQL SynchronizeIrql;

    //
    // FloatingSave - Supplies an indication of whether or not the machine's
    //     floating point state should be saved before invoking the IMSR.
    //

    _In_ BOOLEAN FloatingSave;

    //
    // FallBackServiceRoutine - Supplies an optional address of an interrupt
    //     service routine (ISR) that should be executed when the line based
    //     interrupt associated with this device is signaled.  This parameter
    //     will only be used when connection to this device's interrupt
    //     messages fails, which most commonly occurs when no interrupt
    //     messages are available for this device.
    //
    //     Connection to the fall back service routine is functionally
    //     identical to a normal line based interrupt connection operation,
    //     the only difference being that in this case the service context,
    //     spin lock, synchronization IRQL, and floating save parameters given
    //     for the IMSR are reused when connecting the ISR.
    //

    _In_opt_ PKSERVICE_ROUTINE FallBackServiceRoutine;

} IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;

//
// Define the different interrupt connection types that can be requested
// through IoConnectInterruptEx
//

#define CONNECT_FULLY_SPECIFIED         0x1
#define CONNECT_LINE_BASED              0x2
#define CONNECT_MESSAGE_BASED           0x3
#define CONNECT_FULLY_SPECIFIED_GROUP   0x4
#define CONNECT_CURRENT_VERSION         0x4

//
// Interrupt connection parameter structure definition
//

typedef struct _IO_CONNECT_INTERRUPT_PARAMETERS {

    //
    // Version - Supplies the type of interrupt connection requested by this
    //     structure.  This field must hold one of the following values.
    //
    //         CONNECT_FULLY_SPECIFIED - Indicates that an attempt should be
    //             made to connect to the precise interrupt described by this
    //             structure.  This vector can be either line based or message
    //             signaled.
    //
    //         CONNECT_LINE_BASED - Indicates that an attempt should be made
    //             to connect to the line based interrupt associated with this
    //             device.
    //
    //         CONNECT_MESSAGE_BASED - Indicates that an attempt should be
    //             made to connect to the interrupt messages that have been
    //             allocated for this device, optionally falling back on the
    //             device's line based interrupt if interrupt messages aren't
    //             available.
    //
    //         CONNECT_FULLY_SPECIFIED_GROUP - Same as CONNECT_FULLY_SPECIFIED,
    //             except that a group number is also specified to indicate
    //             the group of processors on which the interrupt is allowed to
    //             be delivered.
    //
    //     After successfully connecting an interrupt, this field is filled on
    //     output with the type of connection that was performed.  This will
    //     always be the connection type given by the caller except in the
    //     case of a message based connection attempt that falls back to
    //     connection to the associated line based interrupt.
    //
    //     If the caller passes an unsupported connection type, this field is
    //     filled on output with the maximum connection type supported by the
    //     interrupt connection routine.
    //

    _Inout_ ULONG Version;

    //
    // Define a union to overlay the connection parameter structures
    // associated with the different connection types on top of one another.
    //

    union {
        IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS FullySpecified;
        IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS LineBased;
        IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS MessageBased;
    };

} IO_CONNECT_INTERRUPT_PARAMETERS, *PIO_CONNECT_INTERRUPT_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoConnectInterruptEx (
    _Inout_ PIO_CONNECT_INTERRUPT_PARAMETERS Parameters
    );
#endif // NTDDI_VERSION >= NTDDI_VISTA

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PCONTROLLER_OBJECT
IoCreateController(
    _In_ ULONG Size
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
_Ret_range_(<=, 0)
NTKERNELAPI
NTSTATUS
IoCreateDevice(
    _In_  PDRIVER_OBJECT DriverObject,
    _In_  ULONG DeviceExtensionSize,
    _In_opt_ PUNICODE_STRING DeviceName,
    _In_  DEVICE_TYPE DeviceType,
    _In_  ULONG DeviceCharacteristics,
    _In_  BOOLEAN Exclusive,
    _Outptr_result_nullonfailure_
    _At_(*DeviceObject,
        __drv_allocatesMem(Mem)
        _When_((((_In_function_class_(DRIVER_INITIALIZE))
               ||(_In_function_class_(DRIVER_DISPATCH)))),
             __drv_aliasesMem))
    PDEVICE_OBJECT *DeviceObject
    );
#endif

#define WDM_MAJORVERSION        0x06
#define WDM_MINORVERSION        0x00

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
__drv_preferredFunction("RtlIsNtDdiVersionAvailable","Preferred")
NTKERNELAPI
BOOLEAN
IoIsWdmVersionAvailable(
    _When_(MajorVersion!=1&&MajorVersion!=6,
    _In_ __drv_reportError("MajorVersion must be 1 or 6")) UCHAR MajorVersion,
    _In_ _When_(MinorVersion!=0 && MinorVersion!=5 && MinorVersion!=16
                    && MinorVersion!=32 && MinorVersion!=48,
    __drv_reportError("MinorVersion must be 0, 0x5, 0x10, 0x20, or 0x30"))
    UCHAR MinorVersion
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_  ACCESS_MASK DesiredAccess,
    _In_  POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_  ULONG FileAttributes,
    _In_  ULONG ShareAccess,
    _In_  ULONG Disposition,
    _In_  ULONG CreateOptions,
    _In_opt_ PVOID EaBuffer,
    _In_  ULONG EaLength,
    _In_  CREATE_FILE_TYPE CreateFileType,
    _In_opt_ PVOID InternalParameters,
    _In_  ULONG Options
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PKEVENT
IoCreateNotificationEvent(
    _In_  PUNICODE_STRING EventName,
    _Out_ PHANDLE EventHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    _In_ PUNICODE_STRING SymbolicLinkName,
    _In_ PUNICODE_STRING DeviceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PKEVENT
IoCreateSynchronizationEvent(
    _In_  PUNICODE_STRING EventName,
    _Out_ PHANDLE EventHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoCreateUnprotectedSymbolicLink(
    _In_ PUNICODE_STRING SymbolicLinkName,
    _In_ PUNICODE_STRING DeviceName
    );
#endif

// end_wdm
// begin_ntddk

//++
//
// VOID
// IoDeassignArcName(
//     _In_ PUNICODE_STRING ArcName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers to deassign an ARC name that they
//     created to a device.  This is generally only called if the driver is
//     deleting the device object, which means that the driver is probably
//     unloading.
//
// Arguments:
//
//     ArcName - Supplies the ARC name to be removed.
//
// Return Value:
//
//     None.
//
//--

#define IoDeassignArcName( ArcName ) (  \
    IoDeleteSymbolicLink( (ArcName) ) )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
IoDeleteController(
    _In_ PCONTROLLER_OBJECT ControllerObject
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
_Kernel_clear_do_init_(__yes)
NTKERNELAPI
VOID
IoDeleteDevice(
    _In_ __drv_freesMem(Mem) PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    _In_ PUNICODE_STRING SymbolicLinkName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
IoDetachDevice(
    _Inout_ PDEVICE_OBJECT TargetDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
IoDisconnectInterrupt(
    _In_ PKINTERRUPT InterruptObject
    );
#endif

//
// Interrupt disconnection parameter structure definition
//

typedef struct _IO_DISCONNECT_INTERRUPT_PARAMETERS {

    //
    // Version - Supplies the type of interrupt disconnection operation
    //     requested by this structure.  This field must match the connection
    //     type returned by a corresponding successful call to
    //     IoConnectInterruptEx.
    //

    _In_ ULONG Version;

    //
    // ConnectionContext - Supplies a union containing the connection context
    //     associated with the interrupt being disconnected.  When
    //     disconnecting fully specified or line based interrupts, this
    //     parameter supplies the interrupt object pointer that was returned
    //     when the interrupt was initially connected.  When disconnecting a
    //     set of interrupt messages, this parameter supplies the interrupt
    //     message information table pointer that was returned when the
    //     interrupt messages were initially connected.
    //

    union {
        _In_ PVOID Generic;
        _In_ PKINTERRUPT InterruptObject;
        _In_ PIO_INTERRUPT_MESSAGE_INFO InterruptMessageTable;
    } ConnectionContext;

} IO_DISCONNECT_INTERRUPT_PARAMETERS, *PIO_DISCONNECT_INTERRUPT_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
IoDisconnectInterruptEx (
    _In_ PIO_DISCONNECT_INTERRUPT_PARAMETERS Parameters
    );
#endif // NTDDI_VERSION >= NTDDI_VISTA

//
// Interrupt active/inactive reporting parameter structure definition
//

typedef struct _IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS {

    //
    // Version - Supplies the type of interrupt reporting operation
    //     requested by this structure.  This field must match the connection
    //     type returned by a corresponding successful call to
    //     IoConnectInterruptEx.
    //

    _In_ ULONG Version;

    //
    // ConnectionContext - Supplies a union containing the connection context
    //     associated with the interrupt being reported.  When
    //     referring to fully specified or line based interrupts, this
    //     parameter supplies the interrupt object pointer that was returned
    //     when the interrupt was initially connected.  When reporting a
    //     set of interrupt messages, this parameter supplies the interrupt
    //     message information table pointer that was returned when the
    //     interrupt messages were initially connected.
    //

    union {
        _In_ PVOID Generic;
        _In_ PKINTERRUPT InterruptObject;
        _In_ PIO_INTERRUPT_MESSAGE_INFO InterruptMessageTable;
    } ConnectionContext;

} IO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS,
  *PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
VOID
IoReportInterruptActive (
    _In_ PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS Parameters
    );

VOID
IoReportInterruptInactive (
    _In_ PIO_REPORT_INTERRUPT_ACTIVE_STATE_PARAMETERS Parameters
    );
#endif // NTDDI_VERSION >= NTDDI_WIN8

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
NTSTATUS
IoGetAffinityInterrupt (
    _In_ PKINTERRUPT InterruptObject,
    _Out_ PGROUP_AFFINITY GroupAffinity
    );
#endif // NTDDI_VERSION >= NTDDI_WIN7

// end_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoEnqueueIrp(
    _In_ PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoFreeController(
    _In_ PCONTROLLER_OBJECT ControllerObject
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoFreeIrp(
    _In_ __drv_freesMem(Mem) PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoFreeMdl(
    PMDL Mdl
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoGetAttachedDevice(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)          // wdm
_IRQL_requires_max_(DISPATCH_LEVEL)               // wdm
NTKERNELAPI                                 // wdm
PDEVICE_OBJECT                              // wdm
IoGetAttachedDeviceReference(               // wdm
    _In_ PDEVICE_OBJECT DeviceObject        // wdm
    );                                      // wdm
#endif                                      // wdm
                                            // wdm
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoGetBaseFileSystemDeviceObject(
    _In_ PFILE_OBJECT FileObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)          // ntddk
_IRQL_requires_max_(PASSIVE_LEVEL)                // ntddk ntosp
NTKERNELAPI                                 // ntddk ntosp
PCONFIGURATION_INFORMATION                  // ntddk ntosp
IoGetConfigurationInformation( VOID );      // ntddk ntosp
#endif                                      // ntddk

// end_ntifs
// begin_wdm

FORCEINLINE
__drv_aliasesMem
PIO_STACK_LOCATION
IoGetCurrentIrpStackLocation(
    _In_ PIRP Irp
)
/*--

Routine Description:

    This routine is invoked to return a pointer to the current stack location
    in an I/O Request Packet (IRP).

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    The function value is a pointer to the current stack location in the
    packet.

--*/
{
    NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
    return Irp->Tail.Overlay.CurrentStackLocation;
}

// end_wdm
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceToVerify(
    _In_ PETHREAD Thread
    );
#endif

// end_ntifs
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__drv_aliasesMem
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PVOID ClientIdentificationAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PEPROCESS
IoGetCurrentProcess(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoGetDeviceObjectPointer(
    _In_  PUNICODE_STRING ObjectName,
    _In_  ACCESS_MASK DesiredAccess,
    _Out_ PFILE_OBJECT *FileObject,
    _Out_ PDEVICE_OBJECT *DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
struct _DMA_ADAPTER *
IoGetDmaAdapter(
    _In_opt_ PDEVICE_OBJECT PhysicalDeviceObject,           // required for PnP drivers
    _In_ struct _DEVICE_DESCRIPTION *DeviceDescription,
    _Out_ _When_(return!=0, _Kernel_IoGetDmaAdapter_ _At_(*NumberOfMapRegisters, _Must_inspect_result_))
    PULONG NumberOfMapRegisters
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
IoForwardIrpSynchronously(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp
    );

#define IoForwardAndCatchIrp IoForwardIrpSynchronously

#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
IoSynchronousCallDriver(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp
    );
#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    );
#endif

// end_ntddk
// begin_wdm

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     _In_ ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
IoGetInitialStack(
    VOID
    );
#endif

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
IoGetStackLimits (
    _Out_ PULONG_PTR LowLimit,
    _Out_ PULONG_PTR HighLimit
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
LOGICAL
IoWithinStackLimits(
    _In_ ULONG_PTR RegionStart,
    _In_ SIZE_T RegionSize
    );
#endif

// end_wdm
#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
FASTCALL
IoCallDriverStackSafe(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp,
    _In_ ULONG StackThreshold,
    _In_ ULONG FailIfNoSwitch
    );
#endif
// begin_wdm

#define IoCallDriverStackSafeDefault(a, b) IoCallDriver(a, b)

//
//  The following function is used to tell the caller how much stack is available
//

_IRQL_requires_max_(APC_LEVEL)
FORCEINLINE
ULONG_PTR
IoGetRemainingStackSize (
    VOID
    )
{
    ULONG_PTR Top;
    ULONG_PTR Bottom;

    IoGetStackLimits( &Bottom, &Top );
    return((ULONG_PTR)(&Top) - Bottom );
}

FORCEINLINE
__drv_aliasesMem
PIO_STACK_LOCATION
IoGetNextIrpStackLocation(
    _In_ PIRP Irp
    )
/*++
Routine Description:

    This routine is invoked to return a pointer to the next stack location
    in an I/O Request Packet (IRP).

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    The function value is a pointer to the next stack location in the packet.

--*/
{
    NT_ASSERT(Irp->CurrentLocation > 0);

    return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    _In_ PFILE_OBJECT FileObject
    );
#endif

// end_wdm
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
IoGetRequestorProcessId(
    _In_ PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PEPROCESS
IoGetRequestorProcess(
    _In_ PIRP Irp
    );
#endif

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoGetTopLevelIrp(
    VOID
    );
#endif

// end_ntifs

VOID
FORCEINLINE
IoInitializeDpcRequest(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIO_DPC_ROUTINE DpcRoutine
    )
/*++

Routine Description:

    This routine is invoked to initialize the DPC in a device object for a
    device driver during its initialization routine.  The DPC is used later
    when the driver interrupt service routine requests that a DPC routine
    be queued for later execution.

Arguments:

    DeviceObject - Pointer to the device object that the request is for.

    DpcRoutine - Address of the driver's DPC routine to be executed when
        the DPC is dequeued for processing.

Return Value:

    None.

--*/
{
    KeInitializeDpc( &DeviceObject->Dpc,
#pragma warning (suppress: 28024) // implementation of the required way
                     (PKDEFERRED_ROUTINE) DpcRoutine,
                     DeviceObject );
}

#if (NTDDI_VERSION >= NTDDI_WS03)
VOID
FORCEINLINE
IoInitializeThreadedDpcRequest(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIO_DPC_ROUTINE DpcRoutine
    )
/*++

Routine Description:

    This routine is invoked to initialize the DPC in a device object for a
    device driver during its initialization routine.  The DPC is used later
    when the driver interrupt service routine requests that a DPC routine
    be queued for later execution.

    This initializes the DPC as a threaded DPC.

Arguments:

    DeviceObject - Pointer to the device object that the request is for.

    DpcRoutine - Address of the driver's DPC routine to be executed when
        the DPC is dequeued for processing.

Return Value:

    None.

--*/
{
#pragma warning (suppress: 28128) // implementation of the required way
    KeInitializeThreadedDpc( &DeviceObject->Dpc,
#pragma warning (suppress: 28165 28024) // implementation of the required way
                             (PKDEFERRED_ROUTINE) DpcRoutine,
                             DeviceObject );
}
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoInitializeIrp(
    _Inout_ PIRP Irp,
    _In_ USHORT PacketSize,
    _In_ CCHAR StackSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN10)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoDestroyIrp(
    _Inout_ PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoInitializeIrpEx(
    _Inout_ PIRP Irp,
    _In_opt_ PDEVICE_OBJECT DeviceObject,
    _In_ USHORT PacketSize,
    _In_ CCHAR StackSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
#if defined(_AMD64_) || defined(_X86_)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoInitializeTimer(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIO_TIMER_ROUTINE TimerRoutine,
    _In_opt_ __drv_aliasesMem PVOID Context
    );
#endif
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoReuseIrp(
    _Inout_ PIRP Irp,
    _In_ NTSTATUS Iostatus
    );
#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoCancelFileOpen(
    _In_ PDEVICE_OBJECT  DeviceObject,
    _In_ PFILE_OBJECT    FileObject
    );
#endif


//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     _In_ NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PIRP
IoMakeAssociatedIrp(
    _In_ PIRP Irp,
    _In_ CCHAR StackSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PIRP
IoMakeAssociatedIrpEx(
    _In_ PIRP Irp,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ CCHAR StackSize
    );
#endif

// end_ntddk
// begin_wdm



FORCEINLINE
VOID
IoMarkIrpPending(
    _Inout_ PIRP Irp
)
/*++
Routine Description:

    This routine marks the specified I/O Request Packet (IRP) to indicate
    that an initial status of STATUS_PENDING was returned to the caller.
    This is used so that I/O completion can determine whether or not to
    fully complete the I/O operation requested by the packet.

Arguments:

    Irp - Pointer to the I/O Request Packet to be marked pending.

Return Value:

    None.

--*/
{
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoGetDeviceProperty
__drv_preferredFunction("IoGetDeviceProperty", "Obsolete")
NTKERNELAPI
NTSTATUS
IoQueryDeviceDescription(
    _In_opt_ PINTERFACE_TYPE BusType,
    _In_opt_ PULONG BusNumber,
    _In_opt_ PCONFIGURATION_TYPE ControllerType,
    _In_opt_ PULONG ControllerNumber,
    _In_opt_ PCONFIGURATION_TYPE PeripheralType,
    _In_opt_ PULONG PeripheralNumber,
    _In_ PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
    _Inout_opt_ PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoQueryFileInformation(
    _In_  PFILE_OBJECT FileObject,
    _In_  FILE_INFORMATION_CLASS FileInformationClass,
    _In_  ULONG Length,
    _Out_ PVOID FileInformation,
    _Out_ PULONG ReturnedLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoQueryVolumeInformation(
    _In_  PFILE_OBJECT FileObject,
    _In_  FS_INFORMATION_CLASS FsInformationClass,
    _In_  ULONG Length,
    _Out_ PVOID FsInformation,
    _Out_ PULONG ReturnedLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoQueueThreadIrp(
    _In_ PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
IoRaiseHardError(
    _In_ PIRP Irp,
    _In_opt_ PVPB Vpb,
    _In_ PDEVICE_OBJECT RealDeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
IoRaiseInformationalHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_opt_ PUNICODE_STRING String,
    _In_opt_ PKTHREAD Thread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
IoSetThreadHardErrorMode(
    _In_ BOOLEAN EnableHardErrors
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
IoRegisterBootDriverReinitialization(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    _In_opt_ PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
IoRegisterDriverReinitialization(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    _In_opt_ PVOID Context
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoRegisterLastChanceShutdownNotification(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Requires_lock_held_(_Global_cancel_spin_lock_)
_Releases_lock_(_Global_cancel_spin_lock_)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    _In_ _IRQL_restores_ _IRQL_uses_cancel_ KIRQL Irql
    );
#endif

// end_wdm
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoReleaseVpbSpinLock(
    _In_ KIRQL Irql
    );
#endif

// end_ntifs
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
IoRemoveShareAccess(
    _In_ PFILE_OBJECT FileObject,
    _Inout_ PSHARE_ACCESS ShareAccess
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoReportResourceForDetection
__drv_preferredFunction("IoReportResourceForDetection if needed", "Obsolete")
NTKERNELAPI
NTSTATUS
IoReportResourceUsage(
    _In_opt_ PUNICODE_STRING DriverClassName,
    _In_  PDRIVER_OBJECT DriverObject,
    _In_reads_bytes_opt_(DriverListSize) PCM_RESOURCE_LIST DriverList,
    _In_opt_ ULONG DriverListSize,
    _In_opt_  PDEVICE_OBJECT DeviceObject,
    _In_reads_bytes_opt_(DeviceListSize) PCM_RESOURCE_LIST DeviceList,
    _In_opt_ ULONG DeviceListSize,
    _In_  BOOLEAN OverrideConflict,
    _Out_ PBOOLEAN ConflictDetected
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
BOOLEAN
IoTranslateBusAddress(
    _In_  INTERFACE_TYPE InterfaceType,
    _In_  ULONG BusNumber,
    _In_  PHYSICAL_ADDRESS BusAddress,
    _Inout_ PULONG AddressSpace,
    _Out_ PPHYSICAL_ADDRESS TranslatedAddress
    );
#endif

// end_ntddk
// begin_wdm


#if (NTDDI_VERSION >= NTDDI_WIN2K)
FORCEINLINE
VOID
IoRequestDpc(
    _Inout_  PDEVICE_OBJECT DeviceObject,
    _In_opt_ PIRP Irp,
    _In_opt_ __drv_aliasesMem PVOID Context
    )
//++
//
// Routine Description:
//
//     This routine is invoked by the device driver's interrupt service routine
//     to request that a DPC routine be queued for later execution at a lower
//     IRQL.
//
// Arguments:
//
//     DeviceObject - Device object for which the request is being processed.
//
//     Irp - Pointer to the current I/O Request Packet (IRP) for the specified
//         device.
//
//     Context - Provides a general context parameter to be passed to the
//         DPC routine.
//
// Return Value:
//
//     None.
//
//--
{
    KeInsertQueueDpc( &DeviceObject->Dpc, Irp, Context );
}
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
// end_wdm
#if !defined(NONTOSPINTERLOCK)
// begin_wdm
_IRQL_requires_max_(DISPATCH_LEVEL)
_Ret_maybenull_
FORCEINLINE
PDRIVER_CANCEL
IoSetCancelRoutine(
    _Inout_  PIRP Irp,
    _In_opt_ PDRIVER_CANCEL CancelRoutine
    )
//++
//
// Routine Description:
//
//     This routine is invoked to set the address of a cancel routine which
//     is to be invoked when an I/O packet has been canceled.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CancelRoutine - Address of the cancel routine that is to be invoked
//         if the IRP is cancelled.
//
// Return Value:
//
//     Previous value of CancelRoutine field in the IRP.
//
//--
{
    return (PDRIVER_CANCEL)(ULONG_PTR) InterlockedExchangePointer((PVOID *)&(Irp)->CancelRoutine, (PVOID)(ULONG_PTR)(CancelRoutine) );
}
// end_wdm
#endif // !defined(NONTOSPINTERLOCK)
// begin_wdm
#endif

_IRQL_requires_max_(DISPATCH_LEVEL)
FORCEINLINE
VOID
IoSetCompletionRoutine(
    _In_ PIRP Irp,
    _In_opt_ PIO_COMPLETION_ROUTINE CompletionRoutine,
    _In_opt_ __drv_aliasesMem PVOID Context,
    _In_ BOOLEAN InvokeOnSuccess,
    _In_ BOOLEAN InvokeOnError,
    _In_ BOOLEAN InvokeOnCancel
    )
//++
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--
{
    PIO_STACK_LOCATION irpSp;
    NT_ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );
    irpSp = IoGetNextIrpStackLocation(Irp);
    irpSp->CompletionRoutine = CompletionRoutine;
    irpSp->Context = Context;
    irpSp->Control = 0;

    if (InvokeOnSuccess) {
        irpSp->Control = SL_INVOKE_ON_SUCCESS;
    }

    if (InvokeOnError) {
        irpSp->Control |= SL_INVOKE_ON_ERROR;
    }

    if (InvokeOnCancel) {
        irpSp->Control |= SL_INVOKE_ON_CANCEL;
    }
}

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
_Must_inspect_result_
NTSTATUS
IoSetCompletionRoutineEx(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp,
    _In_ PIO_COMPLETION_ROUTINE CompletionRoutine,
    _In_opt_ PVOID Context,
    _In_ BOOLEAN InvokeOnSuccess,
    _In_ BOOLEAN InvokeOnError,
    _In_ BOOLEAN InvokeOnCancel
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoSetHardErrorOrVerifyDevice(
    _In_ PIRP Irp,
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

// end_ntddk
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoSetInformation(
    _In_ PFILE_OBJECT FileObject,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ ULONG Length,
    _In_ PVOID FileInformation
    );
#endif

// end_ntifs

FORCEINLINE
VOID
IoSetNextIrpStackLocation (
   _Inout_ PIRP Irp
    )
/*--

Routine Description:

    This routine is invoked to set the current IRP stack location to
    the next stack location, i.e. it "pushes" the stack.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP).

Return Value:

    None.

--*/
{
    NT_ASSERT(Irp->CurrentLocation > 0);
    Irp->CurrentLocation--;
    Irp->Tail.Overlay.CurrentStackLocation--;
}

FORCEINLINE
VOID
IoCopyCurrentIrpStackLocationToNext(
    _Inout_ PIRP Irp
)
/*--

Routine Description:

    This routine is invoked to copy the IRP stack arguments and file
    pointer from the current IrpStackLocation to the next
    in an I/O Request Packet (IRP).

    If the caller wants to call IoCallDriver with a completion routine
    but does not wish to change the arguments otherwise,
    the caller first calls IoCopyCurrentIrpStackLocationToNext,
    then IoSetCompletionRoutine, then IoCallDriver.

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));
    nextIrpSp->Control = 0;
}

FORCEINLINE
VOID
IoSkipCurrentIrpStackLocation (
    _Inout_ PIRP Irp
)
/*--
Routine Description:

    This routine is invoked to increment the current stack location of
    a given IRP.

    If the caller wishes to call the next driver in a stack, and does not
    wish to change the arguments, nor does he wish to set a completion
    routine, then the caller first calls IoSkipCurrentIrpStackLocation
    and the calls IoCallDriver.

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    None
--*/
{
    NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount);
    Irp->CurrentLocation++;
    Irp->Tail.Overlay.CurrentStackLocation++;
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoSetShareAccess(
    _In_  ACCESS_MASK DesiredAccess,
    _In_  ULONG DesiredShareAccess,
    _Inout_ PFILE_OBJECT FileObject,
    _Out_ PSHARE_ACCESS ShareAccess
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
IoSetShareAccessEx(
    _In_  ACCESS_MASK DesiredAccess,
    _In_  ULONG DesiredShareAccess,
    _Inout_ PFILE_OBJECT FileObject,
    _Out_ PSHARE_ACCESS ShareAccess,
    _In_ PBOOLEAN WritePermission
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoSetTopLevelIrp(
    _In_opt_ PIRP Irp
    );
#endif


typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK * PIO_REMOVE_LOCK_TRACKING_BLOCK;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    BOOLEAN     Removed;
    BOOLEAN     Reserved [3];
    __volatile LONG        IoCount;
    KEVENT      RemoveEvent;

} IO_REMOVE_LOCK_COMMON_BLOCK;

typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
    LONG        Signature;
    ULONG       HighWatermark;
    LONGLONG    MaxLockedTicks;
    LONG        AllocateTag;
    LIST_ENTRY  LockList;
    KSPIN_LOCK  Spin;
    __volatile LONG        LowMemoryCount;
    ULONG       Reserved1[4];
    PVOID       Reserved2;
    PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks;
} IO_REMOVE_LOCK_DBG_BLOCK;

typedef struct _IO_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
#if DBG
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
#endif
} IO_REMOVE_LOCK, *PIO_REMOVE_LOCK;

#define IoInitializeRemoveLock(Lock, Tag, Maxmin, HighWater) \
        IoInitializeRemoveLockEx (Lock, Tag, Maxmin, HighWater, sizeof (IO_REMOVE_LOCK))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    _Out_ PIO_REMOVE_LOCK Lock,
    _In_ ULONG  AllocateTag, // Used only on checked kernels
    _In_ ULONG  MaxLockedMinutes, // Used only on checked kernels
    _In_ ULONG  HighWatermark, // Used only on checked kernels
    _In_ ULONG  RemlockSize // are we checked or free
    );
#endif

//
//  Initialize a remove lock.
//
//  Note: Allocation for remove locks needs to be within the device extension,
//  so that the memory for this structure stays allocated until such time as the
//  device object itself is deallocated.
//

#if DBG
#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, __FILE__, __LINE__, sizeof (IO_REMOVE_LOCK))
#else
#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, "", 1, sizeof (IO_REMOVE_LOCK))
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx (
    _Inout_ PIO_REMOVE_LOCK RemoveLock,
    _In_opt_ PVOID          Tag, // Optional
    _In_ PCSTR              File,
    _In_ ULONG              Line,
    _In_ ULONG              RemlockSize // are we checked or free
    );
#endif

//
// Routine Description:
//
//    This routine is called to acquire the remove lock for a device object.
//    While the lock is held, the caller can assume that no pending pnp REMOVE
//    requests will be completed.
//
//    The lock should be acquired immediately upon entering a dispatch routine.
//    It should also be acquired before creating any new reference to the
//    device object if there's a chance of releasing the reference before the
//    new one is done, in addition to references to the driver code itself,
//    which is removed from memory when the last device object goes.
//
//    Arguments:
//
//    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.
//
//    Tag - Used for tracking lock allocation and release.  The same tag
//          specified when acquiring the lock must be used to release the lock.
//          Tags are only checked in checked versions of the driver.
//
//    File - set to __FILE__ as the location in the code where the lock was taken.
//
//    Line - set to __LINE__.
//
// Return Value:
//
//    Returns whether or not the remove lock was obtained.
//    If successful the caller should continue with work calling
//    IoReleaseRemoveLock when finished.
//
//    If not successful the lock was not obtained.  The caller should abort the
//    work but not call IoReleaseRemoveLock.
//

#define IoReleaseRemoveLock(RemoveLock, Tag) \
        IoReleaseRemoveLockEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    _Inout_ PIO_REMOVE_LOCK RemoveLock,
    _In_opt_ PVOID          Tag, // Optional
    _In_ ULONG              RemlockSize // are we checked or free
    );
#endif

//
//
// Routine Description:
//
//    This routine is called to release the remove lock on the device object.  It
//    must be called when finished using a previously locked reference to the
//    device object.  If an Tag was specified when acquiring the lock then the
//    same Tag must be specified when releasing the lock.
//
//    When the lock count reduces to zero, this routine will signal the waiting
//    event to release the waiting thread deleting the device object protected
//    by this lock.
//
// Arguments:
//
//    DeviceObject - the device object to lock
//
//    Tag - The TAG (if any) specified when acquiring the lock.  This is used
//          for lock tracking purposes
//
// Return Value:
//
//    none
//

#define IoReleaseRemoveLockAndWait(RemoveLock, Tag) \
        IoReleaseRemoveLockAndWaitEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx(
    _Inout_ PIO_REMOVE_LOCK RemoveLock,
    _In_opt_ PVOID       Tag,
    _In_ ULONG           RemlockSize // are we checked or free
    );
#endif

//
//
// Routine Description:
//
//    This routine is called when the client would like to delete the
//    remove-locked resource.  This routine will block until all the remove
//    locks have released.
//
//    This routine MUST be called after acquiring the lock.
//
// Arguments:
//
//    RemoveLock
//
// Return Value:
//
//    none
//


//++
//
// USHORT
// IoSizeOfIrp(
//     _In_ CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(DISPATCH_LEVEL) _IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
USHORT
IoSizeOfIrpEx(
    _In_opt_ PDEVICE_OBJECT DeviceObject,
    _In_ CCHAR StackSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL) _IRQL_requires_min_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoStartNextPacket(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ BOOLEAN Cancelable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoStartNextPacketByKey(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ BOOLEAN Cancelable,
    _In_ ULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoStartPacket(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp,
    _In_opt_ PULONG Key,
    _In_opt_ PDRIVER_CANCEL CancelFunction
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
VOID
IoSetStartIoAttributes(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ BOOLEAN DeferredStartIo,
    _In_ BOOLEAN NonCancelable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
#if defined(_AMD64_) || defined(_X86_)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoStartTimer(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
#if defined(_AMD64_) || defined(_X86_)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoStopTimer(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PEPROCESS
IoThreadToProcess(
    _In_ PETHREAD Thread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
IoUnregisterShutdownNotification(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
IoUpdateShareAccess(
    _In_ PFILE_OBJECT FileObject,
    _Inout_ PSHARE_ACCESS ShareAccess
    );
#endif

// end_wdm
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoVerifyVolume(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ BOOLEAN AllowRawMount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)              // wdm
_IRQL_requires_max_(DISPATCH_LEVEL)                   // wdm
NTKERNELAPI                                     // wdm
VOID                                            // wdm
IoWriteErrorLogEntry(                           // wdm
    _In_ PVOID ElEntry                          // wdm
    );                                          // wdm
#endif                                          // wdm


NTKERNELAPI
NTSTATUS
IoCreateDriver (
    _In_opt_ PUNICODE_STRING DriverName,
    _In_ PDRIVER_INITIALIZE InitializationFunction
    );

NTKERNELAPI
VOID
IoDeleteDriver (
    _In_ PDRIVER_OBJECT DriverObject
    );


#if (NTDDI_VERSION >= NTDDI_WIN8)

_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
_Must_inspect_result_
NTSTATUS
IoCreateSystemThread(
    _Inout_ PVOID IoObject,
    _Out_ PHANDLE ThreadHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ HANDLE ProcessHandle,
    _Out_opt_ PCLIENT_ID ClientId,
    _In_ PKSTART_ROUTINE StartRoutine,
    _In_opt_ PVOID StartContext
    );

#endif

typedef struct _IO_WORKITEM *PIO_WORKITEM;

_Function_class_(IO_WORKITEM_ROUTINE)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
typedef
VOID
IO_WORKITEM_ROUTINE (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_opt_ PVOID Context
    );

typedef IO_WORKITEM_ROUTINE *PIO_WORKITEM_ROUTINE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)

__drv_allocatesMem(Mem)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTKERNELAPI
PIO_WORKITEM
IoAllocateWorkItem(
    _In_ PDEVICE_OBJECT DeviceObject
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoFreeWorkItem(
    _In_ __drv_freesMem(Mem) PIO_WORKITEM IoWorkItem
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoQueueWorkItem(
    _Inout_ __drv_aliasesMem PIO_WORKITEM IoWorkItem,
    _In_ PIO_WORKITEM_ROUTINE WorkerRoutine,
    _In_ WORK_QUEUE_TYPE QueueType,
    _In_opt_ __drv_aliasesMem PVOID Context
    );

#endif

_Function_class_(IO_WORKITEM_ROUTINE_EX)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
typedef
VOID
IO_WORKITEM_ROUTINE_EX (
    _In_ PVOID IoObject,
    _In_opt_ PVOID Context,
    _In_ PIO_WORKITEM IoWorkItem
    );

typedef IO_WORKITEM_ROUTINE_EX *PIO_WORKITEM_ROUTINE_EX;

#if (NTDDI_VERSION >= NTDDI_VISTA)

_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
IoQueueWorkItemEx(
    _Inout_ __drv_aliasesMem PIO_WORKITEM IoWorkItem,
    _In_ PIO_WORKITEM_ROUTINE_EX WorkerRoutine,
    _In_ WORK_QUEUE_TYPE QueueType,
    _In_opt_ __drv_aliasesMem PVOID Context
    );

ULONG
IoSizeofWorkItem(
    VOID
    );

VOID
IoInitializeWorkItem(
    _In_ PVOID IoObject,
    _Out_ PIO_WORKITEM IoWorkItem
    );

VOID
IoUninitializeWorkItem(
    _Inout_ PIO_WORKITEM IoWorkItem
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)

_IRQL_requires_max_(DISPATCH_LEVEL)
BOOLEAN
IoTryQueueWorkItem(
    _Inout_ __drv_when(return != 0, __drv_aliasesMem) PIO_WORKITEM IoWorkItem,
    _In_ PIO_WORKITEM_ROUTINE_EX WorkerRoutine,
    _In_ WORK_QUEUE_TYPE QueueType,
    _In_opt_ __drv_aliasesMem PVOID Context
    );

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoWMIRegistrationControl(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG Action
);
#endif

//
// Action code for IoWMIRegistrationControl api
//

#define WMIREG_ACTION_REGISTER      1
#define WMIREG_ACTION_DEREGISTER    2
#define WMIREG_ACTION_REREGISTER    3
#define WMIREG_ACTION_UPDATE_GUIDS  4
#define WMIREG_ACTION_BLOCK_IRPS    5

//
// Code passed in IRP_MN_REGINFO WMI irp
//

#define WMIREGISTER                 0
#define WMIUPDATE                   1

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoWMIAllocateInstanceIds(
    _In_ LPCGUID Guid,
    _In_ ULONG InstanceCount,
    _Out_ ULONG *FirstInstanceId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoWMISuggestInstanceName(
    _In_opt_ PDEVICE_OBJECT PhysicalDeviceObject,
    _In_opt_ PUNICODE_STRING SymbolicLinkName,
    _In_ BOOLEAN CombineNames,
    _Out_ PUNICODE_STRING SuggestedInstanceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(DISPATCH_LEVEL)
_Ret_range_(<=, 0)
NTKERNELAPI
NTSTATUS
IoWMIWriteEvent(
    _Inout_ _When_(return==0, __drv_aliasesMem) PVOID WnodeEventItem
    );
#endif

#if defined(_WIN64)
NTKERNELAPI
ULONG
IoWMIDeviceObjectToProviderId(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#else
#define IoWMIDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIOpenBlock (
    _In_ LPCGUID Guid,
    _In_ ULONG DesiredAccess,
    _Out_ PVOID *DataBlockObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIQueryAllData (
    _In_ PVOID DataBlockObject,
    _Inout_ PULONG InOutBufferSize,
    _Out_writes_bytes_opt_(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIQueryAllDataMultiple (
    _In_reads_(ObjectCount) PVOID *DataBlockObjectList,
    _In_ ULONG ObjectCount,
    _Inout_ PULONG InOutBufferSize,
    _Out_writes_bytes_opt_(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstance (
    _In_ PVOID DataBlockObject,
    _In_ PUNICODE_STRING InstanceName,
    _Inout_ PULONG InOutBufferSize,
    _Out_writes_bytes_opt_(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstanceMultiple (
    _In_reads_(ObjectCount) PVOID *DataBlockObjectList,
    _In_reads_(ObjectCount) PUNICODE_STRING InstanceNames,
    _In_ ULONG ObjectCount,
    _Inout_ PULONG InOutBufferSize,
    _Out_writes_bytes_opt_(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMISetSingleInstance(
    _In_ PVOID DataBlockObject,
    _In_ PUNICODE_STRING InstanceName,
    _In_ ULONG Version,
    _In_ ULONG ValueBufferSize,
    _In_reads_bytes_(ValueBufferSize) PVOID ValueBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMISetSingleItem(
    _In_ PVOID DataBlockObject,
    _In_ PUNICODE_STRING InstanceName,
    _In_ ULONG DataItemId,
    _In_ ULONG Version,
    _In_ ULONG ValueBufferSize,
    _In_reads_bytes_(ValueBufferSize) PVOID ValueBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIExecuteMethod(
    _In_ PVOID DataBlockObject,
    _In_ PUNICODE_STRING InstanceName,
    _In_ ULONG MethodId,
    _In_ ULONG InBufferSize,
    _Inout_ PULONG OutBufferSize,
    _Inout_updates_bytes_to_opt_(*OutBufferSize, InBufferSize) PUCHAR InOutBuffer
    );
#endif

typedef
_Function_class_(WMI_NOTIFICATION_CALLBACK)
_IRQL_requires_same_
VOID FWMI_NOTIFICATION_CALLBACK (
    PVOID Wnode,
    PVOID Context
    );
typedef FWMI_NOTIFICATION_CALLBACK *WMI_NOTIFICATION_CALLBACK;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMISetNotificationCallback(
    _Inout_ PVOID Object,
    _In_ WMI_NOTIFICATION_CALLBACK Callback,
    _In_opt_ PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIHandleToInstanceName(
    _In_ PVOID DataBlockObject,
    _In_ HANDLE FileHandle,
    _Out_ PUNICODE_STRING InstanceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIDeviceObjectToInstanceName(
    _In_ PVOID DataBlockObject,
    _In_ PDEVICE_OBJECT DeviceObject,
    _Out_ PUNICODE_STRING InstanceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    _In_ PVOID IoCompletion,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation,
    _In_ BOOLEAN Quota
    );
#endif

typedef
VOID
IO_MINI_PACKET_CALLBACK_ROUTINE (
    _In_ struct _IO_MINI_COMPLETION_PACKET_USER * MiniPacket,
    _In_opt_ PVOID Context
);

typedef IO_MINI_PACKET_CALLBACK_ROUTINE *PIO_MINI_PACKET_CALLBACK_ROUTINE;

//
// User allocated mini packet (via IoAllocateMiniCompletionPacket)
//
typedef struct _IO_MINI_COMPLETION_PACKET_USER {
    LIST_ENTRY ListEntry;
    ULONG PacketType;
    PVOID KeyContext;
    PVOID ApcContext;
    NTSTATUS IoStatus;
    ULONG_PTR IoStatusInformation;
    PIO_MINI_PACKET_CALLBACK_ROUTINE MiniPacketCallback;
    PVOID Context;
    BOOLEAN Allocated;
} IO_MINI_COMPLETION_PACKET_USER, *PIO_MINI_COMPLETION_PACKET_USER;

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoSetIoCompletionEx(
    _In_ PVOID IoCompletion,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation,
    _In_ BOOLEAN Quota,
    _In_opt_ PIO_MINI_COMPLETION_PACKET_USER MiniPacket
);
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
PIO_MINI_COMPLETION_PACKET_USER
IoAllocateMiniCompletionPacket(
    _In_ PIO_MINI_PACKET_CALLBACK_ROUTINE CallbackRoutine,
    _In_opt_ PVOID Context
);
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
IoInitializeMiniCompletionPacket(
    _Inout_ PIO_MINI_COMPLETION_PACKET_USER MiniPacket,
    _In_ PIO_MINI_PACKET_CALLBACK_ROUTINE CallbackRoutine,
    _In_opt_ PVOID Context
);
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
IoFreeMiniCompletionPacket(
    _Inout_ PIO_MINI_COMPLETION_PACKET_USER MiniPacket
);
#endif


_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
IoIs32bitProcess(
    _In_opt_ PIRP Irp
    );

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
IoIsInitiator32bitProcess(
    _In_ PIRP Irp
    );
#endif // NTDDI_VERSION >= NTDDI_WIN8

#if (NTDDI_VERSION >= NTDDI_WINXP)
DECLSPEC_DEPRECATED_DDK                 // Use IoWritePartitionTableEx
_IRQL_requires_max_(PASSIVE_LEVEL)
__drv_preferredFunction("IoWritePartitionTableEx", "Obsolete")
NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG SectorSize,
    _In_ ULONG SectorsPerTrack,
    _In_ ULONG NumberOfHeads,
    _In_ struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoCreateDisk(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_opt_ struct _CREATE_DISK* Disk
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoReadPartitionTableEx(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Out_ struct _DRIVE_LAYOUT_INFORMATION_EX** DriveLayout
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoWritePartitionTableEx(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_reads_(_Inexpressible_(FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]))) struct _DRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoSetPartitionInformationEx(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG PartitionNumber,
    _In_ struct _SET_PARTITION_INFORMATION_EX* PartitionInfo
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoUpdateDiskGeometry(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ struct _DISK_GEOMETRY_EX* OldDiskGeometry,
    _In_ struct _DISK_GEOMETRY_EX* NewDiskGeometry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoVerifyPartitionTable(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ BOOLEAN FixErrors
    );
#endif

typedef struct _DISK_SIGNATURE {
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;

        struct {
            GUID DiskId;
        } Gpt;
    };
} DISK_SIGNATURE, *PDISK_SIGNATURE;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoReadDiskSignature(
    _In_  PDEVICE_OBJECT DeviceObject,
    _In_  ULONG BytesPerSector,
    _Out_ PDISK_SIGNATURE Signature
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoVolumeDeviceToDosName(
    _In_  PVOID           VolumeDeviceObject,
    _Out_ _When_(return==0,
          _At_(DosName->Buffer, __drv_allocatesMem(Mem)))
          PUNICODE_STRING DosName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
IoVolumeDeviceToGuidPath(
    _In_  PVOID           VolumeDeviceObject,
    _Out_ _When_(return==0,
          _At_(DosName->Buffer, __drv_allocatesMem(Mem)))
          PUNICODE_STRING GuidPath
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
IoVolumeDeviceToGuid(
    _In_  PVOID           VolumeDeviceObject,
    _Out_ GUID            *Guid
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoEnumerateDeviceObjectList(
    _In_  PDRIVER_OBJECT DriverObject,
    _Out_writes_bytes_to_opt_(DeviceObjectListSize,(*ActualNumberDeviceObjects)*sizeof(PDEVICE_OBJECT)) PDEVICE_OBJECT *DeviceObjectList,
    _In_  ULONG          DeviceObjectListSize,
    _Out_ PULONG         ActualNumberDeviceObjects
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PDEVICE_OBJECT
IoGetLowerDeviceObject(
    _In_  PDEVICE_OBJECT  DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoGetDiskDeviceObject(
    _In_  PDEVICE_OBJECT FileSystemDeviceObject,
    _Out_ PDEVICE_OBJECT *DiskDeviceObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoSetSystemPartition(
    _In_ PUNICODE_STRING VolumeNameString
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
IoFreeErrorLogEntry(
    _In_ PVOID ElEntry
    );
#endif

// Cancel SAFE API set start
//
// The following APIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of APIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue API set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel API code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel API set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//


//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2
#define IO_TYPE_CSQ_EX          3

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//

typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
IO_CSQ_INSERT_IRP (
    _In_ struct _IO_CSQ    *Csq,
    _In_ PIRP              Irp
    );

typedef IO_CSQ_INSERT_IRP *PIO_CSQ_INSERT_IRP;

typedef NTSTATUS
IO_CSQ_INSERT_IRP_EX (
    _In_ struct _IO_CSQ    *Csq,
    _In_ PIRP              Irp,
    _In_ PVOID             InsertContext
    );

typedef IO_CSQ_INSERT_IRP_EX *PIO_CSQ_INSERT_IRP_EX;

typedef VOID
IO_CSQ_REMOVE_IRP (
    _In_ PIO_CSQ Csq,
    _In_ PIRP    Irp
    );

typedef IO_CSQ_REMOVE_IRP *PIO_CSQ_REMOVE_IRP;

//
// Retrieves next entry after Irp from the queue.
// Returns NULL if there are no entries in the queue.
// If Irp is NUL, returns the entry in the head of the queue.
// This routine does not remove the IRP from the queue.
//


typedef PIRP
IO_CSQ_PEEK_NEXT_IRP (
    _In_ PIO_CSQ Csq,
    _In_ PIRP    Irp,
    _In_ PVOID   PeekContext
    );

typedef IO_CSQ_PEEK_NEXT_IRP *PIO_CSQ_PEEK_NEXT_IRP;

//
// Lock routine that protects the cancel safe queue.
//

typedef VOID
IO_CSQ_ACQUIRE_LOCK (
     _In_ PIO_CSQ Csq,
     _Out_ PKIRQL  Irql
     );

typedef IO_CSQ_ACQUIRE_LOCK *PIO_CSQ_ACQUIRE_LOCK;

typedef VOID
IO_CSQ_RELEASE_LOCK (
     _In_ PIO_CSQ Csq,
     _In_ KIRQL   Irql
     );

typedef IO_CSQ_RELEASE_LOCK *PIO_CSQ_RELEASE_LOCK;

//
// Completes the IRP with STATUS_CANCELLED. IRP is guaranteed to be valid
// In most cases this routine just calls IoCompleteRequest(Irp, STATUS_CANCELLED);
//

typedef VOID
IO_CSQ_COMPLETE_CANCELED_IRP (
    _In_ PIO_CSQ    Csq,
    _In_ PIRP       Irp
    );

typedef IO_CSQ_COMPLETE_CANCELED_IRP *PIO_CSQ_COMPLETE_CANCELED_IRP;

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ {
    ULONG                            Type;
    PIO_CSQ_INSERT_IRP               CsqInsertIrp;
    PIO_CSQ_REMOVE_IRP               CsqRemoveIrp;
    PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp;
    PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock;
    PIO_CSQ_RELEASE_LOCK             CsqReleaseLock;
    PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp;
    PVOID                            ReservePointer;    // Future expansion
} IO_CSQ, *PIO_CSQ;

//
// Initializes the cancel queue structure.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoCsqInitialize(
    _Out_ PIO_CSQ                       Csq,
    _In_ PIO_CSQ_INSERT_IRP             CsqInsertIrp,
    _In_ PIO_CSQ_REMOVE_IRP             CsqRemoveIrp,
    _In_ PIO_CSQ_PEEK_NEXT_IRP          CsqPeekNextIrp,
    _In_ PIO_CSQ_ACQUIRE_LOCK           CsqAcquireLock,
    _In_ PIO_CSQ_RELEASE_LOCK           CsqReleaseLock,
    _In_ PIO_CSQ_COMPLETE_CANCELED_IRP  CsqCompleteCanceledIrp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
NTSTATUS
IoCsqInitializeEx(
    _Out_ PIO_CSQ                       Csq,
    _In_ PIO_CSQ_INSERT_IRP_EX          CsqInsertIrp,
    _In_ PIO_CSQ_REMOVE_IRP             CsqRemoveIrp,
    _In_ PIO_CSQ_PEEK_NEXT_IRP          CsqPeekNextIrp,
    _In_ PIO_CSQ_ACQUIRE_LOCK           CsqAcquireLock,
    _In_ PIO_CSQ_RELEASE_LOCK           CsqReleaseLock,
    _In_ PIO_CSQ_COMPLETE_CANCELED_IRP  CsqCompleteCanceledIrp
    );
#endif

//
// The caller calls this routine to insert the IRP and return STATUS_PENDING.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
IoCsqInsertIrp(
    _Inout_ PIO_CSQ               Csq,
    _Inout_ PIRP                  Irp,
    _Out_opt_ PIO_CSQ_IRP_CONTEXT Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
NTSTATUS
IoCsqInsertIrpEx(
    _Inout_ PIO_CSQ               Csq,
    _Inout_ PIRP              Irp,
    _Out_opt_ PIO_CSQ_IRP_CONTEXT Context,
    _In_opt_ PVOID                InsertContext
    );
#endif

//
// Returns an IRP if one can be found. NULL otherwise.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PIRP
IoCsqRemoveNextIrp(
    _Inout_  PIO_CSQ Csq,
    _In_opt_ PVOID   PeekContext
    );
#endif

//
// This routine is called from timeout or DPCs.
// The context is presumably part of the DPC or timer context.
// If succesfull returns the IRP associated with context.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PIRP
IoCsqRemoveIrp(
    _Inout_ PIO_CSQ             Csq,
    _Inout_ PIO_CSQ_IRP_CONTEXT Context
    );
#endif

// Cancel SAFE API set end


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoCreateFileSpecifyDeviceObjectHint(
    _Out_ PHANDLE FileHandle,
    _In_  ACCESS_MASK DesiredAccess,
    _In_  POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_  ULONG FileAttributes,
    _In_  ULONG ShareAccess,
    _In_  ULONG Disposition,
    _In_  ULONG CreateOptions,
    _In_opt_ PVOID EaBuffer,
    _In_  ULONG EaLength,
    _In_  CREATE_FILE_TYPE CreateFileType,
    _In_opt_ PVOID InternalParameters,
    _In_  ULONG Options,
    _In_opt_ PVOID DeviceObject
    );
#endif

typedef struct _TXN_PARAMETER_BLOCK {

    USHORT Length;              // sizeof( TXN_PARAMETER_BLOCK )
    USHORT TxFsContext;         // this is mini version of the requested file
    PVOID  TransactionObject;   // referenced pointer to KTRANSACTION

} TXN_PARAMETER_BLOCK, *PTXN_PARAMETER_BLOCK;

//
//  This value should be used in the TxFsContext member of the
//  TXN_PARAMETER_BLOCK in the absence of a specific miniversion.
//

#define TXF_MINIVERSION_DEFAULT_VIEW        (0xFFFE)

#if (NTDDI_VERSION >= NTDDI_VISTA)
PTXN_PARAMETER_BLOCK
IoGetTransactionParameterBlock (
    _In_ PFILE_OBJECT FileObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

//
// ECP context for creating a user mode process. Licensing and antimalware use
// the ECP to determine if the target process can be launched.
//

typedef struct _CREATE_USER_PROCESS_ECP_CONTEXT {
    //
    //  This must be set to the size of this structure.
    //

    USHORT Size;

    //
    //  This must be set to zero.
    //

    USHORT Reserved;

    //
    // The access token of the process that is getting created.
    //

    PACCESS_TOKEN AccessToken;

} CREATE_USER_PROCESS_ECP_CONTEXT, *PCREATE_USER_PROCESS_ECP_CONTEXT;

// {E0E429FF-6DDC-4E65-AAB6-45D05A038A08}
DEFINE_GUID(GUID_ECP_CREATE_USER_PROCESS, 0xe0e429ff, 0x6ddc, 0x4e65, 0xaa, 0xb6, 0x45, 0xd0, 0x5a, 0x3, 0x8a, 0x8);

#endif // NTDDI_VERSION >= NTDDI_WINTHRESHOLD

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct _OPLOCK_KEY_ECP_CONTEXT *POPLOCK_KEY_ECP_CONTEXT;

POPLOCK_KEY_ECP_CONTEXT
IoGetOplockKeyContext (
    _In_ PFILE_OBJECT FileObject
    );
#endif // NTDDI_VERSION >= NTDDI_WIN7

#if (NTDDI_VERSION >= NTDDI_WIN8)
//
//  This structure holds parent and target oplock keys.  This is what gets returned
//  to drivers who call  IoGetOplockKeyContextEx.
//

typedef struct _OPLOCK_KEY_CONTEXT {

    USHORT Version;        //  OPLOCK_KEY_VERSION_*
    USHORT Flags;          //  OPLOCK_KEY_FLAG_*

    GUID ParentOplockKey;

    GUID TargetOplockKey;

    ULONG Reserved;

} OPLOCK_KEY_CONTEXT, *POPLOCK_KEY_CONTEXT;

#define OPLOCK_KEY_VERSION_WIN7     0x0001
#define OPLOCK_KEY_VERSION_WIN8     0x0002

#define OPLOCK_KEY_FLAG_PARENT_KEY  0x0001
#define OPLOCK_KEY_FLAG_TARGET_KEY  0x0002

POPLOCK_KEY_CONTEXT
IoGetOplockKeyContextEx (
    _In_ PFILE_OBJECT FileObject
    );
#endif // NTDDI_VERSION >= NTDDI_WIN8

typedef struct _IO_DRIVER_CREATE_CONTEXT {
    CSHORT Size;
    struct _ECP_LIST *ExtraCreateParameter;
    PVOID DeviceObjectHint;
    PTXN_PARAMETER_BLOCK TxnParameters;
} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;

VOID
FORCEINLINE
IoInitializeDriverCreateContext(
    PIO_DRIVER_CREATE_CONTEXT DriverContext
    )
{
    // Initialize the context
    RtlZeroMemory(DriverContext, sizeof(IO_DRIVER_CREATE_CONTEXT));
    DriverContext->Size = sizeof(IO_DRIVER_CREATE_CONTEXT);
}

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoCreateFileEx(
    _Out_ PHANDLE FileHandle,
    _In_  ACCESS_MASK DesiredAccess,
    _In_  POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_  ULONG FileAttributes,
    _In_  ULONG ShareAccess,
    _In_  ULONG Disposition,
    _In_  ULONG CreateOptions,
    _In_opt_ PVOID EaBuffer,
    _In_  ULONG EaLength,
    _In_  CREATE_FILE_TYPE CreateFileType,
    _In_opt_ PVOID InternalParameters,
    _In_  ULONG Options,
    _In_opt_ PIO_DRIVER_CREATE_CONTEXT DriverContext
    );

NTSTATUS
IoSetIrpExtraCreateParameter(
    _Inout_ PIRP Irp,
    _In_ struct _ECP_LIST *ExtraCreateParameter
    );

VOID
IoClearIrpExtraCreateParameter(
    _Inout_ PIRP Irp
    );

NTSTATUS
IoGetIrpExtraCreateParameter(
    _In_ PIRP Irp,
    _Outptr_result_maybenull_ struct _ECP_LIST **ExtraCreateParameter
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoAttachDeviceToDeviceStackSafe(
    _In_  PDEVICE_OBJECT SourceDevice,
    _In_  PDEVICE_OBJECT TargetDevice,
    _Outptr_ PDEVICE_OBJECT *AttachedToDeviceObject
    );
#endif

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
NTKERNELAPI
NTSTATUS
IoValidateDeviceIoControlAccess(
    _In_ PIRP   Irp,
    _In_ ULONG  RequiredAccess
    );
#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
IO_PAGING_PRIORITY
FASTCALL
IoGetPagingIoPriority(
    _In_ PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
IO_PRIORITY_HINT
IoGetIoPriorityHint(
    _In_ PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoSetIoPriorityHint(
    _In_ PIRP               Irp,
    _In_ IO_PRIORITY_HINT   PriorityHint
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoAllocateSfioStreamIdentifier(
    _In_  PFILE_OBJECT  FileObject,
    _In_  ULONG         Length,
    _In_  PVOID         Signature,
    _Out_ PVOID         *StreamIdentifier
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
PVOID
IoGetSfioStreamIdentifier(
    _In_ PFILE_OBJECT   FileObject,
    _In_ PVOID          Signature
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoFreeSfioStreamIdentifier(
    _In_ PFILE_OBJECT   FileObject,
    _In_ PVOID          Signature
    );
#endif

typedef enum _IO_ACCESS_TYPE {

    //
    // Indicates that the Io will
    // be comprised solely of reads
    //
    ReadAccess,

    //
    // Indicates that the Io will
    // be comprised solely of writes
    //
    WriteAccess,

    //
    // Indicates that the Io will be
    // comprised of reads and writes
    //
    ModifyAccess

} IO_ACCESS_TYPE;

typedef enum _IO_ACCESS_MODE {

    //
    // Indicates that the Io will be
    // sent down in a sequential order
    //
    SequentialAccess,

    //
    // Indicates that the Io might
    // not be in a predictable order
    //
    RandomAccess

} IO_ACCESS_MODE;

typedef enum _IO_CONTAINER_NOTIFICATION_CLASS {
    IoSessionStateNotification, // 0 - Session State Notifications
    IoMaxContainerNotificationClass
} IO_CONTAINER_NOTIFICATION_CLASS;

typedef struct _IO_SESSION_STATE_NOTIFICATION {
    ULONG Size;
    ULONG Flags;
    PVOID IoObject;
    ULONG EventMask;
    PVOID Context;
} IO_SESSION_STATE_NOTIFICATION, *PIO_SESSION_STATE_NOTIFICATION;

typedef enum _IO_CONTAINER_INFORMATION_CLASS {
    IoSessionStateInformation, // 0 - Session State Information
    IoMaxContainerInformationClass
} IO_CONTAINER_INFORMATION_CLASS;

typedef struct _IO_SESSION_STATE_INFORMATION {
    ULONG SessionId;
    IO_SESSION_STATE SessionState;
    BOOLEAN LocalSession;
} IO_SESSION_STATE_INFORMATION, *PIO_SESSION_STATE_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTSTATUS
IoGetContainerInformation (
    _In_ IO_CONTAINER_INFORMATION_CLASS InformationClass,
    _In_opt_ PVOID ContainerObject,
    _Inout_updates_bytes_opt_(BufferLength) PVOID Buffer,
    _In_ ULONG BufferLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef NTSTATUS (*PIO_CONTAINER_NOTIFICATION_FUNCTION)();

typedef
NTSTATUS
IO_SESSION_NOTIFICATION_FUNCTION (
    _In_ PVOID SessionObject,
    _In_ PVOID IoObject,
    _In_ ULONG Event,
    _In_ PVOID Context,
    _In_reads_bytes_opt_(PayloadLength) PVOID NotificationPayload,
    _In_ ULONG PayloadLength
    );

typedef IO_SESSION_NOTIFICATION_FUNCTION *PIO_SESSION_NOTIFICATION_FUNCTION;
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTSTATUS
IoRegisterContainerNotification(
    _In_ IO_CONTAINER_NOTIFICATION_CLASS NotificationClass,
    _In_ PIO_CONTAINER_NOTIFICATION_FUNCTION CallbackFunction,
    _In_reads_bytes_opt_(NotificationInformationLength) PVOID NotificationInformation,
    _In_ ULONG NotificationInformationLength,
    _Out_ PVOID CallbackRegistration
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
VOID
IoUnregisterContainerNotification(
    _In_ PVOID CallbackRegistration
    );
#endif


//
//  IoPrioirityHint support
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _IO_PRIORITY_INFO {
    ULONG Size;
    ULONG ThreadPriority;
    ULONG PagePriority;
    IO_PRIORITY_HINT IoPriority;
} IO_PRIORITY_INFO, *PIO_PRIORITY_INFO;
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
FORCEINLINE
IoInitializePriorityInfo(
    _Out_ PIO_PRIORITY_INFO PriorityInfo
    )
{
    PriorityInfo->Size = sizeof(IO_PRIORITY_INFO);
    PriorityInfo->ThreadPriority = 0xffff;
    PriorityInfo->IoPriority = IoPriorityNormal;
    PriorityInfo->PagePriority = 0;
}
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoRetrievePriorityInfo (
    _In_opt_ PIRP Irp,
    _In_opt_ PFILE_OBJECT FileObject,
    _In_opt_ PETHREAD Thread,
    _Inout_ PIO_PRIORITY_INFO PriorityInfo
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoApplyPriorityInfoThread(
    _In_ PIO_PRIORITY_INFO InputPriorityInfo,
    _Out_opt_ PIO_PRIORITY_INFO OutputPriorityInfo,
    _In_ PETHREAD Thread
    );
#endif


// begin_ntddk
// @@BEGIN_DDKSPLIT
typedef
VOID
DRIVER_PRIORITY_CALLBACK (
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PETHREAD Thread,
    _In_ IO_PRIORITY_HINT TargetPriority
    );

typedef DRIVER_PRIORITY_CALLBACK *PDRIVER_PRIORITY_CALLBACK;

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTSTATUS
IoRegisterPriorityCallback (
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDRIVER_PRIORITY_CALLBACK Callback
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
VOID
IoUnregisterPriorityCallback (
    _In_ PDRIVER_OBJECT DriverObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
BOOLEAN
IoIsActivityTracingEnabled (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
typedef struct _IO_TRACKING_CALLBACK_INFO {
    USHORT Size;
    ULONGLONG ElapsedTime;
    DEVICE_TYPE DeviceType;
} IO_TRACKING_CALLBACK_INFO, *PIO_TRACKING_CALLBACK_INFO;

typedef
VOID
(*PIO_TRACKING_CALLBACK) (
    _In_ PIO_TRACKING_CALLBACK_INFO CallbackInfo
    );

typedef struct _IO_TRACKING_SETTINGS {
    USHORT Size;
    PIO_TRACKING_CALLBACK TrackingCallback;
} IO_TRACKING_SETTINGS, *PIO_TRACKING_SETTINGS;

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
IoRegisterIoTracking(
    _In_ PIO_TRACKING_SETTINGS IoTrackingSettings,
    _Outptr_ PVOID *IoTracker
    );

_IRQL_requires_max_(APC_LEVEL)
VOID
IoUnregisterIoTracking(
    _In_ PVOID IoTracker
    );
#endif

// @@END_DDKSPLIT

#if (NTDDI_VERSION >= NTDDI_WIN8)

//
// BDCB_IMAGE_INFORMATION ImageFlags.
//

#define BDCB_IMAGEFLAGS_FAILED_CODE_INTEGRITY   (1UL << 0)

typedef enum _BDCB_CALLBACK_TYPE {
    BdCbStatusUpdate,
    BdCbInitializeImage,
} BDCB_CALLBACK_TYPE, *PBDCB_CALLBACK_TYPE;

typedef enum _BDCB_CLASSIFICATION {
    BdCbClassificationUnknownImage,
    BdCbClassificationKnownGoodImage,
    BdCbClassificationKnownBadImage,
    BdCbClassificationKnownBadImageBootCritical,
    BdCbClassificationEnd,
} BDCB_CLASSIFICATION, *PBDCB_CLASSIFICATION;

typedef enum _BDCB_STATUS_UPDATE_TYPE {
    BdCbStatusPrepareForDependencyLoad,
    BdCbStatusPrepareForDriverLoad,
    BdCbStatusPrepareForUnload,
} BDCB_STATUS_UPDATE_TYPE, *PBDCB_STATUS_UPDATE_TYPE;

typedef struct _BDCB_STATUS_UPDATE_CONTEXT {
    BDCB_STATUS_UPDATE_TYPE StatusType;
} BDCB_STATUS_UPDATE_CONTEXT, *PBDCB_STATUS_UPDATE_CONTEXT;

typedef struct _BDCB_IMAGE_INFORMATION {
    BDCB_CLASSIFICATION Classification;
    ULONG ImageFlags;
    UNICODE_STRING ImageName;
    UNICODE_STRING RegistryPath;
    UNICODE_STRING CertificatePublisher;
    UNICODE_STRING CertificateIssuer;
    PVOID ImageHash;
    PVOID CertificateThumbprint;
    ULONG ImageHashAlgorithm;
    ULONG ThumbprintHashAlgorithm;
    ULONG ImageHashLength;
    ULONG CertificateThumbprintLength;
} BDCB_IMAGE_INFORMATION, *PBDCB_IMAGE_INFORMATION;

typedef
VOID
BOOT_DRIVER_CALLBACK_FUNCTION (
    _In_opt_ PVOID CallbackContext,
    _In_ BDCB_CALLBACK_TYPE Classification,
    _Inout_ PBDCB_IMAGE_INFORMATION ImageInformation
    );

typedef BOOT_DRIVER_CALLBACK_FUNCTION *PBOOT_DRIVER_CALLBACK_FUNCTION;
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
PVOID
IoRegisterBootDriverCallback (
    _In_ PBOOT_DRIVER_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID CallbackContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
VOID
IoUnregisterBootDriverCallback (
    _In_ PVOID CallbackHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTSTATUS
IoGetActivityIdIrp (
    _In_ PIRP Irp,
    _Out_ LPGUID Guid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTSTATUS
IoSetActivityIdIrp (
    _Inout_ PIRP Irp,
    _In_opt_ LPCGUID Guid
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTSTATUS
IoPropagateActivityIdToThread(
    _In_ PIRP Irp,
    _Out_ LPGUID PropagatedId,
    _Outptr_ LPCGUID *OriginalId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
LPCGUID
IoSetActivityIdThread (
    _In_ LPCGUID ActivityId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
VOID
IoClearActivityIdThread (
    _In_ LPCGUID OriginalId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
LPCGUID
IoGetActivityIdThread (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
VOID
IoTransferActivityId (
    _In_ LPCGUID ActivityId,
    _In_ LPCGUID RelatedActivityId
    );
#endif

// begin_ntifs
#if (NTDDI_VERSION >= NTDDI_WINBLUE)

NTSTATUS
IoGetFsZeroingOffset (
    _In_ PIRP Irp,
    _Out_ PULONG ZeroingOffset
    );

NTSTATUS
IoSetFsZeroingOffsetRequired (
    _Inout_ PIRP Irp
    );

NTSTATUS
IoSetFsZeroingOffset (
    _Inout_ PIRP Irp,
    _In_ ULONG ZeroingOffset
    );

#endif

// end_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
LOGICAL
IoIsValidIrpStatus (
    IN NTSTATUS Status
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
IoIncrementKeepAliveCount(
    _Inout_ PFILE_OBJECT FileObject,
    _Inout_ PEPROCESS Process
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
IoDecrementKeepAliveCount(
    _Inout_ PFILE_OBJECT FileObject,
    _Inout_ PEPROCESS Process
    );
#endif

// end_ntddk
// begin_ntosifs

//============================================================================
// IRP extension support
//============================================================================

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

//
//  Irp Extension function prototypes
//

USHORT
IoSizeofGenericIrpExtension(
    VOID
    );

NTSTATUS
IoGetGenericIrpExtension(
    _In_ PIRP Irp,
    _Out_writes_(GenericExtensionDataSize) PUCHAR GenericExtensionData,
    _In_ USHORT GenericExtensionDataSize
    );

NTSTATUS
IoSetGenericIrpExtension(
    _In_ PIRP Irp,
    _In_reads_(GenericExtensionDataSize) PUCHAR GenericExtensionData,
    _In_ USHORT GenericExtensionDataSize,
    _In_ BOOLEAN OverwriteIfPresent
    );

NTSTATUS
IoPropagateIrpExtensionEx(
    _In_ PIRP SourceIrp,
    _In_ PIRP TargetIrp,
    _In_ LONGLONG TrackedOffset,
    _In_ ULONG Flags
    );

NTSTATUS
IoPropagateIrpExtension(
    _In_ PIRP SourceIrp,
    _In_ PIRP TargetIrp,
    _In_ ULONG Flags
    );

#define IO_IRPEXT_PROPAGATE_GENERIC         0x00000001
#define IO_IRPEXT_PROPAGATE_ACTIVITY_ID     0x00000002
#define IO_IRPEXT_PROPAGATE_TRACKED_OFFSET  0x00000004

#define IO_IRPEXT_PROPAGATE_ALL             0xffffffff      //Drivers should use this unless there is a specific reason to not propagate everything
#endif

// end_ntosifs
// begin_ntifs begin_ntosp
#if (NTDDI_VERSION >= NTDDI_WINBLUE)

NTSTATUS
IoGetFsZeroingOffset (
    _In_ PIRP Irp,
    _Out_ PULONG ZeroingOffset
    );

NTSTATUS
IoSetFsZeroingOffsetRequired (
    _Inout_ PIRP Irp
    );

NTSTATUS
IoSetFsZeroingOffset (
    _Inout_ PIRP Irp,
    _In_ ULONG ZeroingOffset
    );

#endif

// begin_winioctl
#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

//
//  This is a function prototype for a routine that will be called from the
//  IoPropagateIrpExtensionEx routine whenever the IopFsTrackOffsetType
//  extension type is set for a given IRP
//

#ifndef _IO_IRP_EXT_TRACK_OFFSET_HEADER_
#define _IO_IRP_EXT_TRACK_OFFSET_HEADER_

struct _IO_IRP_EXT_TRACK_OFFSET_HEADER;

typedef VOID
(*PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK)(
    _In_ struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *SourceContext,
    _Inout_ struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *TargetContext,
    _In_ LONGLONG RelativeOffset
    );

//
//  When any IRP extension exists which has an OFFSET which needs processing,
//  the Irp extention field in the IRP must point to one of these structures.
//  This is so IoPropagateIrpExtensionEx can caluclate proper file offset
//  adjustments for the sub IRPS as they are split and shiffted
//

#define IRP_EXT_TRACK_OFFSET_HEADER_VALIDATION_VALUE 'TO'    //Track Offset

typedef struct _IO_IRP_EXT_TRACK_OFFSET_HEADER {

    USHORT Validation;

    //  Each consumer of this IRP extension must define a flag that helps
    //  identify the usage of the header. eg: EFS_TRACKED_OFFSET_HEADER_FLAG
    USHORT Flags;

    PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK TrackedOffsetCallback;

} IO_IRP_EXT_TRACK_OFFSET_HEADER, *PIO_IRP_EXT_TRACK_OFFSET_HEADER;

//
//  When using the TrackedOffset IRP extension one of the following
//  flag must be specified so that we can distinguish it from other
//  components setting this IRP extension
//

#define EFS_TRACKED_OFFSET_HEADER_FLAG 0x0001 //EFS Flag
#define SPACES_TRACKED_OFFSET_HEADER_FLAG 0x0002 //SPACES Flag

#endif // _IO_IRP_EXT_TRACK_OFFSET_HEADER_
#endif // (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

//end_winioctl

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

NTSTATUS
IoGetFsTrackOffsetState(
    _In_ PIRP Irp,
    _Out_ PIO_IRP_EXT_TRACK_OFFSET_HEADER *RetFsTrackOffsetBlob,
    _Out_ LONGLONG *RetTrackedOffset);


NTSTATUS
IoSetFsTrackOffsetState(
    _Inout_ PIRP Irp,
    _In_ PIO_IRP_EXT_TRACK_OFFSET_HEADER FsTrackOffsetBlob,
    _In_ LONGLONG TrackedOffset);

BOOLEAN
IoIrpHasFsTrackOffsetExtensionType(
    _In_ PIRP Irp );
#endif
// end_ntifs
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
PEPROCESS
IoGetInitiatorProcess(
    _In_ PFILE_OBJECT FileObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
VOID
IoSetMasterIrpStatus(
    _Inout_ PIRP MasterIrp,
    _In_ NTSTATUS Status
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoQueryFullDriverPath(
    _In_ PDRIVER_OBJECT DriverObject,
    _Out_ PUNICODE_STRING FullPath
    );
#endif
// end_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
IoBoostThreadIo(
    _In_ PETHREAD Thread,
    _In_ IO_PRIORITY_HINT TargetPriority,
    _In_ BOOLEAN Unboost,
    _In_ ULONG Flags
    );
#endif

typedef struct _IO_LOAD_CRASHDUMP_PARAMS {
    ULONG Size;
    PUNICODE_STRING NamePrefix;
    PUNICODE_STRING LoadedBaseName;
} IO_LOAD_CRASHDUMP_PARAMS, *PIO_LOAD_CRASHDUMP_PARAMS;

typedef struct _IO_LOAD_CRASHDUMP_RESULT {
    ULONG Size;
    PVOID ImageHandle;
    PVOID ImageBaseAddress;
} IO_LOAD_CRASHDUMP_RESULT, *PIO_LOAD_CRASHDUMP_RESULT;

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoLoadCrashDumpDriver(
    _In_ PUNICODE_STRING DriverName,
    _In_ PIO_LOAD_CRASHDUMP_PARAMS LoadCrashDumpParams,
    _Inout_ PIO_LOAD_CRASHDUMP_RESULT LoadCrashDumpResult
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTSTATUS
IoConvertFileHandleToKernelHandle (
    _In_opt_ HANDLE Handle,
    _In_ KPROCESSOR_MODE PreviousMode,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OverrideAccessCheck,
    _Out_ HANDLE* KernelHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

//
// {BA57E015-65B3-4C3C-B274-659192F699E3}
//
EXTERN_C const GUID DECLSPEC_SELECTANY BUGCHECK_EFI_GUID = { 0xba57e015, 0x65b3, 0x4c3c, 0xb2, 0x74, 0x65, 0x91, 0x92, 0xf6, 0x99, 0xe3 };

//
// EFI Variable Names
//
#define TRACELOGGING_BUGCHECK_ENVIRONMENT_VARIABLE_PROGRESS                     L"BugCheckProgress"
#define TRACELOGGING_BUGCHECK_ENVIRONMENT_VARIABLE_BUGCHECK                     L"BugCheckCode"
#define TRACELOGGING_BUGCHECK_ENVIRONMENT_VARIABLE_PARAMETER1                   L"BugCheckParameter1"

//
// TraceLogging Progress for BugCheck & Crashdmp
//
#define TRACELOGGING_BUGCHECK_PROGRESS_MASK                                     0x0000FFFF
#define TRACELOGGING_BUGCHECK_FLAG_MASK                                         0xFFFF0000

//
// BugCheck Progress Bits (2 LSB)
// These flags will be set once the corresponding action (function) has finished
//
// Ke (0x0000 - 0x001F)
//
#define TRACELOGGING_BUGCHECK_PROGRESS_KEBUGCHECK_START                         0x00000001
#define TRACELOGGING_BUGCHECK_PROGRESS_BUGCHECK_CALLBACKS_INVOKED               0x00000002
#define TRACELOGGING_BUGCHECK_PROGRESS_IO_WRITE_CRASHDUMP_FINISH                0x00000003
#define TRACELOGGING_BUGCHECK_PROGRESS_KEBUGCHECK_FINISH                        0x00000004
#define TRACELOGGING_BUGCHECK_PROGRESS_DOUBLE_FAULT                             0x00000005

//
// IoMgr (0x0020 - 0x003F)
//
#define TRACELOGGING_IOMGR_PROGRESS_DUMPSTACK_READY                             0x00000020
#define TRACELOGGING_IOMGR_PROGRESS_ADDPAGES_CALLBACKS                          0x00000021
#define TRACELOGGING_IOMGR_PROGRESS_REMOVEPAGES_CALLBACKS                       0x00000022
#define TRACELOGGING_IOMGR_PROGRESS_MINIDUMP_NEEDED_DUMPWRITE                   0x00000023
#define TRACELOGGING_IOMGR_PROGRESS_FORCING_OFFLINE_DUMP                        0x00000024

//
// Crashdmp (0x0040 - 0x005F)
//
#define TRACELOGGING_CRASHDMP_PROGRESS_DUMP_DEVICE_POWER_ON                     0x00000040
#define TRACELOGGING_CRASHDMP_PROGRESS_START_FILTER_DRIVERS                     0x00000041
#define TRACELOGGING_CRASHDMP_PROGRESS_CRASHDMP_INIT_DUMP_STACK                 0x00000042
#define TRACELOGGING_CRASHDMP_PROGRESS_WRITE_BITMAP_DUMP                        0x00000043
#define TRACELOGGING_CRASHDMP_PROGRESS_WRITE_MINIDUMP                           0x00000044
#define TRACELOGGING_CRASHDMP_PROGRESS_INVOKE_SECONDARY_DUMP_CALLBACKS          0x00000045
#define TRACELOGGING_CRASHDMP_PROGRESS_INVOKE_DUMP_CALLBACKS                    0x00000046
#define TRACELOGGING_CRASHDMP_PROGRESS_DUMP_WRITE_CAPSULE                       0x00000047

//
// Hypervisor (0x0060 - 0x007F)
//
#define TRACELOGGING_BUGCHECK_PROGRESS_ENLIGHTENMENTS_DISABLED                  0x00000060
#define TRACELOGGING_BUGCHECK_PROGRESS_HYPERVISOR_ROOT_CRASHDMP_NOTIFIED_1      0x00000061
#define TRACELOGGING_BUGCHECK_PROGRESS_HYPERVISOR_ROOT_CRASHDMP_NOTIFIED_2      0x00000062
#define TRACELOGGING_BUGCHECK_PROGRESS_ENLIGHTENMENTS_RESTORED                  0x00000063

//
// Graphics (0x0080 - 0x009F)
//
#define TRACELOGGING_BUGCHECK_PROGRESS_BUGCHECK_SCREEN_DISPLAYED                0x00000080

//
// Secure Kernel (0x00A0 - 0x00AF)
//
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_INITIATED                             0x000000A0
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_NOTIFYROOT_0                          0x000000A1
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_NOTIFYROOT_1                          0x000000A2
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_PREPARE_CRASHDUMP                     0x000000A3
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_START_PAGEITERATION                   0x000000A4
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_END_PAGEITERATION                     0x000000A5
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_START_GETPAGE                         0x000000A6
#define TRACELOGGING_CRASHDMP_PROGRESS_SK_END_GETPAGE                           0x000000A7

//
// BugCheck Error Flags (2 MSB)
// These flags will be set if an error condition is met
//
#define TRACELOGGING_CRASHDMP_FLAG_UNSUPPORTED_DUMP_TYPE                        0x00010000
#define TRACELOGGING_CRASHDMP_FLAG_PAGEFILE_TOO_SMALL                           0x00020000
#define TRACELOGGING_CRASHDMP_FLAG_DUMP_DEVICE_POWER_ON_CALLED                  0x00040000
#define TRACELOGGING_CRASHDMP_FLAG_DUMP_DEVICE_POWER_ON_FAILED                  0x00080000
#define TRACELOGGING_CRASHDMP_FLAG_HEADER_WRITE_FAILED                          0x00100000
#define TRACELOGGING_CRASHDMP_FLAG_EXCEPTION_ACCESSING_PAGE                     0x00200000
#define TRACELOGGING_CRASHDMP_FLAG_WRITE_PAGE_SPAN_TO_DISK_FAILURE              0x00400000
#define TRACELOGGING_CRASHDMP_FLAG_WRITE_BUFFER_TO_DISK_FAILURE                 0x00800000
#define TRACELOGGING_CRASHDMP_FLAG_DUMP_DEVICE_GONE                             0x01000000
#define TRACELOGGING_IOMGR_FLAG_MINIDUMP_NEEDED                                 0x02000000
#define TRACELOGGING_IOMGR_FLAG_FW_CAPSULE_NEEDED                               0x04000000
#define TRACELOGGING_IOMGR_FLAG_WAIT_WATCHDOG_TIMER_TRIGGER                     0x08000000
#define TRACELOGGING_IOMGR_FLAG_FW_CAPSULE_FAILED                               0x10000000
#endif


#if (NTDDI_VERSION >= NTDDI_THRESHOLD)

typedef enum _IO_STEER_INTERRUPT_CONNECTION_TYPE {
    InterruptConnectionSingle,
    InterruptConnectionMax
} IO_STEER_INTERRUPT_CONNECTION_TYPE, *PIO_STEER_INTERRUPT_CONNECTION_TYPE;

typedef struct _IO_STEER_INTERRUPT_CONNECTION_CONTEXT {
    ULONG Version;
    PDEVICE_OBJECT PhysicalDeviceObject;
    union {
        PVOID Generic;
        PKINTERRUPT InterruptObject;
        PIO_INTERRUPT_MESSAGE_INFO InterruptMessageTable;
    } DUMMYUNIONNAME;
} IO_STEER_INTERRUPT_CONNECTION_CONTEXT, *PIO_STEER_INTERRUPT_CONNECTION_CONTEXT;

typedef struct _IO_STEER_INTERRUPT_CONNECTION {
    IO_STEER_INTERRUPT_CONNECTION_TYPE Type;
    union {
        IO_STEER_INTERRUPT_CONNECTION_CONTEXT Interrupt;
        ULONG Reserved;
    } DUMMYUNIONNAME;
} IO_STEER_INTERRUPT_CONNECTION, *PIO_STEER_INTERRUPT_CONNECTION;

typedef enum _IO_STEER_INTERRUPT_TARGET_TYPE {
    InterruptTargetDefault,
    InterruptTargetCpuSetMask,
    InterruptTargetMax
} IO_STEER_INTERRUPT_TARGET_TYPE, *PIO_STEER_INTERRUPT_TARGET_TYPE;

typedef struct _IO_STEER_INTERRUPT_TARGET {
    IO_STEER_INTERRUPT_TARGET_TYPE Type;
    union {
        struct {
            USHORT Group;
            KAFFINITY Mask;
        } CpuSetMask;
        ULONG Reserved;
    } DUMMYUNIONNAME;
} IO_STEER_INTERRUPT_TARGET, *PIO_STEER_INTERRUPT_TARGET;

_IRQL_requires_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoSteerInterrupt (
    _In_ PIO_STEER_INTERRUPT_CONNECTION Connection,
    _In_ PIO_STEER_INTERRUPT_TARGET Target
    );

#endif

// begin_wudfwdm

//
// Define PnP Device Property for IoGetDeviceProperty
//

#ifdef _PREFAST_
#define __string_type 0x1000
#define __guid_type 0x2000
#define __multiString_type 0x4000
#else
#define __string_type 0
#define __guid_type 0
#define __multiString_type 0
#endif

typedef enum {
    DevicePropertyDeviceDescription = 0x0 | __string_type,
    DevicePropertyHardwareID = 0x1 | __multiString_type,
    DevicePropertyCompatibleIDs = 0x2 | __multiString_type,
    DevicePropertyBootConfiguration = 0x3,
    DevicePropertyBootConfigurationTranslated = 0x4,
    DevicePropertyClassName = 0x5 | __string_type,
    DevicePropertyClassGuid = 0x6 | __string_type,
    DevicePropertyDriverKeyName = 0x7 | __string_type,
    DevicePropertyManufacturer = 0x8 | __string_type,
    DevicePropertyFriendlyName = 0x9 | __string_type,
    DevicePropertyLocationInformation = 0xa | __string_type,
    DevicePropertyPhysicalDeviceObjectName = 0xb | __string_type,
    DevicePropertyBusTypeGuid = 0xc | __guid_type,
    DevicePropertyLegacyBusType = 0xd,
    DevicePropertyBusNumber = 0xe,
    DevicePropertyEnumeratorName = 0xf | __string_type,
    DevicePropertyAddress = 0x10,
    DevicePropertyUINumber = 0x11,
    DevicePropertyInstallState = 0x12,
    DevicePropertyRemovalPolicy = 0x13,
    DevicePropertyResourceRequirements = 0x14,
    DevicePropertyAllocatedResources = 0x15,
    DevicePropertyContainerID = 0x16 | __string_type
} DEVICE_REGISTRY_PROPERTY;

// end_wudfwdm

typedef
_Function_class_(TRANSLATE_BUS_ADDRESS)
_IRQL_requires_same_
_Success_(return)
BOOLEAN TRANSLATE_BUS_ADDRESS(
    _Inout_opt_ PVOID Context,
    _In_ PHYSICAL_ADDRESS BusAddress,
    _In_ ULONG Length,
    _Out_ PULONG AddressSpace,
    _Out_ PPHYSICAL_ADDRESS TranslatedAddress
    );
typedef TRANSLATE_BUS_ADDRESS *PTRANSLATE_BUS_ADDRESS;

typedef
_Function_class_(GET_DMA_ADAPTER)
_IRQL_requires_same_
struct _DMA_ADAPTER *GET_DMA_ADAPTER(
    _Inout_opt_ PVOID Context,
    _In_ struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    _Out_ PULONG NumberOfMapRegisters
    );
typedef GET_DMA_ADAPTER *PGET_DMA_ADAPTER;

typedef
_Function_class_(GET_SET_DEVICE_DATA)
_IRQL_requires_same_
ULONG GET_SET_DEVICE_DATA (
    _Inout_opt_ PVOID Context,
    _In_ ULONG DataType,
    _Inout_updates_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_range_(!=,0) ULONG Length
    );
typedef GET_SET_DEVICE_DATA *PGET_SET_DEVICE_DATA;

typedef enum _DEVICE_INSTALL_STATE {
    InstallStateInstalled,
    InstallStateNeedsReinstall,
    InstallStateFailedInstall,
    InstallStateFinishInstall
} DEVICE_INSTALL_STATE, *PDEVICE_INSTALL_STATE;

// begin_wudfpwdm

//
// Define structure returned in response to IRP_MN_QUERY_BUS_INFORMATION by a
// PDO indicating the type of bus the device exists on.
//

typedef struct _PNP_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} PNP_BUS_INFORMATION, *PPNP_BUS_INFORMATION;

// end_wudfpwdm

//
// Define structure returned in response to IRP_MN_QUERY_LEGACY_BUS_INFORMATION
// by an FDO indicating the type of bus it is.  This is normally the same bus
// type as the device's children (i.e., as retrieved from the child PDO's via
// IRP_MN_QUERY_BUS_INFORMATION) except for cases like CardBus, which can
// support both 16-bit (PCMCIABus) and 32-bit (PCIBus) cards.
//

typedef struct _LEGACY_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} LEGACY_BUS_INFORMATION, *PLEGACY_BUS_INFORMATION;

//
// Defines for IoGetDeviceProperty(DevicePropertyRemovalPolicy).
//
typedef enum _DEVICE_REMOVAL_POLICY {

    RemovalPolicyExpectNoRemoval = 1,
    RemovalPolicyExpectOrderlyRemoval = 2,
    RemovalPolicyExpectSurpriseRemoval = 3

} DEVICE_REMOVAL_POLICY, *PDEVICE_REMOVAL_POLICY;

typedef struct _BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PTRANSLATE_BUS_ADDRESS TranslateBusAddress;
    PGET_DMA_ADAPTER GetDmaAdapter;
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;

} BUS_INTERFACE_STANDARD, *PBUS_INTERFACE_STANDARD;

typedef
_Function_class_(GET_VIRTUAL_DEVICE_DATA)
_IRQL_requires_same_
_IRQL_requires_max_(DISPATCH_LEVEL)
ULONG GET_VIRTUAL_DEVICE_DATA (
    _Inout_                 PVOID Context,
    _In_                    USHORT VirtualFunction,
    _Out_writes_bytes_(Length)    PVOID Buffer,
    _In_                    ULONG Offset,
    _In_                    ULONG Length
    );
typedef GET_VIRTUAL_DEVICE_DATA *PGET_VIRTUAL_DEVICE_DATA;

typedef
_Function_class_(SET_VIRTUAL_DEVICE_DATA)
_IRQL_requires_same_
_IRQL_requires_max_(DISPATCH_LEVEL)
ULONG SET_VIRTUAL_DEVICE_DATA (
    _Inout_             PVOID Context,
    _In_                USHORT VirtualFunction,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_                ULONG Offset,
    _In_                ULONG Length
    );
typedef SET_VIRTUAL_DEVICE_DATA *PSET_VIRTUAL_DEVICE_DATA;

typedef
_Function_class_(GET_VIRTUAL_DEVICE_LOCATION)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS GET_VIRTUAL_DEVICE_LOCATION (
    _Inout_     PVOID Context,
    _In_        USHORT VirtualFunction,
    _Out_       PUINT16 SegmentNumber,
    _Out_       PUINT8 BusNumber,
    _Out_       PUINT8 FunctionNumber
    );
typedef GET_VIRTUAL_DEVICE_LOCATION *PGET_VIRTUAL_DEVICE_LOCATION;

typedef
_Function_class_(GET_VIRTUAL_DEVICE_RESOURCES)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID GET_VIRTUAL_DEVICE_RESOURCES (
    _Inout_     PVOID   Context,
    _Out_       PUINT8  CapturedBusNumbers
    );
typedef GET_VIRTUAL_DEVICE_RESOURCES *PGET_VIRTUAL_DEVICE_RESOURCES;

typedef
_Function_class_(ENABLE_VIRTUALIZATION)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS ENABLE_VIRTUALIZATION (
    _Inout_     PVOID   Context,
    _In_        UINT16  NumVFs,
    _In_        BOOLEAN EnableVfMigration,
    _In_        BOOLEAN EnableMigrationInterrupt,
    _In_        BOOLEAN EnableVirtualization
    );
typedef ENABLE_VIRTUALIZATION *PENABLE_VIRTUALIZATION;


typedef
_Function_class_(GET_VIRTUAL_FUNCTION_PROBED_BARS)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
GET_VIRTUAL_FUNCTION_PROBED_BARS(
    _Inout_         PVOID  Context,
    _Out_writes_(6) PULONG BaseRegisterValues
    ) ;
typedef GET_VIRTUAL_FUNCTION_PROBED_BARS *PGET_VIRTUAL_FUNCTION_PROBED_BARS;


typedef struct _PCI_VIRTUALIZATION_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // virtualization interfaces
    //
    PSET_VIRTUAL_DEVICE_DATA SetVirtualFunctionData;
    PGET_VIRTUAL_DEVICE_DATA GetVirtualFunctionData;

    PGET_VIRTUAL_DEVICE_LOCATION    GetLocation;
    PGET_VIRTUAL_DEVICE_RESOURCES   GetResources;

    PENABLE_VIRTUALIZATION EnableVirtualization;

    PGET_VIRTUAL_FUNCTION_PROBED_BARS GetVirtualFunctionProbedBars;

} PCI_VIRTUALIZATION_INTERFACE, *PPCI_VIRTUALIZATION_INTERFACE;

//
// PCI Security Interface - 6e7f1451-199e-4acc-ba2d-762b4edf4674
//

#define PCI_SECURITY_INTERFACE_VERSION 1

typedef enum _PCI_ACS_BIT {

    PciAcsReserved = 0,
    PciAcsBitEnable,
    PciAcsBitDisable,
    PciAcsBitDontCare

} PCI_ACS_BIT, *PPCI_ACS_BIT;

typedef
_Function_class_(PCI_SET_ACS)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS PCI_SET_ACS (
    _Inout_     PVOID   Context,
    _In_        PCI_ACS_BIT EnableSourceValidation,
    _In_        PCI_ACS_BIT EnableTranslationBlocking,
    _In_        PCI_ACS_BIT EnableP2PRequestRedirect,
    _In_        PCI_ACS_BIT EnableCompletionRedirect,
    _In_        PCI_ACS_BIT EnableUpstreamForwarding,
    _In_        PCI_ACS_BIT EnableEgressControl,
    _In_        PCI_ACS_BIT EnableDirectTranslatedP2P
    );

typedef PCI_SET_ACS *PPCI_SET_ACS;

typedef struct _PCI_SECURITY_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PPCI_SET_ACS    SetAccessControlServices;

} PCI_SECURITY_INTERFACE, *PPCI_SECURITY_INTERFACE;

// begin_wudfpwdm

typedef
VOID
(*PREENUMERATE_SELF)(
    _In_ PVOID Context
    );

typedef struct _REENUMERATE_SELF_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // Self-reenumeration interface
    //
    PREENUMERATE_SELF SurpriseRemoveAndReenumerateSelf;
} REENUMERATE_SELF_INTERFACE_STANDARD, *PREENUMERATE_SELF_INTERFACE_STANDARD;

//
// D3Cold Support Interface
//

#define D3COLD_SUPPORT_INTERFACE_VERSION 1

typedef
_Function_class_(SET_D3COLD_SUPPORT)
_IRQL_requires_(PASSIVE_LEVEL)
VOID
SET_D3COLD_SUPPORT (
    _In_reads_opt_(_Inexpressible_("varies")) PVOID Context,
    _In_ BOOLEAN D3ColdSupport
    );

typedef SET_D3COLD_SUPPORT *PSET_D3COLD_SUPPORT;

typedef enum _DEVICE_WAKE_DEPTH {
    DeviceWakeDepthNotWakeable    = 0,
    DeviceWakeDepthD0,
    DeviceWakeDepthD1,
    DeviceWakeDepthD2,
    DeviceWakeDepthD3hot,
    DeviceWakeDepthD3cold,
    DeviceWakeDepthMaximum
} DEVICE_WAKE_DEPTH, *PDEVICE_WAKE_DEPTH;

FORCEINLINE
DEVICE_POWER_STATE
MapWakeDepthToDstate(
    _In_ DEVICE_WAKE_DEPTH WakeDepth
    )
{
    const DEVICE_POWER_STATE dstateMap[DeviceWakeDepthMaximum] =
    {
        PowerDeviceD0,
        PowerDeviceD0,
        PowerDeviceD1,
        PowerDeviceD2,
        PowerDeviceD3,
        PowerDeviceD3
    };

    if (WakeDepth < 0 || WakeDepth >= DeviceWakeDepthMaximum) {
        return PowerDeviceUnspecified;
    } else {
        return dstateMap[WakeDepth];
    }
}

typedef
_Function_class_(GET_IDLE_WAKE_INFO)
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
GET_IDLE_WAKE_INFO (
    _In_reads_opt_(_Inexpressible_("varies")) PVOID Context,
    _In_ SYSTEM_POWER_STATE SystemPowerState,
    _Out_ PDEVICE_WAKE_DEPTH DeepestWakeableDstate
    );

typedef GET_IDLE_WAKE_INFO *PGET_IDLE_WAKE_INFO;

typedef
_Function_class_(GET_D3COLD_CAPABILITY)
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
GET_D3COLD_CAPABILITY (
    _In_reads_opt_(_Inexpressible_("varies")) PVOID Context,
    _Out_ PBOOLEAN D3ColdSupported
    );

typedef GET_D3COLD_CAPABILITY *PGET_D3COLD_CAPABILITY;

typedef enum _D3COLD_LAST_TRANSITION_STATUS {
    LastDStateTransitionStatusUnknown = 0,
    LastDStateTransitionD3hot,
    LastDStateTransitionD3cold
} D3COLD_LAST_TRANSITION_STATUS, *PD3COLD_LAST_TRANSITION_STATUS;

typedef
_Function_class_(GET_D3COLD_LAST_TRANSITION_STATUS)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
GET_D3COLD_LAST_TRANSITION_STATUS (
    _In_reads_opt_(_Inexpressible_("varies")) PVOID Context,
    _Out_ PD3COLD_LAST_TRANSITION_STATUS LastTransitionStatus
    );

typedef GET_D3COLD_LAST_TRANSITION_STATUS *PGET_D3COLD_LAST_TRANSITION_STATUS;

typedef struct _D3COLD_SUPPORT_INTERFACE {

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PSET_D3COLD_SUPPORT                 SetD3ColdSupport;
    PGET_IDLE_WAKE_INFO                 GetIdleWakeInfo;
    PGET_D3COLD_CAPABILITY              GetD3ColdCapability;
    PGET_D3COLD_CAPABILITY              GetBusDriverD3ColdSupport;
    PGET_D3COLD_LAST_TRANSITION_STATUS  GetLastTransitionStatus;

} D3COLD_SUPPORT_INTERFACE, *PD3COLD_SUPPORT_INTERFACE;

// end_wdm end_wudfpwdm
// begin_ntddk

typedef struct _AGP_TARGET_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // config munging routines
    //
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;
    UCHAR CapabilityID;  // 2 (AGPv2 host) or new 0xE (AGPv3 bridge)

} AGP_TARGET_BUS_INTERFACE_STANDARD, *PAGP_TARGET_BUS_INTERFACE_STANDARD;

// end_ntddk
// begin_wdm

//
// The following definitions are used in ACPI QueryInterface
//
typedef BOOLEAN (* PGPE_SERVICE_ROUTINE) (
                            PVOID,
                            PVOID);

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS (* PGPE_CONNECT_VECTOR) (
                            PDEVICE_OBJECT,
                            ULONG,
                            KINTERRUPT_MODE,
                            BOOLEAN,
                            PGPE_SERVICE_ROUTINE,
                            PVOID,
                            PVOID);

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS (* PGPE_DISCONNECT_VECTOR) (
                            PVOID);

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS (* PGPE_ENABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS (* PGPE_DISABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS (* PGPE_CLEAR_STATUS) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef
VOID (* PDEVICE_NOTIFY_CALLBACK) (
                            PVOID,
                            ULONG);

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS (* PREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK,
                            PVOID);

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
void (* PUNREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK);

typedef struct _ACPI_INTERFACE_STANDARD {
    //
    // Generic interface header
    //
    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;
    //
    // ACPI interfaces
    //
    PGPE_CONNECT_VECTOR                     GpeConnectVector;
    PGPE_DISCONNECT_VECTOR                  GpeDisconnectVector;
    PGPE_ENABLE_EVENT                       GpeEnableEvent;
    PGPE_DISABLE_EVENT                      GpeDisableEvent;
    PGPE_CLEAR_STATUS                       GpeClearStatus;
    PREGISTER_FOR_DEVICE_NOTIFICATIONS      RegisterForDeviceNotifications;
    PUNREGISTER_FOR_DEVICE_NOTIFICATIONS    UnregisterForDeviceNotifications;

} ACPI_INTERFACE_STANDARD, *PACPI_INTERFACE_STANDARD;

//
// The following definitions are used in GUID_ACPI_INTERFACE_STANDARD2,
// The first version (above) passes in DEVICE_OBJECs, where this one
// is based on Contexts.
//

typedef
BOOLEAN
(*PGPE_SERVICE_ROUTINE2) (
    PVOID   ObjectContext,
    PVOID   ServiceContext
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS
(*PGPE_CONNECT_VECTOR2) (
    PVOID           Context,
    ULONG           GpeNumber,
    KINTERRUPT_MODE Mode,
    BOOLEAN         Shareable,
    PGPE_SERVICE_ROUTINE    ServiceRoutine,
    PVOID           ServiceContext,
    PVOID           *ObjectContext
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS
(*PGPE_DISCONNECT_VECTOR2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS
(*PGPE_ENABLE_EVENT2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS
(*PGPE_DISABLE_EVENT2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS
(*PGPE_CLEAR_STATUS2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
(*PDEVICE_NOTIFY_CALLBACK2) (
    PVOID   NotificationContext,
    ULONG   NotifyCode
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTSTATUS
(*PREGISTER_FOR_DEVICE_NOTIFICATIONS2) (
    PVOID   Context,
    PDEVICE_NOTIFY_CALLBACK2    NotificationHandler,
    PVOID   NotificationContext
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
(*PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2) (
    PVOID   Context
    );

typedef struct {
    //
    // Generic interface header
    //
    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;
    //
    // ACPI interfaces
    //
    PGPE_CONNECT_VECTOR2                    GpeConnectVector;
    PGPE_DISCONNECT_VECTOR2                 GpeDisconnectVector;
    PGPE_ENABLE_EVENT2                      GpeEnableEvent;
    PGPE_DISABLE_EVENT2                     GpeDisableEvent;
    PGPE_CLEAR_STATUS2                      GpeClearStatus;
    PREGISTER_FOR_DEVICE_NOTIFICATIONS2     RegisterForDeviceNotifications;
    PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2   UnregisterForDeviceNotifications;

} ACPI_INTERFACE_STANDARD2, *PACPI_INTERFACE_STANDARD2;

// end_wdm
// begin_nthal

typedef enum _ACPI_REG_TYPE {
    PM1a_ENABLE,
    PM1b_ENABLE,
    PM1a_STATUS,
    PM1b_STATUS,
    PM1a_CONTROL,
    PM1b_CONTROL,
    GP_STATUS,
    GP_ENABLE,
    SMI_CMD,
    MaxRegType
} ACPI_REG_TYPE, *PACPI_REG_TYPE;

typedef USHORT (*PREAD_ACPI_REGISTER) (
  _In_ ACPI_REG_TYPE AcpiReg,
  _In_ ULONG         Register);

typedef VOID (*PWRITE_ACPI_REGISTER) (
  _In_ ACPI_REG_TYPE AcpiReg,
  _In_ ULONG         Register,
  _In_ USHORT        Value
  );

typedef struct ACPI_REGS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // READ/WRITE_ACPI_REGISTER functions
    //
    PREAD_ACPI_REGISTER  ReadAcpiRegister;
    PWRITE_ACPI_REGISTER WriteAcpiRegister;

} ACPI_REGS_INTERFACE_STANDARD, *PACPI_REGS_INTERFACE_STANDARD;


typedef NTSTATUS (*PHAL_QUERY_ALLOCATE_PORT_RANGE) (
  _In_ BOOLEAN IsSparse,
  _In_ BOOLEAN PrimaryIsMmio,
  _In_opt_ PVOID VirtBaseAddr,
  _In_ PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
  _In_ ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
  _Out_ PUSHORT NewRangeId
  );

typedef VOID (*PHAL_FREE_PORT_RANGE)(
    _In_ USHORT RangeId
    );


typedef struct _HAL_PORT_RANGE_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // QueryAllocateRange/FreeRange functions
    //
    PHAL_QUERY_ALLOCATE_PORT_RANGE QueryAllocateRange;
    PHAL_FREE_PORT_RANGE FreeRange;

} HAL_PORT_RANGE_INTERFACE, *PHAL_PORT_RANGE_INTERFACE;


//
// describe the CMOS HAL interface
//

typedef enum _CMOS_DEVICE_TYPE {
    CmosTypeStdPCAT,
    CmosTypeIntelPIIX4,
    CmosTypeDal1501
} CMOS_DEVICE_TYPE;


typedef
ULONG
(*PREAD_ACPI_CMOS) (
    _In_ CMOS_DEVICE_TYPE CmosType,
    _In_ ULONG SourceAddress,
    _Out_writes_bytes_(ByteCount) PUCHAR DataBuffer,
    _In_ ULONG ByteCount
    );

typedef
ULONG
(*PWRITE_ACPI_CMOS) (
    _In_ CMOS_DEVICE_TYPE CmosType,
    _In_ ULONG SourceAddress,
    _In_reads_bytes_(ByteCount) PUCHAR DataBuffer,
    _In_ ULONG ByteCount
    );

typedef struct _ACPI_CMOS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // READ/WRITE_ACPI_CMOS functions
    //
    PREAD_ACPI_CMOS     ReadCmos;
    PWRITE_ACPI_CMOS    WriteCmos;

} ACPI_CMOS_INTERFACE_STANDARD, *PACPI_CMOS_INTERFACE_STANDARD;

//
// These definitions are used for getting PCI Interrupt Routing interfaces
//

typedef struct {
    PVOID   LinkNode;
    ULONG   StaticVector;
    UCHAR   Flags;
} ROUTING_TOKEN, *PROUTING_TOKEN;

//
// Flag indicating that the device supports
// MSI interrupt routing or that the provided token contains
// MSI routing information
//

#define PCI_MSI_ROUTING         0x1
#define PCI_STATIC_ROUTING      0x2


//
// PCI devices which busmaster may appear on the bus with a tag from
// the device or from one or more of the upstream bridges or switches.  This
// enumerates the way that a device will appear to the root complex.
//
typedef enum _PCI_BUSMASTER_RID_TYPE {
    BusmasterRidFromDeviceRid,
    BusmasterRidFromBridgeRid,
    BusmasterRidFromMultipleBridges
} PCI_BUSMASTER_RID_TYPE, *PPCI_BUSMASTER_RID_TYPE;

typedef struct _PCI_BUSMASTER_DESCRIPTOR {

    PCI_BUSMASTER_RID_TYPE Type;

    ULONG Segment;

    union {

        struct {
            UCHAR   Bus;
            UCHAR   Device;
            UCHAR   Function;
            UCHAR   Reserved;
        } DeviceRid;

        struct {
            UCHAR   Bus;
            UCHAR   Device;
            UCHAR   Function;
            UCHAR   Reserved;
        } BridgeRid;

        struct {
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
        } MultipleBridges;

    } DUMMYSTRUCTNAME;
} PCI_BUSMASTER_DESCRIPTOR, *PPCI_BUSMASTER_DESCRIPTOR;

typedef
NTSTATUS
(*PGET_INTERRUPT_ROUTING)(
    _In_  PDEVICE_OBJECT  Pdo,
    _Inout_ ULONG           *Bus,
    _Inout_ ULONG           *PciSlot,
    _Out_opt_ UCHAR           *InterruptLine,
    _Out_opt_ UCHAR           *InterruptPin,
    _Out_opt_ UCHAR           *ClassCode,
    _Out_opt_ UCHAR           *SubClassCode,
    _Outptr_result_maybenull_ PDEVICE_OBJECT  *ParentPdo,
    _Out_opt_ UCHAR           *Flags,
    _Out_opt_ UCHAR                    *PhantomFunctionBits,
    _Out_opt_ PCI_BUSMASTER_DESCRIPTOR *InitiatingRidDescriptor
    );

typedef
VOID
(*PUPDATE_INTERRUPT_LINE)(
    _In_ PDEVICE_OBJECT Pdo,
    _In_ UCHAR LineRegister
    );

typedef struct _INT_ROUTE_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PGET_INTERRUPT_ROUTING GetInterruptRouting;
    PVOID                   Reserved;
    PUPDATE_INTERRUPT_LINE UpdateInterruptLine;

} INT_ROUTE_INTERFACE_STANDARD, *PINT_ROUTE_INTERFACE_STANDARD;

// Some well-known interface versions supported by the PCI Bus Driver

#define PCI_INT_ROUTE_INTRF_STANDARD_VER 2

// end_nthal

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoSynchronousInvalidateDeviceRelations(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ DEVICE_RELATION_TYPE Type
    );
#endif

// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoReportDetectedDevice(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ INTERFACE_TYPE LegacyBusType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _In_opt_ PCM_RESOURCE_LIST ResourceList,
    _In_opt_ PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    _In_ BOOLEAN ResourceAssigned,
    _Inout_ PDEVICE_OBJECT *DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoReportRootDevice(
    _In_ PDRIVER_OBJECT DriverObject
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoInvalidateDeviceRelations(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ DEVICE_RELATION_TYPE Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoRequestDeviceEject(
    _In_ PDEVICE_OBJECT PhysicalDeviceObject
    );
#endif

typedef VOID (*PIO_DEVICE_EJECT_CALLBACK)(
    _In_ NTSTATUS Status,
    _Inout_opt_ PVOID Context
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoRequestDeviceEjectEx(
    _In_ PDEVICE_OBJECT PhysicalDeviceObject,
    _In_opt_ PIO_DEVICE_EJECT_CALLBACK Callback,
    _In_opt_ PVOID Context,
    _In_opt_ PDRIVER_OBJECT DriverObject
    );
#endif

// end_wdm

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoRequestDeviceRemovalForReset(
    _In_ PDEVICE_OBJECT PhysicalDeviceObject,
    _In_ ULONG Flags
    );
#endif

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_When_((DeviceProperty & __string_type),
    _At_(PropertyBuffer,
        _Post_z_)
    )
_When_((DeviceProperty & __multiString_type),
    _At_(PropertyBuffer,
        _Post_ _NullNull_terminated_)
    )
NTKERNELAPI
NTSTATUS
IoGetDeviceProperty(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ DEVICE_REGISTRY_PROPERTY DeviceProperty,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_opt_(BufferLength) PVOID PropertyBuffer,
    _Out_ _Deref_out_range_(<=, BufferLength) PULONG ResultLength
    );
#endif

// begin_wudfwdm
//
// The following definitions are used in IoOpenDeviceRegistryKey
//

#define PLUGPLAY_REGKEY_DEVICE  1
#define PLUGPLAY_REGKEY_DRIVER  2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4

// end_wudfwdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoOpenDeviceRegistryKey(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG DevInstKeyType,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE DevInstRegKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterDeviceInterface(
    _In_ PDEVICE_OBJECT PhysicalDeviceObject,
    _In_ CONST GUID *InterfaceClassGuid,
    _In_opt_ PUNICODE_STRING ReferenceString,
    _Out_ _When_(return==0,
                     _At_(SymbolicLinkName->Buffer, __drv_allocatesMem(Mem)))
    PUNICODE_STRING SymbolicLinkName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    _In_ PUNICODE_STRING SymbolicLinkName,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE DeviceInterfaceKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoSetDeviceInterfaceState(
    _In_ PUNICODE_STRING SymbolicLinkName,
    _In_ BOOLEAN Enable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaces(
    _In_ CONST GUID *InterfaceClassGuid,
    _In_opt_ PDEVICE_OBJECT PhysicalDeviceObject,
    _In_ ULONG Flags,
    _Outptr_result_nullonfailure_
    _At_(*SymbolicLinkList,
        _When_(return==0, __drv_allocatesMem(Mem)))
    PZZWSTR *SymbolicLinkList
    );
#endif

#define DEVICE_INTERFACE_INCLUDE_NONACTIVE   0x00000001

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaceAlias(
    _In_ PUNICODE_STRING SymbolicLinkName,
    _In_ CONST GUID *AliasInterfaceClassGuid,
    _Out_
    _When_(return==0,
               _At_(AliasSymbolicLinkName->Buffer, __drv_allocatesMem(Mem)))
    PUNICODE_STRING AliasSymbolicLinkName
    );
#endif

//
// Define PnP notification event categories
//

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved,
    EventCategoryHardwareProfileChange,
    EventCategoryDeviceInterfaceChange,
    EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY;

//
// Define flags that modify the behavior of IoRegisterPlugPlayNotification
// for the various event categories...
//

#define PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES    0x00000001

typedef
_Function_class_(DRIVER_NOTIFICATION_CALLBACK_ROUTINE)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
DRIVER_NOTIFICATION_CALLBACK_ROUTINE (
    _In_ PVOID NotificationStructure,
    _Inout_opt_ PVOID Context
);
typedef DRIVER_NOTIFICATION_CALLBACK_ROUTINE
    *PDRIVER_NOTIFICATION_CALLBACK_ROUTINE;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoRegisterPlugPlayNotification(
    _In_ IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    _In_ ULONG EventCategoryFlags,
    _In_opt_ PVOID EventCategoryData,
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
    _Inout_opt_ __drv_aliasesMem PVOID Context,
    _Outptr_result_nullonfailure_
    _At_(*NotificationEntry,
        _When_(return==0, __drv_allocatesMem(Mem)))
    PVOID *NotificationEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoUnregisterPlugPlayNotification(
    _In_ __drv_freesMem(Pool) PVOID NotificationEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoUnregisterPlugPlayNotificationEx(
    _In_ __drv_freesMem(Pool) PVOID NotificationEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChange(
    _In_ PDEVICE_OBJECT PhysicalDeviceObject,
    _In_ PVOID NotificationStructure  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    );
#endif

typedef
_Function_class_(DEVICE_CHANGE_COMPLETE_CALLBACK)
_IRQL_requires_same_
VOID
DEVICE_CHANGE_COMPLETE_CALLBACK(
    _Inout_opt_ PVOID Context
    );
typedef DEVICE_CHANGE_COMPLETE_CALLBACK *PDEVICE_CHANGE_COMPLETE_CALLBACK;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
IoInvalidateDeviceState(
    _In_ PDEVICE_OBJECT PhysicalDeviceObject
    );
#endif

#define IoAdjustPagingPathCount(_count_,_paging_) {     \
    if (_paging_) {                                     \
        InterlockedIncrement(_count_);                  \
    } else {                                            \
        InterlockedDecrement(_count_);                  \
    }                                                   \
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChangeAsynchronous(
    _In_ PDEVICE_OBJECT PhysicalDeviceObject,
    _In_ PVOID NotificationStructure,  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    _In_opt_ PDEVICE_CHANGE_COMPLETE_CALLBACK Callback,
    _In_opt_ PVOID Context
    );
#endif

// end_wdm
// begin_ntddk
//
// Device location interface declarations
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTSTATUS
(*PGET_LOCATION_STRING) (
    _Inout_opt_ PVOID Context,
    _Outptr_
    _At_(*LocationStrings,
        _When_(return == 0, __drv_allocatesMem(Mem)))
    PZZWSTR *LocationStrings
    );

typedef struct _PNP_LOCATION_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // interface specific entry
    //
    PGET_LOCATION_STRING GetLocationString;

} PNP_LOCATION_INTERFACE, *PPNP_LOCATION_INTERFACE;

//
// Resource arbiter declarations
//

typedef enum _ARBITER_ACTION {
    ArbiterActionTestAllocation,
    ArbiterActionRetestAllocation,
    ArbiterActionCommitAllocation,
    ArbiterActionRollbackAllocation,
    ArbiterActionQueryAllocatedResources,
    ArbiterActionWriteReservedResources,
    ArbiterActionQueryConflict,
    ArbiterActionQueryArbitrate,
    ArbiterActionAddReserved,
    ArbiterActionBootAllocation
} ARBITER_ACTION, *PARBITER_ACTION;

typedef struct _ARBITER_CONFLICT_INFO {
    //
    // The device object owning the device that is causing the conflict
    //
    PDEVICE_OBJECT OwningObject;

    //
    // The start of the conflicting range
    //
    ULONGLONG Start;

    //
    // The end of the conflicting range
    //
    ULONGLONG End;

} ARBITER_CONFLICT_INFO, *PARBITER_CONFLICT_INFO;

//
// The parameters for those actions
//

typedef struct _ARBITER_TEST_ALLOCATION_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's
    //
    _Inout_ PLIST_ENTRY ArbitrationList;

    //
    // The size of the AllocateFrom array
    //
    _In_ ULONG AllocateFromCount;

    //
    // Array of resource descriptors describing the resources available
    // to the arbiter for it to arbitrate
    //
    _In_ PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;

} ARBITER_TEST_ALLOCATION_PARAMETERS, *PARBITER_TEST_ALLOCATION_PARAMETERS;


typedef struct _ARBITER_RETEST_ALLOCATION_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's
    //
    _Inout_ PLIST_ENTRY ArbitrationList;

    //
    // The size of the AllocateFrom array
    //
    _In_ ULONG AllocateFromCount;

    //
    // Array of resource descriptors describing the resources available
    // to the arbiter for it to arbitrate
    //
    _In_ PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom;

} ARBITER_RETEST_ALLOCATION_PARAMETERS, *PARBITER_RETEST_ALLOCATION_PARAMETERS;

typedef struct _ARBITER_BOOT_ALLOCATION_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's
    //
    _Inout_ PLIST_ENTRY ArbitrationList;

} ARBITER_BOOT_ALLOCATION_PARAMETERS, *PARBITER_BOOT_ALLOCATION_PARAMETERS;


typedef struct _ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS {

    //
    // The resources that are currently allocated
    //
    _Out_ PCM_PARTIAL_RESOURCE_LIST *AllocatedResources;

} ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS, *PARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS;

typedef struct _ARBITER_QUERY_CONFLICT_PARAMETERS {

    //
    // This is the device we are trying to find a conflict for
    //
    _In_ PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // This is the resource to find the conflict for
    //
    _In_ PIO_RESOURCE_DESCRIPTOR ConflictingResource;

    //
    // Number of devices conflicting on the resource
    //
    _Out_ PULONG ConflictCount;

    //
    // Pointer to array describing the conflicting device objects and ranges
    //
    _Out_ PARBITER_CONFLICT_INFO *Conflicts;

} ARBITER_QUERY_CONFLICT_PARAMETERS, *PARBITER_QUERY_CONFLICT_PARAMETERS;

typedef struct _ARBITER_QUERY_ARBITRATE_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's - should have
    // only one entry
    //
    _In_ PLIST_ENTRY ArbitrationList;

} ARBITER_QUERY_ARBITRATE_PARAMETERS, *PARBITER_QUERY_ARBITRATE_PARAMETERS;

typedef struct _ARBITER_ADD_RESERVED_PARAMETERS {

    //
    // Doubly linked list of ARBITER_LIST_ENTRY's - should have
    // only one entry
    //
    _In_ PDEVICE_OBJECT ReserveDevice;

} ARBITER_ADD_RESERVED_PARAMETERS, *PARBITER_ADD_RESERVED_PARAMETERS;


typedef struct _ARBITER_PARAMETERS {

    union {

        ARBITER_TEST_ALLOCATION_PARAMETERS              TestAllocation;
        ARBITER_RETEST_ALLOCATION_PARAMETERS            RetestAllocation;
        ARBITER_BOOT_ALLOCATION_PARAMETERS              BootAllocation;
        ARBITER_QUERY_ALLOCATED_RESOURCES_PARAMETERS    QueryAllocatedResources;
        ARBITER_QUERY_CONFLICT_PARAMETERS               QueryConflict;
        ARBITER_QUERY_ARBITRATE_PARAMETERS              QueryArbitrate;
        ARBITER_ADD_RESERVED_PARAMETERS                 AddReserved;

    } Parameters;

} ARBITER_PARAMETERS, *PARBITER_PARAMETERS;

typedef enum _ARBITER_REQUEST_SOURCE {

    ArbiterRequestUndefined = -1,
    ArbiterRequestLegacyReported,   // IoReportResourceUsage
    ArbiterRequestHalReported,      // IoReportHalResourceUsage
    ArbiterRequestLegacyAssigned,   // IoAssignResources
    ArbiterRequestPnpDetected,      // IoReportResourceForDetection
    ArbiterRequestPnpEnumerated     // IRP_MN_QUERY_RESOURCE_REQUIREMENTS

} ARBITER_REQUEST_SOURCE;


typedef enum _ARBITER_RESULT {

    ArbiterResultUndefined = -1,
    ArbiterResultSuccess,
    ArbiterResultExternalConflict, // This indicates that the request can never be solved for devices in this list
    ArbiterResultNullRequest       // The request was for length zero and thus no translation should be attempted

} ARBITER_RESULT;

//
// ARBITER_FLAG_BOOT_CONFIG - this indicates that the request is for the
// resources assigned by the firmware/BIOS.  It should be succeeded even if
// it conflicts with another devices boot config.
//

#define ARBITER_FLAG_BOOT_CONFIG 0x00000001

//
// ARBITER_FLAG_ROOT_ENUM - This indicates that the associated device was root-
// enumerated.  This might happen either because somebody force-installed a
// PnP driver without a bus driver or because we've associated a stand-in device
// for an old NT-4-style non-PnP driver.
//

#define ARBITER_FLAG_ROOT_ENUM   0x00000002

//
// ARBITER_FLAG_OTHER_ENUM - This indicates that the device was not a candidate
// for ARBITER_FLAG_ROOT_ENUM.  This exists as its own flag to differentiate the
// case where the status of the device has not yet been determined.
//

#define ARBITER_FLAG_OTHER_ENUM  0x00000004

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoReportResourceForDetection(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_reads_bytes_opt_(DriverListSize) PCM_RESOURCE_LIST DriverList,
    _In_opt_ ULONG DriverListSize,
    _In_opt_ PDEVICE_OBJECT DeviceObject,
    _In_reads_bytes_opt_(DeviceListSize) PCM_RESOURCE_LIST DeviceList,
    _In_opt_ ULONG DeviceListSize,
    _Out_ PBOOLEAN ConflictDetected
    );
#endif

typedef struct _ARBITER_LIST_ENTRY {

    //
    // This is a doubly linked list of entries for easy sorting
    //
    LIST_ENTRY ListEntry;

    //
    // The number of alternative allocation
    //
    ULONG AlternativeCount;

    //
    // Pointer to an array of resource descriptors for the possible allocations
    //
    _Field_size_(AlternativeCount)
    PIO_RESOURCE_DESCRIPTOR Alternatives;

    //
    // The device object of the device requesting these resources.
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Indicates where the request came from
    //
    ARBITER_REQUEST_SOURCE RequestSource;

    //
    // Flags these indicate a variety of things (use ARBITER_FLAG_*)
    //
    ULONG Flags;

    //
    // Space to aid the arbiter in processing the list it is initialized to 0 when
    // the entry is created.  The system will not attempt to interpret it.
    //
    LONG_PTR WorkSpace;

    //
    // Interface Type, Slot Number and Bus Number from Resource Requirements list,
    // used only for reverse identification.
    //
    INTERFACE_TYPE InterfaceType;
    ULONG SlotNumber;
    ULONG BusNumber;

    //
    // A pointer to a descriptor to indicate the resource that was allocated.
    // This is allocated by the system and filled in by the arbiter in response to an
    // ArbiterActionTestAllocation.
    //
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Assignment;

    //
    // Pointer to the alternative that was chosen from to provide the assignment.
    // This is filled in by the arbiter in response to an ArbiterActionTestAllocation.
    //
    PIO_RESOURCE_DESCRIPTOR SelectedAlternative;

    //
    // The result of the operation
    // This is filled in by the arbiter in response to an ArbiterActionTestAllocation.
    //
    ARBITER_RESULT Result;

} ARBITER_LIST_ENTRY, *PARBITER_LIST_ENTRY;

//
// The arbiter's entry point
//

typedef
NTSTATUS
(*PARBITER_HANDLER) (
    _Inout_opt_ PVOID Context,
    _In_ ARBITER_ACTION Action,
    _Inout_ PARBITER_PARAMETERS Parameters
    );

//
// Arbiter interface
//

#define ARBITER_PARTIAL   0x00000001


typedef struct _ARBITER_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Entry point to the arbiter
    //
    PARBITER_HANDLER ArbiterHandler;

    //
    // Other information about the arbiter, use ARBITER_* flags
    //
    ULONG Flags;

} ARBITER_INTERFACE, *PARBITER_INTERFACE;

//
// The directions translation can take place in
//

typedef enum _RESOURCE_TRANSLATION_DIRECTION {
    TranslateChildToParent,
    TranslateParentToChild
} RESOURCE_TRANSLATION_DIRECTION;

//
// Translation functions
//

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_HANDLER)(
    _Inout_opt_ PVOID Context,
    _In_ PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    _In_ RESOURCE_TRANSLATION_DIRECTION Direction,
    _In_opt_ ULONG AlternativesCount,
    _In_reads_opt_(AlternativesCount) IO_RESOURCE_DESCRIPTOR Alternatives[],
    _In_ PDEVICE_OBJECT PhysicalDeviceObject,
    _Out_ PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

typedef
NTSTATUS
(*PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER)(
    _Inout_opt_ PVOID Context,
    _In_ PIO_RESOURCE_DESCRIPTOR Source,
    _In_ PDEVICE_OBJECT PhysicalDeviceObject,
    _Out_ PULONG TargetCount,
    _Out_writes_(*TargetCount) PIO_RESOURCE_DESCRIPTOR *Target
);

//
// Translator Interface
//

typedef struct _TRANSLATOR_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PTRANSLATE_RESOURCE_HANDLER TranslateResources;
    PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements;
} TRANSLATOR_INTERFACE, *PTRANSLATOR_INTERFACE;

// end_ntddk
// begin_nthal

//
// Legacy Device Detection Handler
//

typedef
NTSTATUS
(*PLEGACY_DEVICE_DETECTION_HANDLER)(
    _Inout_opt_ PVOID Context,
    _In_ INTERFACE_TYPE LegacyBusType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _Outptr_ PDEVICE_OBJECT *PhysicalDeviceObject
);

//
// Legacy Device Detection Interface
//

typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PLEGACY_DEVICE_DETECTION_HANDLER LegacyDeviceDetection;
} LEGACY_DEVICE_DETECTION_INTERFACE, *PLEGACY_DEVICE_DETECTION_INTERFACE;

// end_nthal end_ntifs
// begin_wdm

//
// Header structure for all Plug&Play notification events...
//

typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
    USHORT Version; // presently at version 1.
    USHORT Size;    // size (in bytes) of header + event-specific data.
    GUID Event;
    //
    // Event-specific stuff starts here.
    //
} PLUGPLAY_NOTIFICATION_HEADER, *PPLUGPLAY_NOTIFICATION_HEADER;

//
// Notification structure for all EventCategoryHardwareProfileChange events...
//

typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // (No event-specific data)
    //
} HWPROFILE_CHANGE_NOTIFICATION, *PHWPROFILE_CHANGE_NOTIFICATION;


//
// Notification structure for all EventCategoryDeviceInterfaceChange events...
//

typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    GUID InterfaceClassGuid;
    PUNICODE_STRING SymbolicLinkName;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION, *PDEVICE_INTERFACE_CHANGE_NOTIFICATION;


//
// Notification structures for EventCategoryTargetDeviceChange...
//

//
// The following structure is used for TargetDeviceQueryRemove,
// TargetDeviceRemoveCancelled, and TargetDeviceRemoveComplete:
//
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;
} TARGET_DEVICE_REMOVAL_NOTIFICATION, *PTARGET_DEVICE_REMOVAL_NOTIFICATION;

//
// The following structure header is used for all other (i.e., 3rd-party)
// target device change events.  The structure accommodates both a
// variable-length binary data buffer, and a variable-length unicode text
// buffer.  The header must indicate where the text buffer begins, so that
// the data can be delivered in the appropriate format (ANSI or Unicode)
// to user-mode recipients (i.e., that have registered for handle-based
// notification via RegisterDeviceNotification).
//

typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;    // This field must be set to NULL by callers of
                                // IoReportTargetDeviceChange.  Clients that
                                // have registered for target device change
                                // notification on the affected PDO will be
                                // called with this field set to the file object
                                // they specified during registration.
                                //
    LONG NameBufferOffset;      // offset (in bytes) from beginning of
                                // CustomDataBuffer where text begins (-1 if none)
                                //
    UCHAR CustomDataBuffer[1];  // variable-length buffer, containing (optionally)
                                // a binary data at the start of the buffer,
                                // followed by an optional unicode text buffer
                                // (word-aligned).
                                //
} TARGET_DEVICE_CUSTOM_NOTIFICATION, *PTARGET_DEVICE_CUSTOM_NOTIFICATION;

// begin_wudfwdm

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// Custom device properties...
//

#include <devpropdef.h>

//
// Definitions of property flags.
//

#define PLUGPLAY_PROPERTY_PERSISTENT  0x00000001

#endif

// end_wudfwdm

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoSetDevicePropertyData (
    _In_ PDEVICE_OBJECT     Pdo,
    _In_ CONST DEVPROPKEY   *PropertyKey,
    _In_ LCID               Lcid,
    _In_ ULONG              Flags,
    _In_ DEVPROPTYPE        Type,
    _In_ ULONG              Size,
    _In_reads_bytes_opt_(Size)
         PVOID              Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoGetDevicePropertyData (
    _In_ PDEVICE_OBJECT     Pdo,
    _In_ CONST DEVPROPKEY   *PropertyKey,
    _In_ LCID               Lcid,
    _Reserved_ ULONG        Flags,
    _In_ ULONG              Size,
    _Out_writes_bytes_to_(Size, *RequiredSize)
          PVOID             Data,
    _Out_ PULONG            RequiredSize,
    _Out_ PDEVPROPTYPE      Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoSetDeviceInterfacePropertyData (
    _In_ PUNICODE_STRING    SymbolicLinkName,
    _In_ CONST DEVPROPKEY   *PropertyKey,
    _In_ LCID               Lcid,
    _In_ ULONG              Flags,
    _In_ DEVPROPTYPE        Type,
    _In_ ULONG              Size,
    _In_reads_bytes_opt_(Size)
         PVOID              Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoGetDeviceInterfacePropertyData (
    _In_ PUNICODE_STRING    SymbolicLinkName,
    _In_ CONST DEVPROPKEY   *PropertyKey,
    _In_ LCID               Lcid,
    _Reserved_ ULONG        Flags,
    _In_ ULONG              Size,
    _Out_writes_bytes_to_(Size, *RequiredSize)
          PVOID             Data,
    _Out_ PULONG            RequiredSize,
    _Out_ PDEVPROPTYPE      Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
IoGetDeviceNumaNode (
    _In_ PDEVICE_OBJECT Pdo,
    _Out_ PUSHORT NodeNumber
    );
#endif

// end_wdm

#define PNP_REPLACE_TEST_QUIESCE 0x80000000

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WS08)
_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
NTKERNELAPI
NTSTATUS
NTAPI
IoReplacePartitionUnit (
    _In_ PDEVICE_OBJECT TargetPdo,
    _In_ PDEVICE_OBJECT SparePdo,
    _In_ ULONG Flags
    );
#endif

// end_wdm

typedef
NTSTATUS
(*PPARTITION_UNIT_GET_UNIQUE_ID) (
    _In_ PVOID Context,
    _Out_ PULONG64 UniqueId
    );

#define SPARE_PROPERTY_HARDWARE_MIRRORING   0x01
#define SPARE_PROPERTY_HARDWARE_PAGE_COPY   0x02
#define SPARE_PROPERTY_HARDWARE_QUIESCE     0x04

typedef
NTSTATUS
(*PPARTITION_UNIT_GET_SPARE_PROPERTIES) (
    _In_ PVOID Context,
    _Out_ PULONG Properties
    );

typedef
BOOLEAN
(*PPARTITION_UNIT_IS_VALID_SPARE) (
    _In_ PVOID Context,
    _In_ ULONG64 UniqueId
    );

#define PARTITION_UNIT_INTERFACE_VERSION    1

typedef struct _PARTITION_UNIT_INTERFACE {

    //
    // Generic interface header.
    //

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Specific interface handlers.
    //

    PPARTITION_UNIT_GET_UNIQUE_ID GetUniqueId;
    PPARTITION_UNIT_GET_SPARE_PROPERTIES GetSpareProperties;
    PPARTITION_UNIT_IS_VALID_SPARE IsValidSpare;

} PARTITION_UNIT_INTERFACE, *PPARTITION_UNIT_INTERFACE;

// begin_wdm

//
// Define replace driver entrypoint.
//

typedef struct _PNP_REPLACE_DRIVER_INTERFACE *PPNP_REPLACE_DRIVER_INTERFACE;

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_DRIVER_INIT) (
    _Inout_ PPNP_REPLACE_DRIVER_INTERFACE Interface,
    _In_ PVOID Unused
    );

//
// Define parameters to replace driver.
//

#define PNP_REPLACE_NO_MAP MAXLONGLONG

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_MAP_MEMORY) (
    _In_    PHYSICAL_ADDRESS    TargetPhysicalAddress,
    _In_    PHYSICAL_ADDRESS    SparePhysicalAddress,
    _Inout_ PLARGE_INTEGER      NumberOfBytes,
    _Outptr_ PVOID *TargetAddress,
    _Outptr_ PVOID *SpareAddress
    );

typedef struct _PNP_REPLACE_MEMORY_LIST {

    ULONG AllocatedCount;
    ULONG Count;
    ULONGLONG TotalLength;
    struct {
        PHYSICAL_ADDRESS Address;
        ULONGLONG Length;
    } Ranges[ANYSIZE_ARRAY];

} PNP_REPLACE_MEMORY_LIST, *PPNP_REPLACE_MEMORY_LIST;

typedef struct _PNP_REPLACE_PROCESSOR_LIST {

    PKAFFINITY Affinity;
    ULONG GroupCount;
    ULONG AllocatedCount;
    ULONG Count;
    ULONG ApicIds[ANYSIZE_ARRAY];

} PNP_REPLACE_PROCESSOR_LIST, *PPNP_REPLACE_PROCESSOR_LIST;

typedef struct _PNP_REPLACE_PROCESSOR_LIST_V1 {

    KAFFINITY AffinityMask;
    ULONG AllocatedCount;
    ULONG Count;
    ULONG ApicIds[ANYSIZE_ARRAY];

} PNP_REPLACE_PROCESSOR_LIST_V1, *PPNP_REPLACE_PROCESSOR_LIST_V1;

#define PNP_REPLACE_PARAMETERS_VERSION 2

typedef struct _PNP_REPLACE_PARAMETERS {

    ULONG Size;
    ULONG Version;

    ULONG64 Target;
    ULONG64 Spare;
    PPNP_REPLACE_PROCESSOR_LIST TargetProcessors;
    PPNP_REPLACE_PROCESSOR_LIST SpareProcessors;
    PPNP_REPLACE_MEMORY_LIST TargetMemory;
    PPNP_REPLACE_MEMORY_LIST SpareMemory;

    PREPLACE_MAP_MEMORY MapMemory;

} PNP_REPLACE_PARAMETERS, *PPNP_REPLACE_PARAMETERS;

//
// Define replace driver interface.
//

typedef
VOID
(*PREPLACE_UNLOAD) (
    VOID
    );

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_BEGIN) (
    _In_ PPNP_REPLACE_PARAMETERS Parameters,
    _Outptr_ PVOID *Context
);

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_END) (
    _In_ PVOID Context
    );

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_MIRROR_PHYSICAL_MEMORY) (
    _In_ PVOID Context,
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ LARGE_INTEGER ByteCount
    );

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_SET_PROCESSOR_ID) (
    _In_ PVOID Context,
    _In_ ULONG ApicId,
    _In_ BOOLEAN Target
    );

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_SWAP) (
    _In_ PVOID Context
    );

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_INITIATE_HARDWARE_MIRROR) (
    _In_ PVOID Context
    );

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_MIRROR_PLATFORM_MEMORY) (
    _In_ PVOID Context
    );

typedef
_Must_inspect_result_
NTSTATUS
(*PREPLACE_GET_MEMORY_DESTINATION) (
    _In_ PVOID Context,
    _In_ PHYSICAL_ADDRESS SourceAddress,
    _Out_ PPHYSICAL_ADDRESS DestinationAddress
    );

typedef
_Must_inspect_result_ NTSTATUS
(*PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE) (
    _In_ PVOID Context,
    _In_ BOOLEAN Enable
    );

#define PNP_REPLACE_DRIVER_INTERFACE_VERSION 1
#define PNP_REPLACE_DRIVER_INTERFACE_MINIMUM_SIZE \
             FIELD_OFFSET(PNP_REPLACE_DRIVER_INTERFACE, InitiateHardwareMirror)

#define PNP_REPLACE_MEMORY_SUPPORTED            0x0001
#define PNP_REPLACE_PROCESSOR_SUPPORTED         0x0002
#define PNP_REPLACE_HARDWARE_MEMORY_MIRRORING   0x0004
#define PNP_REPLACE_HARDWARE_PAGE_COPY          0x0008
#define PNP_REPLACE_HARDWARE_QUIESCE            0x0010

//
// Define interface structure.
//

typedef struct _PNP_REPLACE_DRIVER_INTERFACE {

    ULONG Size;
    ULONG Version;

    ULONG Flags;
    PREPLACE_UNLOAD Unload;
    PREPLACE_BEGIN BeginReplace;
    PREPLACE_END EndReplace;
    PREPLACE_MIRROR_PHYSICAL_MEMORY MirrorPhysicalMemory;
    PREPLACE_SET_PROCESSOR_ID SetProcessorId;
    PREPLACE_SWAP Swap;
    PREPLACE_INITIATE_HARDWARE_MIRROR InitiateHardwareMirror;
    PREPLACE_MIRROR_PLATFORM_MEMORY MirrorPlatformMemory;
    PREPLACE_GET_MEMORY_DESTINATION GetMemoryDestination;
    PREPLACE_ENABLE_DISABLE_HARDWARE_QUIESCE EnableDisableHardwareQuiesce;

} PNP_REPLACE_DRIVER_INTERFACE, *PPNP_REPLACE_DRIVER_INTERFACE;


#if (NTDDI_VERSION >= NTDDI_WINBLUE)

//
// Define crashdump runtime power interface.
//

typedef
NTSTATUS
(*PCRASHDUMP_POWER_ON)(
    _In_opt_ PVOID Context
    );

typedef struct _CRASHDUMP_FUNCTIONS_INTERFACE {

    //
    // generic interface header
    //

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Power-on at crashdump time method
    //

    PCRASHDUMP_POWER_ON PowerOn;

} CRASHDUMP_FUNCTIONS_INTERFACE, *PCRASHDUMP_FUNCTIONS_INTERFACE;
#endif

// end_wdm

//
// Ordering dependency routines and definitions.
//

#define PNP_DEPENDENCY_TYPE_INITIALIZATION 0x1
#define PNP_DEPENDENCY_TYPE_START          0x2

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoClearDependency (
    _In_ PDEVICE_OBJECT DependentPdo,
    _In_ PDEVICE_OBJECT ProviderPdo
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoDeleteAllDependencyRelations (
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoDuplicateDependency (
    _In_ PDEVICE_OBJECT ProviderPdo,
    _In_ PDEVICE_OBJECT NewProviderPdo
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoReserveDependency(
    _In_ PDEVICE_OBJECT DependentDevice,
    _In_ PCUNICODE_STRING ProviderId,
    _In_ ULONG DependencyTypes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoResolveDependency (
    _In_ PCUNICODE_STRING BindingId,
    _In_ PDEVICE_OBJECT Device
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoSetDependency(
    _In_ PDEVICE_OBJECT DependentDevice,
    _In_ PDEVICE_OBJECT ProviderDevice,
    _In_ ULONG DependencyTypes
    );
#endif

typedef enum {
    DependencyPathNone,
    DependencyPathDirect,
    DependencyPathIndirect
} PNP_DEPENDENCY_PATH_TYPE, *PPNP_DEPENDENCY_PATH_TYPE;

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
NTSTATUS
IoTestDependency(
    _In_ PDEVICE_OBJECT Dependent,
    _In_ PDEVICE_OBJECT Provider,
    _Out_ PPNP_DEPENDENCY_PATH_TYPE PathType,
    _Out_ PULONG DependencyTypes
    );
#endif

NTKERNELAPI
ULONG
IoPnPDeliverServicePowerNotification(
    _In_   POWER_ACTION           PowerOperation,
    _In_   ULONG                  PowerNotificationCode,
    _In_   ULONG                  PowerNotificationData,
    _In_   BOOLEAN                Synchronous
    );

// begin_nthal

typedef struct _DMA_CACHE_COHERENCY_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    BOOLEAN CacheCoherent;
} DMA_CACHE_COHERENCY_INTERFACE, *PDMA_CACHE_COHERENCY_INTERFACE;

typedef union _IOMMU_SVM_CAPABILITIES {
    struct {
        ULONG AtsCapability:1;
        ULONG PriCapability:1;
        ULONG PasidCapability:1;

        struct {
            ULONG PasidMaxWidth:5;
            ULONG PasidExePerm:1;
            ULONG PasidPrivMode:1;
            ULONG AtsPageAlignedRequest:1;
            ULONG AtsGlobalInvalidate:1;
            ULONG AtsInvalidateQueueDepth:5;
        } CapReg;

        ULONG Rsvd:15;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;
} IOMMU_SVM_CAPABILITIES, *PIOMMU_SVM_CAPABILITIES;

typedef NTSTATUS (*PHAL_DEVICE_POWER_TRANSITION_CALLBACK)(
    __in PDEVICE_OBJECT Pdo,
    __in DEVICE_POWER_STATE NewPowerState,
    __in PVOID Context
    );

typedef
_Function_class_(GET_SVM_CAPABILITIES)
_IRQL_requires_same_
NTSTATUS GET_SVM_CAPABILITIES(
    __inout PVOID Context,
    __out PIOMMU_SVM_CAPABILITIES CapabilitiesOut
    );
typedef GET_SVM_CAPABILITIES *PGET_SVM_CAPABILITIES;

typedef
_Function_class_(ENABLE_SVM_CAPABILITIES)
_IRQL_requires_same_
NTSTATUS ENABLE_SVM_CAPABILITIES(
    __in PVOID Context,
    __in PIOMMU_SVM_CAPABILITIES Capabilities,
    __in PHAL_DEVICE_POWER_TRANSITION_CALLBACK HalDevicePowerTransCallback,
    __in PVOID HalDevicePowerTransCallbackContext
    );
typedef ENABLE_SVM_CAPABILITIES *PENABLE_SVM_CAPABILITIES;

typedef
_Function_class_(DISABLE_SVM_CAPABILITIES)
_IRQL_requires_same_
NTSTATUS DISABLE_SVM_CAPABILITIES(
    __in PVOID Context,
    __in PIOMMU_SVM_CAPABILITIES Capabilities
    );
typedef DISABLE_SVM_CAPABILITIES *PDISABLE_SVM_CAPABILITIES;

typedef struct _IOMMU_DEVICE_PATH {
    GUID BusTypeGuid;
    ULONG UniqueIdLength;
    ULONG PathLength;
    PVOID UniqueId;
    PVOID Path;
} IOMMU_DEVICE_PATH, *PIOMMU_DEVICE_PATH;

typedef
_Function_class_(GET_DEVICE_PATH_INFORMATION)
_IRQL_requires_same_
NTSTATUS GET_DEVICE_PATH_INFORMATION(
    __in PVOID Context,
    __out PIOMMU_DEVICE_PATH *PathOut
    );
typedef GET_DEVICE_PATH_INFORMATION *PGET_DEVICE_PATH_INFORMATION;

typedef struct _IOMMU_BUS_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PGET_SVM_CAPABILITIES GetSvmCapabilities;
    PENABLE_SVM_CAPABILITIES EnableSvmCapabilities;
    PDISABLE_SVM_CAPABILITIES DisableSvmCapabilities;
    PGET_DEVICE_PATH_INFORMATION GetDevicePathInformation;
} IOMMU_BUS_INTERFACE, *PIOMMU_BUS_INTERFACE;

// end_nthal

// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

#define DEVICE_RESET_INTERFACE_VERSION  1

//
// Define an enum for various reset types supported.
//
// Note reset type value should not exceed 31 as the "SupportedResetTypes"
// field within the reset interface is a ULONG.
//

typedef enum _DEVICE_RESET_TYPE
{
    FunctionLevelDeviceReset,
    PlatformLevelDeviceReset
} DEVICE_RESET_TYPE;

typedef
VOID
(DEVICE_RESET_COMPLETION)(
    _In_ NTSTATUS Status,
    _Inout_opt_ PVOID Context
    );

typedef DEVICE_RESET_COMPLETION *PDEVICE_RESET_COMPLETION;

typedef struct _FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS {
    ULONG Size;
    PDEVICE_RESET_COMPLETION DeviceResetCompletion;
    PVOID CompletionContext;
} FUNCTION_LEVEL_DEVICE_RESET_PARAMETERS, *PFUNCTION_LEVEL_DEVICE_RESET_PARAMETERS;

typedef
NTSTATUS
(*PDEVICE_RESET_HANDLER)(
    _In_ PVOID InterfaceContext,
    _In_ DEVICE_RESET_TYPE ResetType,
    _In_ ULONG Flags,
    _In_opt_ PVOID ResetParameters
    );

typedef struct _DEVICE_RESET_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // device reset interface
    //
    PDEVICE_RESET_HANDLER DeviceReset;
    ULONG SupportedResetTypes;
    PVOID Reserved;
} DEVICE_RESET_INTERFACE_STANDARD, *PDEVICE_RESET_INTERFACE_STANDARD;

#endif
// end_wdm


//
//  Provides a known bad pointer address which always bugchecks if
//  acccessed.   This gives drivers a way to find pointer bugs by
//  initializing invalid pointers to this value.
//

extern PVOID MmBadPointer;


#define MM_BAD_POINTER (                               \
                       __pragma(warning(push))         \
                       __pragma(warning(disable:4995)) \
                       *(PVOID *) MmBadPointer         \
                       __pragma(warning(pop))          \
                        )

#pragma deprecated(MmBadPointer)  // Use MM_BAD_POINTER instead


//
// Define the old maximum disk transfer size to be used by MM and Cache
// Manager.  Current transfer sizes can typically be much larger.
//

#define MM_MAXIMUM_DISK_IO_SIZE          (0x10000)

//++
//
// ULONG_PTR
// ROUND_TO_PAGES (
//     _In_ ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES (
//     _In_ ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  (((Size) >> PAGE_SHIFT) + \
                               (((Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET (
//     _In_ PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN (
//     _In_ PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// SIZE_T
// ADDRESS_AND_SIZE_TO_SPAN_PAGES (
//     _In_ PVOID Va,
//     _In_ SIZE_T Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
    ((BYTE_OFFSET (Va) + ((SIZE_T) (Size)) + (PAGE_SIZE - 1)) >> PAGE_SHIFT)

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(COMPUTE_PAGES_SPANNED)   // Use ADDRESS_AND_SIZE_TO_SPAN_PAGES
#endif

#define COMPUTE_PAGES_SPANNED(Va, Size) ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size)


//++
//
// BOOLEAN
// IS_SYSTEM_ADDRESS
//     _In_ PVOID Va
//     )
//
// Routine Description:
//
//     This macro takes a virtual address and returns TRUE if the virtual address
//     is within system space, FALSE otherwise.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns TRUE is the address is in system space.
//

#define IS_SYSTEM_ADDRESS(VA) ((VA) >= MM_SYSTEM_RANGE_START)

//++
// PPFN_NUMBER
// MmGetMdlPfnArray (
//     _In_ PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlPfnArray routine returns the virtual address of the
//     first element of the array of physical page numbers associated with
//     the MDL.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the first element of the array of
//     physical page numbers associated with the MDL.
//
//--

#define MmGetMdlPfnArray(Mdl) ((PPFN_NUMBER)(Mdl + 1))

//++
//
// PVOID
// MmGetMdlVirtualAddress (
//     _In_ PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlVirtualAddress returns the virtual address of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the buffer described by the Mdl
//
//--

#define MmGetMdlVirtualAddress(Mdl)                                     \
    ((PVOID) ((PCHAR) ((Mdl)->StartVa) + (Mdl)->ByteOffset))

//++
//
// ULONG
// MmGetMdlByteCount (
//     _In_ PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteCount returns the length in bytes of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte count of the buffer described by the Mdl
//
//--

#define MmGetMdlByteCount(Mdl)  ((Mdl)->ByteCount)

//++
//
// ULONG
// MmGetMdlByteOffset (
//     _In_ PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteOffset returns the byte offset within the page
//     of the buffer described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte offset within the page of the buffer described by the Mdl
//
//--

#define MmGetMdlByteOffset(Mdl)  ((Mdl)->ByteOffset)

//++
//
// PVOID
// MmGetMdlStartVa (
//     _In_ PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlBaseVa returns the virtual address of the buffer
//     described by the Mdl rounded down to the nearest page.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the returns the starting virtual address of the MDL.
//
//
//--

#define MmGetMdlBaseVa(Mdl)  ((Mdl)->StartVa)

typedef enum _MM_SYSTEM_SIZE {
    MmSmallSystem,
    MmMediumSystem,
    MmLargeSystem
} MM_SYSTEMSIZE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize (
    VOID
    );
#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
MmIsThisAnNtAsSystem (
    VOID
    );
#endif

NTKERNELAPI
NTSTATUS
MmAdjustWorkingSetSize (
    _In_ SIZE_T WorkingSetMinimum,
    _In_ SIZE_T WorkingSetMaximum,
    _In_ ULONG SystemCache,
    _In_ BOOLEAN IncreaseOkay
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_ (APC_LEVEL) 
NTKERNELAPI
NTSTATUS
MmCreateSection (
    _Outptr_ PVOID *SectionObject,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle,
    _In_opt_ PFILE_OBJECT File
    );
#endif


_Must_inspect_result_ 
_Post_satisfies_ (*CapturedViewSize >= _Old_(*CapturedViewSize))
_IRQL_requires_max_ (APC_LEVEL) 
NTKERNELAPI
NTSTATUS
MmMapViewOfSection (
    _In_ PVOID SectionToMap,
    _In_ PEPROCESS Process,
    _Inout_ _At_(*CapturedBase,
                   _Pre_readable_byte_size_(*CapturedViewSize)
                   _Post_readable_byte_size_(*CapturedViewSize))
         PVOID *CapturedBase,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T CapturedViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
    );

_IRQL_requires_max_ (APC_LEVEL) 
NTKERNELAPI
NTSTATUS
MmUnmapViewOfSection (
    _In_ PEPROCESS Process,
    _In_opt_ PVOID BaseAddress
    );


#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmIsVerifierEnabled (
    _Out_ PULONG VerifierFlags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmAddVerifierThunks (
    _In_reads_bytes_ (ThunkBufferSize) PVOID ThunkBuffer,
    _In_ ULONG ThunkBufferSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmAddVerifierSpecialThunks(
    _In_ ULONG_PTR EntryRoutine,
    _In_reads_bytes_(ThunkBufferSize) PVOID ThunkBuffer,
    _In_ ULONG ThunkBufferSize
    );
#endif


//
// I/O support routines.
//

_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
VOID
MmProbeAndLockSelectedPages (
    _Inout_ PMDL MemoryDescriptorList,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ LOCK_OPERATION Operation
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
VOID
MmProbeAndLockProcessPages (
    _Inout_ PMDL MemoryDescriptorList,
    _In_ PEPROCESS Process,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ LOCK_OPERATION Operation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
_At_(MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset, 
    _Field_size_bytes_opt_(MemoryDescriptorList->ByteCount)) // Esp:823  Esp:829
NTKERNELAPI
VOID
MmProbeAndLockPages (
    _Inout_ PMDL MemoryDescriptorList,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ LOCK_OPERATION Operation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmUnlockPages (
    _Inout_ PMDL MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmBuildMdlForNonPagedPool (
    _Inout_ PMDL MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)

typedef struct _MM_PHYSICAL_ADDRESS_LIST {
    PHYSICAL_ADDRESS PhysicalAddress;
    SIZE_T NumberOfBytes;
} MM_PHYSICAL_ADDRESS_LIST, *PMM_PHYSICAL_ADDRESS_LIST;

_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
MmAllocateMdlForIoSpace (
    _In_reads_ (NumberOfEntries) PMM_PHYSICAL_ADDRESS_LIST PhysicalAddressList,
    _In_ SIZE_T NumberOfEntries,
    _Out_ PMDL *NewMdl
    );

_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
LOGICAL
MmAreMdlPagesCached (
     _In_ PMDL MemoryDescriptorList
     );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
__drv_preferredFunction("MmMapLockedPagesSpecifyCache",
    "Obsolete except on Windows 98.  Use MmGetSystemAddressForMdlSafe if this "
	"is a call to MmGetSystemAddressForMdl.") 
_When_(AccessMode==0, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(AccessMode==1, _Maybe_raises_SEH_exception_ _IRQL_requires_max_(APC_LEVEL)) 
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
PVOID
MmMapLockedPages (
    _Inout_ PMDL MemoryDescriptorList,
    _In_ __drv_strictType(KPROCESSOR_MODE/enum _MODE,__drv_typeConst) 
    KPROCESSOR_MODE AccessMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
LOGICAL
MmIsIoSpaceActive (
    _In_ PHYSICAL_ADDRESS StartAddress,
    _In_ SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PVOID
NTAPI
MmGetSystemRoutineAddress (
    _In_ PUNICODE_STRING SystemRoutineName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
MmAdvanceMdl (
    _Inout_ PMDL Mdl,
    _In_ ULONG NumberOfBytes
    );
#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmMapUserAddressesToPage (
    _In_reads_bytes_(NumberOfBytes) PVOID BaseAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ PVOID PageAddress
    );
#endif

// end_ntddk
// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WINXP)
_Must_inspect_result_ 
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
MmProtectMdlSystemAddress (
    _In_ PMDL MemoryDescriptorList,
    _In_ ULONG NewProtect
    );
#endif

//
// _MM_PAGE_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPagePriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//

// begin_ntndis
// begin_wudfpwdm

typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;

// end_wudfpwdm

#define MdlMappingNoWrite       0x80000000  // Create the mapping as nowrite
#define MdlMappingNoExecute     0x40000000  // Create the mapping as noexecute

// end_ntndis

//
// Note: This function is not available in WDM 1.0
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Post_writable_byte_size_(MemoryDescriptorList->ByteCount)
_When_(AccessMode==KernelMode, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(AccessMode==UserMode, _Maybe_raises_SEH_exception_ _IRQL_requires_max_(APC_LEVEL) _Post_notnull_)
_At_(MemoryDescriptorList->MappedSystemVa, 
    _Post_writable_byte_size_(MemoryDescriptorList->ByteCount)) // Esp:829
_Must_inspect_result_ 
_Success_(return != NULL)
NTKERNELAPI
PVOID
MmMapLockedPagesSpecifyCache (
    _Inout_ PMDL MemoryDescriptorList,
    _In_ __drv_strictType(KPROCESSOR_MODE/enum _MODE,__drv_typeConst) 
            KPROCESSOR_MODE AccessMode,
    _In_ __drv_strictTypeMatch(__drv_typeCond) MEMORY_CACHING_TYPE CacheType,
    _In_opt_ PVOID RequestedAddress,
    _In_     ULONG BugCheckOnFailure,
    _In_     ULONG Priority  // MM_PAGE_PRIORITY logically OR'd with MdlMapping*
    );

#if !POOL_NX_OPTOUT && (POOL_NX_OPTIN || POOL_NX_OPTIN_AUTO)

//
// If NX Pool Opt-In is enabled, then MmMapLockedPagesSpecifyCache calls are
// remapped to go through the following forceinline.
//
// N.B.  Should NX Pool Opt-In be enabled, ExInitializeDriverRuntime(...) *MUST*
//       be invoked before any calls to MmMapLockedPagesSpecifyCache in order
//       for Opt-In to be correctly applied.
//

FORCEINLINE
_Post_writable_byte_size_(MemoryDescriptorList->ByteCount)
_When_(AccessMode==KernelMode, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(AccessMode==UserMode, _Maybe_raises_SEH_exception_ _IRQL_requires_max_(APC_LEVEL) _Post_notnull_)
_At_(MemoryDescriptorList->MappedSystemVa, 
    _Post_writable_byte_size_(MemoryDescriptorList->ByteCount)) // Esp:829
_Must_inspect_result_ 
_Success_(return != NULL)
PVOID
MmMapLockedPagesSpecifyCache_NXOptIn (
    _Inout_ PMDL MemoryDescriptorList,
    _In_ __drv_strictType(KPROCESSOR_MODE/enum _MODE,__drv_typeConst) 
            KPROCESSOR_MODE AccessMode,
    _In_ __drv_strictTypeMatch(__drv_typeCond) MEMORY_CACHING_TYPE CacheType,
    _In_opt_ PVOID RequestedAddress,
    _In_     ULONG BugCheckOnFailure,
    _In_     ULONG Priority  // MM_PAGE_PRIORITY logically OR'd with MdlMapping*
    )
{
    return MmMapLockedPagesSpecifyCache (MemoryDescriptorList,
                                         AccessMode,
                                         CacheType,
                                         RequestedAddress,
                                         BugCheckOnFailure,
#if POOL_NX_OPTIN_AUTO
                                         Priority | MdlMappingNoExecute
#else
                                         Priority | ExDefaultMdlProtection
#endif
                                         );
}

#define MmMapLockedPagesSpecifyCache MmMapLockedPagesSpecifyCache_NXOptIn

#endif // !POOL_NX_OPTOUT && (POOL_NX_OPTIN || POOL_NX_OPTIN_AUTO)

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmUnmapLockedPages (
    _In_ PVOID BaseAddress,
    _Inout_ PMDL MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Must_inspect_result_ 
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
_When_ (return != NULL, _Out_writes_bytes_opt_ (NumberOfBytes)) PVOID
MmAllocateMappingAddress (
     _In_ SIZE_T NumberOfBytes,
     _In_ ULONG PoolTag
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
MmFreeMappingAddress (
     _In_ PVOID BaseAddress,
     _In_ ULONG PoolTag
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Post_writable_byte_size_(MemoryDescriptorList->ByteCount)
_IRQL_requires_max_(DISPATCH_LEVEL)
_At_(
    MemoryDescriptorList->MappedSystemVa + MemoryDescriptorList->ByteOffset,  // Esp:823
    _Post_writable_byte_size_(MemoryDescriptorList->ByteCount))  // Esp:829
_Must_inspect_result_ 
_Success_(return != NULL)
NTKERNELAPI
PVOID
MmMapLockedPagesWithReservedMapping (
    _In_    PVOID MappingAddress,
    _In_    ULONG PoolTag,
    _Inout_ PMDL MemoryDescriptorList,
    _In_    __drv_strictTypeMatch(__drv_typeCond) MEMORY_CACHING_TYPE CacheType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmUnmapReservedMapping (
     _In_ PVOID BaseAddress,
     _In_ ULONG PoolTag,
     _Inout_ PMDL MemoryDescriptorList
     );
#endif

// end_wdm
// begin_ntddk

typedef struct _PHYSICAL_MEMORY_RANGE {
    PHYSICAL_ADDRESS BaseAddress;
    LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
MmAddPhysicalMemory (
    _In_ PPHYSICAL_ADDRESS StartAddress,
    _Inout_ PLARGE_INTEGER NumberOfBytes
    );
#endif

typedef NTSTATUS (*PMM_ROTATE_COPY_CALLBACK_FUNCTION) (
    _In_ PMDL DestinationMdl,
    _In_ PMDL SourceMdl,
    _In_ PVOID Context
    );

typedef enum _MM_ROTATE_DIRECTION {
    MmToFrameBuffer,
    MmToFrameBufferNoCopy,
    MmToRegularMemory,
    MmToRegularMemoryNoCopy,
    MmMaximumRotateDirection
} MM_ROTATE_DIRECTION, *PMM_ROTATE_DIRECTION;

#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_ 
_IRQL_requires_max_ (APC_LEVEL)
NTSTATUS
MmRotatePhysicalView (
    _In_ PVOID VirtualAddress,
    _Inout_ PSIZE_T NumberOfBytes,
    _In_opt_ PMDL NewMdl,
    _In_ MM_ROTATE_DIRECTION Direction,
    _In_ PMM_ROTATE_COPY_CALLBACK_FUNCTION CopyFunction,
    _In_opt_ PVOID Context
    );
#endif

// end_ntddk

// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
MmRemovePhysicalMemory (
    _In_ PPHYSICAL_ADDRESS StartAddress,
    _Inout_ PLARGE_INTEGER NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (PASSIVE_LEVEL)
NTKERNELAPI
PPHYSICAL_MEMORY_RANGE
MmGetPhysicalMemoryRanges (
    VOID
    );
#endif

// end_ntddk
// begin_nthal

_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
MmMarkPhysicalMemoryAsGood (
    _In_ PPHYSICAL_ADDRESS StartAddress,
    _Inout_ PLARGE_INTEGER NumberOfBytes
    );

_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmMarkPhysicalMemoryAsBad (
    _In_ PPHYSICAL_ADDRESS StartAddress,
    _Inout_ PLARGE_INTEGER NumberOfBytes
    );

// end_nthal

#define MM_DONT_ZERO_ALLOCATION                 0x00000001  // wdm
#define MM_ALLOCATE_FROM_LOCAL_NODE_ONLY        0x00000002  // wdm
#define MM_ALLOCATE_FULLY_REQUIRED              0x00000004  // wdm
#define MM_ALLOCATE_NO_WAIT                     0x00000008  // wdm
#define MM_ALLOCATE_PREFER_CONTIGUOUS           0x00000010  // wdm
#define MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS   0x00000020  // wdm
#define MM_ALLOCATE_FAST_LARGE_PAGES            0x00000040  // wdm
#define MM_ALLOCATE_TRIM_IF_NECESSARY           0x00000080  // wdm
#define MM_ALLOCATE_AND_HOT_REMOVE              0x00000100  // wdm
#define MM_ALLOCATE_SECURE_PAGES                0x00000200

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN8)
_Must_inspect_result_ 
_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
PMDL
MmAllocateNodePagesForMdlEx (
    _In_ PHYSICAL_ADDRESS LowAddress,
    _In_ PHYSICAL_ADDRESS HighAddress,
    _In_ PHYSICAL_ADDRESS SkipBytes,
    _In_ SIZE_T TotalBytes,
    _In_ MEMORY_CACHING_TYPE CacheType,
    _In_ ULONG IdealNode,
    _In_ ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_Must_inspect_result_ 
_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
PMDL
MmAllocatePagesForMdlEx (
    _In_ PHYSICAL_ADDRESS LowAddress,
    _In_ PHYSICAL_ADDRESS HighAddress,
    _In_ PHYSICAL_ADDRESS SkipBytes,
    _In_ SIZE_T TotalBytes,
    _In_ MEMORY_CACHING_TYPE CacheType,
    _In_ ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PMDL
MmAllocatePagesForMdl (
    _In_ PHYSICAL_ADDRESS LowAddress,
    _In_ PHYSICAL_ADDRESS HighAddress,
    _In_ PHYSICAL_ADDRESS SkipBytes,
    _In_ SIZE_T TotalBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmFreePagesFromMdl (
    _Inout_ PMDL MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
_Out_writes_bytes_opt_ (NumberOfBytes) 
PVOID
MmMapIoSpace (
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ MEMORY_CACHING_TYPE CacheType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmUnmapIoSpace (
    _In_reads_bytes_ (NumberOfBytes) PVOID BaseAddress,
    _In_ SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_Must_inspect_result_
_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
_Out_writes_bytes_opt_ (NumberOfBytes)
PVOID
MmMapIoSpaceEx (
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Protect
    );
#endif

// end_wdm 
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
_Out_writes_bytes_opt_ (NumberOfBytes) PVOID
MmMapVideoDisplay (
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ MEMORY_CACHING_TYPE CacheType
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
VOID
MmUnmapVideoDisplay (
     _In_reads_bytes_ (NumberOfBytes) PVOID BaseAddress,
     _In_ SIZE_T NumberOfBytes
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    _In_ PVOID BaseAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
MmGetCacheAttribute (
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _Out_ MEMORY_CACHING_TYPE *CacheType
    );

typedef struct _MM_COPY_ADDRESS {
    union {
        PVOID VirtualAddress;
        PHYSICAL_ADDRESS PhysicalAddress;
    };
} MM_COPY_ADDRESS, *PMMCOPY_ADDRESS;

#define MM_COPY_MEMORY_PHYSICAL             0x1
#define MM_COPY_MEMORY_VIRTUAL              0x2

_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmCopyMemory (
    _In_ PVOID TargetAddress,
    _In_ MM_COPY_ADDRESS SourceAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ ULONG Flags,
    _Out_ PSIZE_T NumberOfBytesTransferred
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
MmGetVirtualForPhysical (
    _In_ PHYSICAL_ADDRESS PhysicalAddress
    );
#endif

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
_When_ (return != NULL, _Post_writable_byte_size_ (NumberOfBytes)) PVOID
MmAllocateContiguousMemory (
    _In_ SIZE_T NumberOfBytes,
    _In_ PHYSICAL_ADDRESS HighestAcceptableAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
_When_ (return != NULL, _Post_writable_byte_size_ (NumberOfBytes)) PVOID
MmAllocateContiguousMemorySpecifyCache (
    _In_ SIZE_T NumberOfBytes,
    _In_ PHYSICAL_ADDRESS LowestAcceptableAddress,
    _In_ PHYSICAL_ADDRESS HighestAcceptableAddress,
    _In_opt_ PHYSICAL_ADDRESS BoundaryAddressMultiple,
    _In_ MEMORY_CACHING_TYPE CacheType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

// begin_ntminiport

typedef ULONG NODE_REQUIREMENT;

#define MM_ANY_NODE_OK          0x80000000

// end_ntminiport

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_ 
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
_When_ (return != NULL, _Post_writable_byte_size_ (NumberOfBytes)) PVOID
MmAllocateContiguousMemorySpecifyCacheNode (
    _In_ SIZE_T NumberOfBytes,
    _In_ PHYSICAL_ADDRESS LowestAcceptableAddress,
    _In_ PHYSICAL_ADDRESS HighestAcceptableAddress,
    _In_opt_ PHYSICAL_ADDRESS BoundaryAddressMultiple,
    _In_ MEMORY_CACHING_TYPE CacheType,
    _In_ NODE_REQUIREMENT PreferredNode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_Must_inspect_result_ 
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
_When_ (return != NULL, _Post_writable_byte_size_ (NumberOfBytes)) PVOID
MmAllocateContiguousNodeMemory (
    _In_ SIZE_T NumberOfBytes,
    _In_ PHYSICAL_ADDRESS LowestAcceptableAddress,
    _In_ PHYSICAL_ADDRESS HighestAcceptableAddress,
    _In_opt_ PHYSICAL_ADDRESS BoundaryAddressMultiple,
    _In_ ULONG Protect,
    _In_ NODE_REQUIREMENT PreferredNode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmFreeContiguousMemory (
    _In_ PVOID BaseAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmFreeContiguousMemorySpecifyCache (
    _In_reads_bytes_ (NumberOfBytes) PVOID BaseAddress,
    _In_ SIZE_T NumberOfBytes,
    _In_ MEMORY_CACHING_TYPE CacheType
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
_Out_writes_bytes_opt_ (NumberOfBytes) PVOID
MmAllocateNonCachedMemory (
    _In_ SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
MmFreeNonCachedMemory (
    _In_reads_bytes_ (NumberOfBytes) PVOID BaseAddress,
    _In_ SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
MmIsAddressValid (
    _In_ PVOID VirtualAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
__drv_preferredFunction("(see documentation)", "Obsolete")
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
BOOLEAN
MmIsNonPagedSystemAddressValid (
    _In_ PVOID VirtualAddress
    );
#endif

// end_ntddk
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
SIZE_T
MmSizeOfMdl (
    _In_reads_bytes_opt_ (Length) PVOID Base,
    _In_ SIZE_T Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoAllocateMdl
__drv_preferredFunction("IoAllocateMdl","Obsolete")
NTKERNELAPI
PMDL
MmCreateMdl (
    _Out_writes_bytes_opt_ (sizeof (MDL) + (sizeof (PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES (Base, Length))) PMDL MemoryDescriptorList,
    _In_reads_bytes_opt_ (Length) PVOID Base,
    _In_ SIZE_T Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)

typedef enum _MM_MDL_PAGE_CONTENTS_STATE {
    MmMdlPageContentsDynamic,
    MmMdlPageContentsInvariant,
    MmMdlPageContentsQuery
} MM_MDL_PAGE_CONTENTS_STATE, PMM_MDL_PAGE_CONTENTS_STATE;

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
MM_MDL_PAGE_CONTENTS_STATE
MmMdlPageContentsState (
    _Inout_ PMDL MemoryDescriptorList,
    _In_ MM_MDL_PAGE_CONTENTS_STATE State
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
MmLockPagableDataSection (
    _In_ PVOID AddressWithinSection
    );
#endif

// end_wdm
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
MmLockPagableSectionByHandle (
    _In_ PVOID ImageSectionHandle
    );
#endif

// end_ntddk
// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
MmResetDriverPaging (
    _In_ PVOID AddressWithinSection
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
MmPageEntireDriver (
    _In_ PVOID AddressWithinSection
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
MmUnlockPagableImageSection (
    _In_ PVOID ImageSectionHandle
    );
#endif


#if (NTDDI_VERSION >= NTDDI_THRESHOLD)
typedef struct _ESILO *PESILO;

//
// Server Silo function to get Server Silo associated with Session
//

NTKERNELAPI
BOOLEAN
MmIsSessionInCurrentServerSilo(
	_In_ ULONG SessionId
	);
#endif

//
// Note that even though this function prototype
// says "HANDLE", MmSecureVirtualMemory does NOT return
// anything resembling a Win32-style handle.  The return
// value from this function can ONLY be used with MmUnsecureVirtualMemory.
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_(APC_LEVEL) 
__drv_reportError("Caution: MmSecureVirtualMemory ensures the specified VA "
	"range protections cannot be tightened - but accesses to the memory can "
	"still fail and so they must be protected by try-except.")
NTKERNELAPI
HANDLE
MmSecureVirtualMemory (
    __in_data_source(USER_MODE) _In_reads_bytes_ (Size) PVOID Address,
    _In_  __in_data_source(USER_MODE) SIZE_T Size,
    _In_ ULONG ProbeMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
MmUnsecureVirtualMemory (
    _In_ HANDLE SecureHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)

#define MM_SYSTEM_VIEW_EXCEPTIONS_FOR_INPAGE_ERRORS 0x1

_Must_inspect_result_
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpaceEx (
    _In_ PVOID Section,
    _Outptr_result_bytebuffer_ (*ViewSize) PVOID *MappedBase,
    _Inout_ PSIZE_T ViewSize,
    _Inout_ PLARGE_INTEGER SectionOffset,
    _In_ ULONG_PTR Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpace (
    _In_ PVOID Section,
    _Outptr_result_bytebuffer_ (*ViewSize) PVOID *MappedBase,
    _Inout_ PSIZE_T ViewSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmUnmapViewInSystemSpace (
    _In_ PVOID MappedBase
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_Must_inspect_result_
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmMapViewInSessionSpaceEx (
    _In_ PVOID Section,
    _Outptr_result_bytebuffer_ (*ViewSize) PVOID *MappedBase,
    _Inout_ PSIZE_T ViewSize,
    _Inout_ PLARGE_INTEGER SectionOffset,
    _In_ ULONG_PTR Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_ 
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmMapViewInSessionSpace (
    _In_ PVOID Section,
    _Outptr_result_bytebuffer_ (*ViewSize) PVOID *MappedBase,
    _Inout_ PSIZE_T ViewSize
    );
#endif

// end_ntddk
// begin_nthal
_Must_inspect_result_ 
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmCommitSessionMappedView (
    _In_reads_bytes_ (ViewSize) PVOID MappedAddress,
    _In_ SIZE_T ViewSize
    );

// end_nthal
// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmUnmapViewInSessionSpace (
    _In_ PVOID MappedBase
    );
#endif


_IRQL_requires_max_(DISPATCH_LEVEL)
FORCEINLINE
VOID
MmInitializeMdl (
    _Out_writes_bytes_(sizeof(MDL)+(sizeof(PFN_NUMBER)*ADDRESS_AND_SIZE_TO_SPAN_PAGES(BaseVa,Length)))
             PMDL MemoryDescriptorList,
    _In_opt_ PVOID BaseVa,
    _In_     SIZE_T Length
    )
//++
//
// Routine Description:
//
//     This routine initializes the header of a Memory Descriptor List (MDL).
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to initialize.
//
//     BaseVa - Base virtual address mapped by the MDL.
//
//     Length - Length, in bytes, of the buffer mapped by the MDL.
//
// Return Value:
//
//     None.
//
//--
{
    MemoryDescriptorList->Next = (PMDL) NULL;
    MemoryDescriptorList->Size = (CSHORT)(sizeof(MDL) +
            (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(BaseVa, Length)));
    MemoryDescriptorList->MdlFlags = 0;
    MemoryDescriptorList->StartVa = (PVOID) PAGE_ALIGN(BaseVa);
    MemoryDescriptorList->ByteOffset = BYTE_OFFSET(BaseVa);
    MemoryDescriptorList->ByteCount = (ULONG)Length;
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
_Post_writable_byte_size_(Mdl->ByteCount)
_At_(Mdl->MappedSystemVa, 
    _Post_writable_byte_size_(Mdl->ByteCount)) // Esp:829
_Check_return_ 
_Success_(return != NULL)
FORCEINLINE
PVOID
MmGetSystemAddressForMdlSafe (
    _Inout_ PMDL Mdl,
    _In_    ULONG Priority  // MM_PAGE_PRIORITY logically OR'd with MdlMapping*
    )
//++
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL. If the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
//     Priority - Supplies an indication as to how important it is that this
//                request succeed under low available PTE conditions.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//     Unlike MmGetSystemAddressForMdl, Safe guarantees that it will always
//     return NULL on failure instead of bugchecking the system.
//
//     This routine is not usable by WDM 1.0 drivers as 1.0 did not include
//     MmMapLockedPagesSpecifyCache.  The solution for WDM 1.0 drivers is to
//     provide synchronization and set/reset the MDL_MAPPING_CAN_FAIL bit.
//
//--
{
    if (Mdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL)) {
        return Mdl->MappedSystemVa;
    } else {
        return MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmCached,   
                                            NULL, FALSE, Priority);
    }
}
#endif

//++
//
// PVOID
// MmGetSystemAddressForMdl (
//     _In_ PMDL MDL
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL, if the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//--

//#define MmGetSystemAddressForMdl(MDL)
//     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA)) ?
//                             ((MDL)->MappedSystemVa) :
//                ((((MDL)->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL)) ?
//                      ((PVOID)((ULONG)(MDL)->StartVa | (MDL)->ByteOffset)) :
//                            (MmMapLockedPages((MDL),KernelMode)))))

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(MmGetSystemAddressForMdl)    // Use MmGetSystemAddressForMdlSafe
#endif

#define MmGetSystemAddressForMdl(MDL)                                  \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPages((MDL),KernelMode)))

_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
FORCEINLINE
MmPrepareMdlForReuse (
    _Inout_ PMDL MDL
    )
//++
//
// Routine Description:
//
//     This routine will take all of the steps necessary to allow an MDL to be
//     re-used.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL that will be re-used.
//
// Return Value:
//
//     None.
//
//--
{
    if ((MDL->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) {
        NT_ASSERT((MDL->MdlFlags & MDL_PARTIAL) != 0);
        MmUnmapLockedPages( MDL->MappedSystemVa, MDL );
    } else if ((MDL->MdlFlags & MDL_PARTIAL) == 0) {
        NT_ASSERT((MDL->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0);
    }
}

typedef NTSTATUS (*PMM_DLL_INITIALIZE) (
    _In_ PUNICODE_STRING RegistryPath
    );

typedef NTSTATUS (*PMM_DLL_UNLOAD) (
    VOID
    );



//
// Define an empty typedef for the _DRIVER_OBJECT structure so it may be
// referenced by function types before it is actually defined.
//
struct _DRIVER_OBJECT;

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
LOGICAL
MmIsDriverSuspectForVerifier (
    _In_ struct _DRIVER_OBJECT *DriverObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LOGICAL
MmIsDriverVerifying (
    _In_ struct _DRIVER_OBJECT *DriverObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
LOGICAL
MmIsDriverVerifyingByAddress (
    _In_ PVOID AddressWithinSection
    );
#endif


NTKERNELAPI
VOID
MmMapMemoryDumpMdl (
    _Inout_ PMDL MemoryDumpMdl
    );


// begin_ntminiport

//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    _In_ ULONG ReadBank,
    _In_ ULONG WriteBank,
    _In_ PVOID Context
    );

// end_ntminiport

#if defined(_X86_) || defined(_AMD64_)
_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmSetBankedSection (
    _In_ HANDLE ProcessHandle,
    _In_reads_bytes_ (BankLength) PVOID VirtualAddress,
    _In_ ULONG BankLength,
    _In_ BOOLEAN ReadWriteBank,
    _In_ PBANKED_SECTION_ROUTINE BankRoutine,
    _In_ PVOID Context
    );
#endif

_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmCopyVirtualMemory (
    _In_ PEPROCESS FromProcess,
    _In_ CONST VOID *FromAddress,
    _In_ PEPROCESS ToProcess,
    _Out_opt_ PVOID ToAddress,
    _In_ SIZE_T BufferSize,
    _In_ KPROCESSOR_MODE PreviousMode,
    _Out_ PSIZE_T NumberOfBytesCopied
    );

#if (NTDDI_VERSION >= NTDDI_WIN8)

//
// Prefetch virtual addresses public interface.
//

typedef struct _PREFETCH_VIRTUAL_ADDRESS_ENTRY {

    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;

} PREFETCH_VIRTUAL_ADDRESS_ENTRY, *PPREFETCH_VIRTUAL_ADDRESS_ENTRY;

typedef enum _PREFETCH_VIRTUAL_ADDRESS_PRIORITY_TYPE {
    PrefetchPagePriorityDefault,
    PrefetchPagePriorityLow,
    PrefetchPagePriorityUseThreadDefault,
    PrefetchPagePriorityReserved
} PREFETCH_VIRTUAL_ADDRESS_PRIORITY_TYPE, *PPREFETCH_VIRTUAL_ADDRESS_PRIORITY_TYPE;

typedef union _PREFETCH_VIRTUAL_ADDRESS_FLAGS {
    struct {
        ULONG ConsumeOnlySamePriorityOrLowerPages : 1;
        ULONG PagePriority : 2;     // PREFETCH_VIRTUAL_ADDRESS_PRIORITY_TYPE
        ULONG MustBeZero : 29;
    } Flags;
    ULONG AllFlags;
} PREFETCH_VIRTUAL_ADDRESS_FLAGS, *PPREFETCH_VIRTUAL_ADDRESS_FLAGS;

typedef struct _PREFETCH_VIRTUAL_ADDRESS_LIST {

    //
    // Must be PREFETCH_VIRTUAL_ADDRESS_LIST_VERSION_1.
    //

    ULONG Version;

    //
    // As defined above ...
    //

    PREFETCH_VIRTUAL_ADDRESS_FLAGS u1;

    //
    // The address space handle - used to distinguish what types of addresses
    // are being requested.
    //

    HANDLE AddressSpaceHandle;

    //
    // NumberOfEntries - Supplies the number of entries
    // in the VirtualAddresses array.
    //

    ULONG_PTR NumberOfEntries;

    //
    // VirtualAddresses supplies an array of virtual addresses and lengths.
    // THIS LIST MUST BE NONPAGED SINCE IT IS REFERENCED BY THE FAULT CODE.
    //

    PPREFETCH_VIRTUAL_ADDRESS_ENTRY VirtualAddresses;        // NumberOfEntries entries here

} PREFETCH_VIRTUAL_ADDRESS_LIST, *PPREFETCH_VIRTUAL_ADDRESS_LIST;

#define PREFETCH_VIRTUAL_ADDRESS_LIST_VERSION_1     0x1

_IRQL_requires_max_ (APC_LEVEL)
NTKERNELAPI
NTSTATUS
MmPrefetchVirtualAddresses (
    _In_ PPREFETCH_VIRTUAL_ADDRESS_LIST ParameterBlock
    );

#endif


//
// Define OEM bitmapped font check values.
//

#define OEM_FONT_VERSION 0x200
#define OEM_FONT_TYPE 0
#define OEM_FONT_ITALIC 0
#define OEM_FONT_UNDERLINE 0
#define OEM_FONT_STRIKEOUT 0
#define OEM_FONT_CHARACTER_SET 255
#define OEM_FONT_FAMILY (3 << 4)

//
// Define OEM bitmapped font file header structure.
//
// N.B. this is a packed structure.
//

#include "pshpack1.h"
typedef struct _OEM_FONT_FILE_HEADER {
    USHORT Version;
    ULONG FileSize;
    UCHAR Copyright[60];
    USHORT Type;
    USHORT Points;
    USHORT VerticleResolution;
    USHORT HorizontalResolution;
    USHORT Ascent;
    USHORT InternalLeading;
    USHORT ExternalLeading;
    UCHAR Italic;
    UCHAR Underline;
    UCHAR StrikeOut;
    USHORT Weight;
    UCHAR CharacterSet;
    USHORT PixelWidth;
    USHORT PixelHeight;
    UCHAR Family;
    USHORT AverageWidth;
    USHORT MaximumWidth;
    UCHAR FirstCharacter;
    UCHAR LastCharacter;
    UCHAR DefaultCharacter;
    UCHAR BreakCharacter;
    USHORT WidthInBytes;
    ULONG Device;
    ULONG Face;
    ULONG BitsPointer;
    ULONG BitsOffset;
    UCHAR Filler;
    struct {
        USHORT Width;
        USHORT Offset;
    } Map[1];
} OEM_FONT_FILE_HEADER, *POEM_FONT_FILE_HEADER;
#include "poppack.h"


//
// Define the device description structure.
//

typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Dma64BitAddresses;
    ULONG BusNumber; // unused for WDM
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
#if (NTDDI_VERSION >= NTDDI_WIN8)
    ULONG DmaAddressWidth;
    ULONG DmaControllerInstance;
    ULONG DmaRequestLine;
    PHYSICAL_ADDRESS DeviceAddress;
#endif /* NTDDI_VERSION >= NTDDI_WIN8 */
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

// end_wdm
// begin_nthal

#define HalDmaIsBusMasterDescriptorCompatible(DeviceDescriptor, sg, ic, w) \
        ((DeviceDescriptor->Master != FALSE) && \
         (DeviceDescriptor->ScatterGather == sg) && \
         (DeviceDescriptor->IgnoreCount == ic) &&   \
         (DeviceDescriptor->DmaAddressWidth == w))

// end_nthal
// begin_wdm

//
// Define the supported version numbers for the device description structure.
//

#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1
#define DEVICE_DESCRIPTION_VERSION2 2
#define DEVICE_DESCRIPTION_VERSION3 3

//
// Define the supported version numbers for DMA adapter info and the
// DMA transfer info structure.
//

#define DMA_ADAPTER_INFO_VERSION1   1
#define DMA_TRANSFER_INFO_VERSION1  1

typedef struct _DMA_ADAPTER_INFO_V1 {
    ULONG ReadDmaCounterAvailable;
    ULONG ScatterGatherLimit;
    ULONG DmaAddressWidth;
    ULONG Flags;
    ULONG MinimumTransferUnit;
} DMA_ADAPTER_INFO_V1, *PDMA_ADAPTER_INFO_V1;

typedef struct _DMA_ADAPTER_INFO {
    ULONG Version;
    union {
        DMA_ADAPTER_INFO_V1 V1;
    };
} DMA_ADAPTER_INFO, *PDMA_ADAPTER_INFO;

//
// Define the bits in the adapter info flags.
//

#define ADAPTER_INFO_SYNCHRONOUS_CALLBACK             0x0001

typedef struct _DMA_TRANSFER_INFO_V1 {
    ULONG MapRegisterCount;
    ULONG ScatterGatherElementCount;
    ULONG ScatterGatherListSize;
} DMA_TRANSFER_INFO_V1, *PDMA_TRANSFER_INFO_V1;

typedef struct _DMA_TRANSFER_INFO {
    ULONG Version;
    union {
        DMA_TRANSFER_INFO_V1 V1;
    };
} DMA_TRANSFER_INFO, *PDMA_TRANSFER_INFO;

//
// Define the supported version numbers and the corresponding sizes of opaque
// DMA transfer context structure.
//

#define DMA_TRANSFER_CONTEXT_VERSION1  1

#if defined (_WIN64)

#define DMA_TRANSFER_CONTEXT_SIZE_V1   128

#else

#define DMA_TRANSFER_CONTEXT_SIZE_V1   64

#endif

//
// Define the flags used in AllocateAdapterChannelEx, GetScatterGatherListEx,
// and BuildScatterGatherListEx.
//

#define DMA_SYNCHRONOUS_CALLBACK  0x01

// end_wdm
// begin_nthal

//
// Boot record disk partition table entry structure format.
//

typedef struct _PARTITION_DESCRIPTOR {
    UCHAR ActiveFlag;               // Bootable or not
    UCHAR StartingTrack;            // Not used
    UCHAR StartingCylinderLsb;      // Not used
    UCHAR StartingCylinderMsb;      // Not used
    UCHAR PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    UCHAR EndingTrack;              // Not used
    UCHAR EndingCylinderLsb;        // Not used
    UCHAR EndingCylinderMsb;        // Not used
    UCHAR StartingSectorLsb0;       // Hidden sectors
    UCHAR StartingSectorLsb1;
    UCHAR StartingSectorMsb0;
    UCHAR StartingSectorMsb1;
    UCHAR PartitionLengthLsb0;      // Sectors in this partition
    UCHAR PartitionLengthLsb1;
    UCHAR PartitionLengthMsb0;
    UCHAR PartitionLengthMsb1;
} PARTITION_DESCRIPTOR, *PPARTITION_DESCRIPTOR;

//
// Number of partition table entries
//

#define NUM_PARTITION_TABLE_ENTRIES     4

//
// Partition table record and boot signature offsets in 16-bit words.
//

#define PARTITION_TABLE_OFFSET         (0x1be / 2)
#define BOOT_SIGNATURE_OFFSET          ((0x200 / 2) - 1)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

//
// Initial size of the Partition list structure.
//

#define PARTITION_BUFFER_SIZE          2048

//
// Partition active flag - i.e., boot indicator
//

#define PARTITION_ACTIVE_FLAG          0x80

//
// Get and set environment variable values.
//

NTHALAPI
ARC_STATUS
HalGetEnvironmentVariable (
    _In_ PSTR Variable,
    _In_ USHORT Length,
    _Out_writes_bytes_(Length) PCHAR Buffer
    );

NTHALAPI
ARC_STATUS
HalSetEnvironmentVariable (
    _In_ PSTR Variable,
    _In_ PSTR Value
    );

NTHALAPI
NTSTATUS
HalGetEnvironmentVariableEx (
    _In_ PWSTR VariableName,
    _In_ LPCGUID VendorGuid,
    _Out_writes_bytes_(*ValueLength) PVOID Value,
    _Inout_ PULONG ValueLength,
    _Out_opt_ PULONG Attributes
    );


NTHALAPI
NTSTATUS
HalSetEnvironmentVariableEx (
    _In_ PWSTR VariableName,
    _In_ LPCGUID VendorGuid,
    _In_reads_bytes_(ValueLength) PVOID Value,
    _In_ ULONG ValueLength,
    _In_ ULONG Attributes
    );

NTHALAPI
NTSTATUS
HalEnumerateEnvironmentVariablesEx (
    _In_ ULONG InformationClass,
    _Out_writes_bytes_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
    );

NTHALAPI
NTSTATUS
HalQueryEnvironmentVariableInfoEx (
    _In_ ULONG Attributes,
    _Out_ PULONGLONG MaximumVariableStorageSize,
    _Out_ PULONGLONG RemainingVariableStorageSize,
    _Out_ PULONGLONG MaximumVariableSize
    );

                                                
#if defined(_M_IX86) || defined(_M_AMD64)       
                                                
#define HalGetDmaAlignmentRequirement() 1L      
                                                
#elif defined(_M_ARM) || defined(_M_ARM64)      
                                                
#define HalGetDmaAlignmentRequirement() 1L      
                                                
#endif                                          

#if defined(_ARM_) || defined(_ARM64_)          // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp
NTHALAPI
VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

#endif                                          // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp
// begin_wdm begin_ntndis

NTHALAPI
VOID
KeFlushWriteBuffer (
    VOID
    );

// end_wdm end_ntndis
// begin_nthal

NTHALAPI
BOOLEAN
HalQueryRealTimeClock (
    _Out_ PTIME_FIELDS TimeFields
    );
//
// Firmware interface functions.
//

NTHALAPI
VOID
HalReturnToFirmware (
    _In_ FIRMWARE_REENTRY Routine
    );

//
// System interrupts functions.
//

typedef struct _INTERRUPT_CONNECTION_DATA *PINTERRUPT_CONNECTION_DATA;
typedef struct _INTERRUPT_VECTOR_DATA *PINTERRUPT_VECTOR_DATA;
typedef struct _INTERRUPT_REMAPPING_INFO *PINTERRUPT_REMAPPING_INFO;

NTHALAPI
NTSTATUS
HalEnableInterrupt (
    _In_ PINTERRUPT_CONNECTION_DATA ConnectionData
    );

NTHALAPI
NTSTATUS
HalDisableInterrupt (
    _In_ PINTERRUPT_CONNECTION_DATA ConnectionData
    );

NTHALAPI
KIRQL
HalConvertDeviceIdtToIrql (
    _In_ ULONG IdtEntry
    );

NTHALAPI
NTSTATUS
HalGetVectorInput (
    _In_ ULONG Vector,
    _In_ PGROUP_AFFINITY Affinity,
    _Out_ PULONG Input,
    _Out_ PKINTERRUPT_POLARITY Polarity,
    _Out_ PINTERRUPT_REMAPPING_INFO IntRemapInfo
    );

// begin_ntddk
//
// I/O driver configuration functions.
//
#if !defined(NO_LEGACY_DRIVERS)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
__drv_preferredFunction("(see documentation)", "Obsolete")
NTHALAPI
NTSTATUS
HalAssignSlotResources (
    _In_ PUNICODE_STRING RegistryPath,
    _In_ PUNICODE_STRING DriverClassName OPTIONAL,
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ INTERFACE_TYPE BusType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _Inout_ PCM_RESOURCE_LIST *AllocatedResources
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
_IRQL_requires_max_(PASSIVE_LEVEL)
__drv_preferredFunction(
    "IoReportDetectedDevice and IoReportResourceForDetection", "Obsolete")
NTHALAPI
ULONG
HalGetInterruptVector (
    _In_ INTERFACE_TYPE  InterfaceType,
    _In_ ULONG BusNumber,
    _In_ ULONG BusInterruptLevel,
    _In_ ULONG BusInterruptVector,
    _Out_ PKIRQL Irql,
    _Out_ PKAFFINITY Affinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
_When_(BusDataType!=0,  /* Cmos == 0 */
    __drv_preferredFunction(
    "IRP_MN_QUERY_INTERFACE and IRP_MN_WRITE_CONFIG requests",
    "Obsolete except for BusDataType==Cmos"))
NTHALAPI
ULONG
HalSetBusData (
    _In_ BUS_DATA_TYPE BusDataType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );
#endif

#endif // NO_LEGACY_DRIVERS

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
_When_(BusDataType!=0, /* Cmos == 0 */
    __drv_preferredFunction(
    "IRP_MN_QUERY_INTERFACE and IRP_MN_WRITE_CONFIG requests",
    "Obsolete except for BusDataType==Cmos"))
NTHALAPI
ULONG
HalSetBusDataByOffset (
    _In_ BUS_DATA_TYPE BusDataType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
__drv_preferredFunction("(see documentation)", "Obsolete")
NTHALAPI
BOOLEAN
HalTranslateBusAddress (
    _In_ INTERFACE_TYPE  InterfaceType,
    _In_ ULONG BusNumber,
    _In_ PHYSICAL_ADDRESS BusAddress,
    _Inout_ PULONG AddressSpace,
    _Out_ PPHYSICAL_ADDRESS TranslatedAddress
    );
#endif

//
// Values for AddressSpace parameter of HalTranslateBusAddress
//
//      0x0         - Memory space
//      0x1         - Port space
//      0x2 - 0x1F  - Address spaces specific for Alpha
//                      0x2 - UserMode view of memory space
//                      0x3 - UserMode view of port space
//                      0x4 - Dense memory space
//                      0x5 - reserved
//                      0x6 - UserMode view of dense memory space
//                      0x7 - 0x1F - reserved
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTHALAPI
PVOID
HalAllocateCrashDumpRegisters (
    _In_ PADAPTER_OBJECT AdapterObject,
    _Inout_ PULONG NumberOfMapRegisters
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
// end_nthal
typedef enum _HAL_DMA_CRASH_DUMP_REGISTER_TYPE {
    HalDmaCrashDumpRegisterSet1 = 0,
    HalDmaCrashDumpRegisterSet2,
    HalDmaCrashDumpRegisterSetMax
} HAL_DMA_CRASH_DUMP_REGISTER_TYPE, *PHAL_DMA_CRASH_DUMP_REGISTER_TYPE;
// begin_nthal

NTSTATUS
HalDmaAllocateCrashDumpRegistersEx (
    _In_ PADAPTER_OBJECT Adapter,
    _In_ ULONG NumberOfMapRegisters,
    _In_ HAL_DMA_CRASH_DUMP_REGISTER_TYPE Type,
    _Out_ PVOID *MapRegisterBase,
    _Out_ PULONG MapRegistersAvailable
    );

NTSTATUS
HalDmaFreeCrashDumpRegistersEx (
    _In_ PADAPTER_OBJECT Adapter,
    _In_ HAL_DMA_CRASH_DUMP_REGISTER_TYPE Type
    );
#endif

#if !defined(NO_LEGACY_DRIVERS)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
_When_(BusDataType!=0,
    __drv_preferredFunction(
        "IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG requests",
        "Obsolete except for BusDataType==Cmos"))
NTHALAPI
ULONG
HalGetBusData (
    _In_ BUS_DATA_TYPE BusDataType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );
#endif
#endif // NO_LEGACY_DRIVERS

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
_When_(BusDataType!=0,
    __drv_preferredFunction("IRP_MN_QUERY_INTERFACE",
    "Obsolete except for BusDataType==Cmos"))
NTHALAPI
ULONG
HalGetBusDataByOffset (
    _In_ BUS_DATA_TYPE BusDataType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoGetDmaAdapter
_IRQL_requires_max_(PASSIVE_LEVEL)
__drv_preferredFunction("IoGetDmaAdapter", "Obsolete")
NTHALAPI
PADAPTER_OBJECT
HalGetAdapter (
    _In_ PDEVICE_DESCRIPTION DeviceDescription,
    _Out_ PULONG NumberOfMapRegisters
    );
#endif

// end_ntddk

#if !defined(NO_LEGACY_DRIVERS)
NTHALAPI
NTSTATUS
HalAdjustResourceList (
    _Inout_ PIO_RESOURCE_REQUIREMENTS_LIST *pResourceList
    );
#endif // NO_LEGACY_DRIVERS

// begin_ntddk
//
// System beep functions.
//
#if !defined(NO_LEGACY_DRIVERS)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTHALAPI
BOOLEAN
HalMakeBeep(
    _In_ ULONG Frequency
    );
#endif
#endif // NO_LEGACY_DRIVERS

//
// The following function prototypes are for HAL routines with a prefix of Io.
//
// DMA adapter object functions.
//


NTHALAPI
NTSTATUS
HalGetProcessorIdByNtNumber (
    _In_ ULONG Number,
    _Out_ PULONG Id
    );

typedef enum _IPI_TYPE {
    IpiAffinity = 0,
    IpiAllButSelf,
    IpiAll
} IPI_TYPE;

NTSTATUS
HalRequestIpiSpecifyVector (
    _In_ IPI_TYPE IpiType,
    _In_opt_ PKAFFINITY_EX Affinity,
    _In_ ULONG Vector
    );


//
// The following defines and prototypes define the logging interface for the HAL
// to inject events into the NT kernel logger.
//

typedef
VOID
(*PHAL_LOG_ROUTINE) (
    _In_ ULONG EventId,
    _In_ PVOID Buffer,
    _In_ ULONG Size
    );

typedef struct _HAL_LOG_REGISTER_CONTEXT {
    PHAL_LOG_ROUTINE LogRoutine;
    ULONG Flag;
} HAL_LOG_REGISTER_CONTEXT, *PHAL_LOG_REGISTER_CONTEXT;

//
// Performance counter function.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter (
   _Out_opt_ PLARGE_INTEGER PerformanceFrequency
   );
#endif

// begin_ntndis
//
// Stall processor execution function.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTHALAPI
VOID
KeStallExecutionProcessor (
    _In_ ULONG MicroSeconds
    );
#endif

typedef
NTSTATUS
(*PINSTALL_BUS_HANDLER)(
      _In_ PBUS_HANDLER   Bus
      );

typedef
NTSTATUS
(*pHalRegisterBusHandler)(
    _In_ INTERFACE_TYPE          InterfaceType,
    _In_ BUS_DATA_TYPE           AssociatedConfigurationSpace,
    _In_ ULONG                   BusNumber,
    _In_ INTERFACE_TYPE          ParentBusType,
    _In_ ULONG                   ParentBusNumber,
    _In_ ULONG                   SizeofBusExtensionData,
    _In_ PINSTALL_BUS_HANDLER    InstallBusHandlers,
    _Out_ PBUS_HANDLER           *BusHandler
    );

// begin_ntddk
typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForBus) (
    _In_ INTERFACE_TYPE InterfaceType,
    _In_ ULONG          BusNumber
    );
typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForConfigSpace) (
    _In_ BUS_DATA_TYPE  ConfigSpace,
    _In_ ULONG          BusNumber
    );
typedef
VOID
(FASTCALL *pHalReferenceBusHandler) (
    _In_ PBUS_HANDLER   BusHandler
    );
typedef
VOID
(*pHalSetWakeEnable)(
    _In_ BOOLEAN       Enable
    );

typedef
NTSTATUS
(*pHalSetWakeAlarm)(
    _In_opt_ ULONGLONG AcWakeTime,
    _In_opt_ ULONGLONG DcWakeTime
    );

typedef
VOID
(*pHalLocateHiberRanges)(
    _In_ PVOID MemoryMap
    );

//
// HAL state elements.
//
// N.B.  The size of this structure is fixed.  Do not remove.
//

typedef struct _HAL_STATE_ELEMENT {
    _Field_size_bytes_(Size) PVOID Address;
    SIZE_T Size;
} HAL_STATE_ELEMENT, *PHAL_STATE_ELEMENT;

typedef CONST HAL_STATE_ELEMENT *PCHAL_STATE_ELEMENT;

typedef struct _HAL_STATE_ELEMENT_INFORMATION {
    PCHAL_STATE_ELEMENT StateElements;
    SIZE_T StateElementCount;
} HAL_STATE_ELEMENT_INFORMATION, *PHAL_STATE_ELEMENT_INFORMATION;

// end_nthal
// begin_ntddk

//-----------------------------------------------------------------------------
//      HAL Function dispatch
//

typedef enum _HAL_QUERY_INFORMATION_CLASS {
    HalInstalledBusInformation,
    HalProfileSourceInformation,
    HalInformationClassUnused1,
    HalPowerInformation,
    HalProcessorSpeedInformation,
    HalCallbackInformation,
    HalMapRegisterInformation,
    HalMcaLogInformation,               // Machine Check Abort Information
    HalFrameBufferCachingInformation,
    HalDisplayBiosInformation,
    HalProcessorFeatureInformation,
    HalNumaTopologyInterface,
    HalErrorInformation,                // General MCA, CMC, CPE Error Information.
    HalCmcLogInformation,               // Processor Corrected Machine Check Information
    HalCpeLogInformation,               // Corrected Platform Error Information
    HalQueryMcaInterface,
    HalQueryAMLIIllegalIOPortAddresses,
    HalQueryMaxHotPlugMemoryAddress,
    HalPartitionIpiInterface,
    HalPlatformInformation,
    HalQueryProfileSourceList,
    HalInitLogInformation,
    HalFrequencyInformation,
    HalProcessorBrandString,
    HalHypervisorInformation,
    HalPlatformTimerInformation,
    HalAcpiAuditInformation,
    HalIrtInformation,
    HalSecondaryInterruptInformation,
    HalParkingPageInformation,
    HalNumaRangeTableInformation,
    HalChannelTopologyInformation,
    HalExternalCacheInformation,
    HalQueryDebuggerInformation,
    HalFwBootPerformanceInformation,
    HalFwS3PerformanceInformation,
    HalGetChannelPowerInformation,
    HalQueryStateElementInformation,
    HalPsciInformation,
    HalInterruptControllerInformation,
    HalQueryIommuReservedRegionInformation,
    HalQueryArmErrataInformation,
    HalQueryProcessorEfficiencyInformation,
    // information levels >= 0x8000000 reserved for OEM use
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


typedef enum _HAL_SET_INFORMATION_CLASS {
    HalProfileSourceInterval,
    HalProfileSourceInterruptHandler,  // Register performance monitor interrupt callback
    HalMcaRegisterDriver,              // Register Machine Check Abort driver
    HalKernelErrorHandler,
    HalCmcRegisterDriver,              // Register Processor Corrected Machine Check driver
    HalCpeRegisterDriver,              // Register Corrected Platform  Error driver
    HalMcaLog,
    HalCmcLog,
    HalCpeLog,
    HalGenerateCmcInterrupt,           // Used to test CMC
    HalProfileSourceTimerHandler,      // Resister profile timer interrupt callback
    HalEnlightenment,
    HalProfileDpgoSourceInterruptHandler,  // Register performance monitor interrupt callback for dpgo
    HalRegisterSecondaryInterruptInterface,
    HalSetChannelPowerInformation,
    HalI386ExceptionChainTerminatorInformation, // Set x86 SEHOP exception chain terminator
//    HalRegisterPlatformServicesInterface,
} HAL_SET_INFORMATION_CLASS, *PHAL_SET_INFORMATION_CLASS;

// begin_nthal

// end_ntddk

typedef struct _HAL_SET_I386_EXCEPTION_CHAIN_TERMINATOR_INFORMATION {
    PVOID ExceptionChainTerminator;
} HAL_SET_I386_EXCEPTION_CHAIN_TERMINATOR_INFORMATION, *PHAL_SET_I386_EXCEPTION_CHAIN_TERMINATOR_INFORMATION;

// begin_ntddk

typedef
NTSTATUS
(*pHalQuerySystemInformation)(
    _In_ HAL_QUERY_INFORMATION_CLASS  InformationClass,
    _In_ ULONG     BufferSize,
    _Out_writes_bytes_to_(BufferSize, *ReturnedLength) PVOID Buffer,
    _Out_ PULONG   ReturnedLength
    );

// end_ntddk
NTSTATUS
HaliQuerySystemInformation (
    _In_ HAL_QUERY_INFORMATION_CLASS InformationClass,
    _In_ ULONG BufferSize,
    _Out_writes_bytes_to_(BufferSize, *ReturnedLength) PVOID Buffer,
    _Out_ PULONG ReturnedLength
    );

//begin_ntddk

typedef
NTSTATUS
(*pHalSetSystemInformation)(
    _In_ HAL_SET_INFORMATION_CLASS    InformationClass,
    _In_ ULONG     BufferSize,
    _In_ PVOID     Buffer
    );

// end_ntddk
NTSTATUS
HaliSetSystemInformation (
    _In_ HAL_SET_INFORMATION_CLASS InformationClass,
    _In_ ULONG BufferSize,
    _In_reads_bytes_(BufferSize) PVOID Buffer
    );
// begin_ntddk

typedef
VOID
(FASTCALL *pHalExamineMBR)(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG SectorSize,
    _In_ ULONG MBRTypeIdentifier,
    _Out_ PVOID *Buffer
    );

typedef
NTSTATUS
(FASTCALL *pHalIoReadPartitionTable)(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG SectorSize,
    _In_ BOOLEAN ReturnRecognizedPartitions,
    _Out_ struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

typedef
NTSTATUS
(FASTCALL *pHalIoSetPartitionInformation)(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG SectorSize,
    _In_ ULONG PartitionNumber,
    _In_ ULONG PartitionType
    );

typedef
NTSTATUS
(FASTCALL *pHalIoWritePartitionTable)(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG SectorSize,
    _In_ ULONG SectorsPerTrack,
    _In_ ULONG NumberOfHeads,
    _In_ struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

typedef
NTSTATUS
(*pHalQueryBusSlots)(
    _In_ PBUS_HANDLER         BusHandler,
    _In_ ULONG                BufferSize,
    _Out_ PULONG              SlotNumbers,
    _Out_ PULONG              ReturnedLength
    );

typedef
NTSTATUS
(*pHalInitPnpDriver)(
    VOID
    );

// end_ntddk
NTSTATUS
HaliInitPnpDriver (
    VOID
    );

// end_nthal
// begin_ntddk

typedef struct _PM_DISPATCH_TABLE {
    ULONG   Signature;
    ULONG   Version;
    PVOID   Function[1];
} PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;

// begin_nthal

typedef
NTSTATUS
(*pHalInitPowerManagement)(
    _In_ PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    _Out_ PPM_DISPATCH_TABLE *PmHalDispatchTable
    );

// end_ntddk
NTSTATUS
HaliInitPowerManagement (
    _In_ PPM_DISPATCH_TABLE PmDriverDispatchTable,
    _Inout_ PPM_DISPATCH_TABLE *PmHalDispatchTable
    );
// begin_ntddk

typedef
struct _DMA_ADAPTER *
(*pHalGetDmaAdapter)(
    _In_opt_ PVOID PhysicalDeviceObject,
    _In_ struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    _Out_ PULONG NumberOfMapRegisters
    );

// end_ntddk
struct _DMA_ADAPTER *
HaliGetDmaAdapter (
    _In_opt_ PVOID PhysicalDeviceObject,
    _In_ struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    _Out_ PULONG NumberOfMapRegisters
    );
// begin_ntddk

typedef
NTSTATUS
(*pHalGetInterruptTranslator)(
    _In_ INTERFACE_TYPE ParentInterfaceType,
    _In_ ULONG ParentBusNumber,
    _In_ INTERFACE_TYPE BridgeInterfaceType,
    _In_ USHORT Size,
    _In_ USHORT Version,
    _Out_ PTRANSLATOR_INTERFACE Translator,
    _Out_ PULONG BridgeBusNumber
    );

// end_ntddk
NTSTATUS
HaliGetInterruptTranslator (
    _In_ INTERFACE_TYPE ParentInterfaceType,
    _In_ ULONG ParentBusNumber,
    _In_ INTERFACE_TYPE BridgeInterfaceType,
    _In_ USHORT Size,
    _In_ USHORT Version,
    _Out_ PTRANSLATOR_INTERFACE Translator,
    _Out_ PULONG BridgeBusNumber
    );
// begin_ntddk

typedef
BOOLEAN
(*pHalTranslateBusAddress)(
    _In_ INTERFACE_TYPE  InterfaceType,
    _In_ ULONG BusNumber,
    _In_ PHYSICAL_ADDRESS BusAddress,
    _Inout_ PULONG AddressSpace,
    _Out_ PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef
NTSTATUS
(*pHalAssignSlotResources) (
    _In_ PUNICODE_STRING RegistryPath,
    _In_ PUNICODE_STRING DriverClassName OPTIONAL,
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ INTERFACE_TYPE BusType,
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _Inout_ PCM_RESOURCE_LIST *AllocatedResources
    );

typedef
VOID
(*pHalHaltSystem) (
    VOID
    );

typedef
BOOLEAN
(*pHalResetDisplay) (
    VOID
    );

// end_nthal
// begin_ntndis
typedef struct _MAP_REGISTER_ENTRY {
    PVOID   MapRegister;
    BOOLEAN WriteToDevice;
} MAP_REGISTER_ENTRY, *PMAP_REGISTER_ENTRY;
// end_ntndis
// begin_nthal

// end_ntddk
typedef
NTSTATUS
(*pHalAllocateMapRegisters)(
    _In_ struct _ADAPTER_OBJECT *DmaAdapter,
    _In_ ULONG NumberOfMapRegisters,
    _In_ ULONG BaseAddressCount,
    _Out_ PMAP_REGISTER_ENTRY MapRegsiterArray
    );

NTSTATUS
HalAllocateMapRegisters(
    _In_ struct _ADAPTER_OBJECT *DmaAdapter,
    _In_ ULONG NumberOfMapRegisters,
    _In_ ULONG BaseAddressCount,
    _Out_ PMAP_REGISTER_ENTRY MapRegsiterArray
    );
// begin_ntddk

typedef
UCHAR
(*pHalVectorToIDTEntry) (
    ULONG Vector
);

typedef
BOOLEAN
(*pHalFindBusAddressTranslation) (
    _In_ PHYSICAL_ADDRESS BusAddress,
    _Inout_ PULONG AddressSpace,
    _Out_ PPHYSICAL_ADDRESS TranslatedAddress,
    _Inout_ PULONG_PTR Context,
    _In_ BOOLEAN NextBus
    );

typedef
NTSTATUS
(*pHalStartMirroring)(
    VOID
    );

typedef
NTSTATUS
(*pHalEndMirroring)(
    _In_ ULONG PassNumber
    );

typedef
NTSTATUS
(*pHalMirrorPhysicalMemory)(
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ LARGE_INTEGER NumberOfBytes
    );

typedef
NTSTATUS
(*pHalMirrorVerify)(
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ LARGE_INTEGER NumberOfBytes
    );

// end_nthal

// begin_ntoshvp

typedef struct {
    UCHAR     Type;  //CmResourceType
    BOOLEAN   Valid;
    UCHAR     Reserved[2];
    PUCHAR    TranslatedAddress;
    ULONG     Length;
} DEBUG_DEVICE_ADDRESS, *PDEBUG_DEVICE_ADDRESS;

typedef struct {
    PHYSICAL_ADDRESS  Start;
    PHYSICAL_ADDRESS  MaxEnd;
    PVOID             VirtualAddress;
    ULONG             Length;
    BOOLEAN           Cached;
    BOOLEAN           Aligned;
} DEBUG_MEMORY_REQUIREMENTS, *PDEBUG_MEMORY_REQUIREMENTS;

typedef enum {
    KdNameSpacePCI,
    KdNameSpaceACPI,
    KdNameSpaceAny,
    KdNameSpaceNone,

    //
    // Maxmimum namespace enumerator.
    //

    KdNameSpaceMax,
} KD_NAMESPACE_ENUM, *PKD_NAMESPACE_ENUM;

typedef enum {
    KdConfigureDeviceAndContinue,
    KdSkipDeviceAndContinue,
    KdConfigureDeviceAndStop,
    KdSkipDeviceAndStop,
} KD_CALLBACK_ACTION, *PKD_CALLBACK_ACTION;

//
// Debug transport specific data for use by the transport.
//

typedef struct _DEBUG_TRANSPORT_DATA {
    ULONG HwContextSize;
    BOOLEAN UseSerialFraming;
} DEBUG_TRANSPORT_DATA, *PDEBUG_TRANSPORT_DATA;

#define MAXIMUM_DEBUG_BARS 6

#define DBG_DEVICE_FLAG_HAL_SCRATCH_ALLOCATED 0x01
#define DBG_DEVICE_FLAG_BARS_MAPPED           0x02
#define DBG_DEVICE_FLAG_SCRATCH_ALLOCATED     0x04

typedef struct _DEBUG_DEVICE_DESCRIPTOR {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    Segment;
    USHORT    VendorID;
    USHORT    DeviceID;
    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    union {
        UCHAR     Flags;
        struct {
            UCHAR DbgHalScratchAllocated : 1;
            UCHAR DbgBarsMapped : 1;
            UCHAR DbgScratchAllocated : 1;
        };
    };
    BOOLEAN   Initialized;
    BOOLEAN   Configured;
    DEBUG_DEVICE_ADDRESS BaseAddress[MAXIMUM_DEBUG_BARS];
    DEBUG_MEMORY_REQUIREMENTS Memory;
    USHORT    PortType;
    USHORT    PortSubtype;
    PVOID     OemData;
    ULONG     OemDataLength;
    KD_NAMESPACE_ENUM NameSpace;
    PWCHAR    NameSpacePath;
    ULONG     NameSpacePathLength;
    ULONG     TransportType;
    DEBUG_TRANSPORT_DATA TransportData;
} DEBUG_DEVICE_DESCRIPTOR, *PDEBUG_DEVICE_DESCRIPTOR;

// end_ntoshvp

typedef struct _PCI_DEBUGGING_DEVICE_IN_USE {
    USHORT Segment;
    ULONG Bus;
    ULONG Slot;
} PCI_DEBUGGING_DEVICE_IN_USE, *PPCI_DEBUGGING_DEVICE_IN_USE;

typedef struct _ACPI_DEBUGGING_DEVICE_IN_USE {
    ULONG NameSpacePathLength;
    WCHAR NameSpacePath[ANYSIZE_ARRAY];
} ACPI_DEBUGGING_DEVICE_IN_USE, *PACPI_DEBUGGING_DEVICE_IN_USE;

typedef struct _DEBUGGING_DEVICE_IN_USE {
    KD_NAMESPACE_ENUM NameSpace;
    ULONG StructureLength;
    union {
        ACPI_DEBUGGING_DEVICE_IN_USE AcpiDevice;
        PCI_DEBUGGING_DEVICE_IN_USE PciDevice;
    };
} DEBUGGING_DEVICE_IN_USE, *PDEBUGGING_DEVICE_IN_USE;

typedef struct _DEBUGGING_DEVICE_IN_USE_INFORMATION {
    ULONG DeviceCount;
    DEBUGGING_DEVICE_IN_USE Device[ANYSIZE_ARRAY];
} DEBUGGING_DEVICE_IN_USE_INFORMATION, *PDEBUGGING_DEVICE_IN_USE_INFORMATION;

// begin_nthal

typedef
KD_CALLBACK_ACTION
(*PDEBUG_DEVICE_FOUND_FUNCTION) (
    PDEBUG_DEVICE_DESCRIPTOR Device
    );

typedef
NTSTATUS
(*pKdEnumerateDebuggingDevices) (
    _In_ PVOID LoaderBlock,
    _Inout_ PDEBUG_DEVICE_DESCRIPTOR Device,
    _In_ PDEBUG_DEVICE_FOUND_FUNCTION Callback
    );

typedef
NTSTATUS
(*pKdSetupPciDeviceForDebugging)(
    _In_    PVOID                     LoaderBlock,   OPTIONAL
    _Inout_ PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
NTSTATUS
(*pKdReleasePciDeviceForDebugging)(
    _Inout_ PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
NTSTATUS
(*pKdSetupIntegratedDeviceForDebugging)(
    _In_    PVOID                     LoaderBlock,   OPTIONAL
    _Inout_ PDEBUG_DEVICE_DESCRIPTOR  IntegratedDevice
);

typedef
NTSTATUS
(*pKdReleaseIntegratedDeviceForDebugging)(
    _Inout_ PDEBUG_DEVICE_DESCRIPTOR  IntegratedDevice
);

typedef
PVOID
(*pKdGetAcpiTablePhase0)(
    _In_ struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    _In_ ULONG Signature
    );

typedef
VOID
(*pKdCheckPowerButton)(
    VOID
    );

typedef
VOID
(*pHalEndOfBoot)(
    VOID
    );

typedef
PVOID
(*pKdMapPhysicalMemory64)(
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ ULONG NumberPages,
    _In_ BOOLEAN FlushCurrentTLB
    );

typedef
VOID
(*pKdUnmapVirtualAddress)(
    _In_ PVOID VirtualAddress,
    _In_ ULONG NumberPages,
    _In_ BOOLEAN FlushCurrentTLB
    );

typedef
ULONG
(*pKdGetPciDataByOffset)(
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );

typedef
ULONG
(*pKdSetPciDataByOffset)(
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );

typedef
PVOID
(*pHalGetAcpiTable)(
    _In_ ULONG Signature,
    _In_opt_ PCSTR OemId,
    _In_opt_ PCSTR OemTableId
    );

typedef
VOID
(*PCI_ERROR_HANDLER_CALLBACK)(
    VOID
    );

typedef
VOID
(*pHalSetPciErrorHandlerCallback)(
    _In_ PCI_ERROR_HANDLER_CALLBACK Callback
    );

// end_ntddk

typedef
ULONG
(*pHalGetInterruptVector)(
    _In_ INTERFACE_TYPE InterfaceType,
    _In_ ULONG BusNumber,
    _In_ ULONG BusInterruptLevel,
    _In_ ULONG BusInterruptVector,
    _Out_ PKIRQL Irql,
    _Out_ PKAFFINITY Affinity
    );

typedef
NTSTATUS
(*pHalGetVectorInput)(
    _In_ ULONG Vector,
    _In_ PGROUP_AFFINITY Affinity,
    _Out_ PULONG Input,
    _Out_ PKINTERRUPT_POLARITY Polarity,
    _Out_ PINTERRUPT_REMAPPING_INFO IntRemapInfo
    );

typedef
NTSTATUS
(*pHalLoadMicrocode)(
    _In_ PVOID ImageHandle
    );

typedef
NTSTATUS
(*pHalUnloadMicrocode)(
    VOID
    );

typedef
NTSTATUS
(*pHalPostMicrocodeUpdate)(
    VOID
    );

typedef
NTSTATUS
(*pHalAllocateMessageTarget)(
    _In_ PDEVICE_OBJECT Owner,
    _In_ PGROUP_AFFINITY ProcessorSet,
    _In_ ULONG NumberOfIdtEntries,
    _In_ KINTERRUPT_MODE Mode,
    _In_ BOOLEAN ShareVector,
    _Out_ PULONG Vector,
    _Out_ PKIRQL Irql,
    _Out_ PULONG IdtEntry
    );

typedef
VOID
(*pHalFreeMessageTarget)(
    _In_ PDEVICE_OBJECT Owner,
    _In_ ULONG Vector,
    _In_ PGROUP_AFFINITY ProcessorSet
    );

//
// Dynamic partitioning hot-replace HAL interface function.
//

#define HAL_DP_REPLACE_PHASE_QUIESCE    0
#define HAL_DP_REPLACE_PHASE_SWAP       1
#define HAL_DP_REPLACE_PHASE_WAKE       2
#define HAL_DP_REPLACE_PHASE_CANCEL     3

typedef struct _PNP_REPLACE_PROCESSOR_LIST *PPNP_REPLACE_PROCESSOR_LIST;

#define HAL_DP_REPLACE_PROCESSOR_ID_RECONFIGURE     0x01
#define HAL_DP_REPLACE_HARDWARE_QUIESCE             0x02

typedef struct _HAL_DP_REPLACE_PARAMETERS {
    ULONG Flags;
    PPNP_REPLACE_PROCESSOR_LIST TargetProcessors;
    PPNP_REPLACE_PROCESSOR_LIST SpareProcessors;
} HAL_DP_REPLACE_PARAMETERS, *PHAL_DP_REPLACE_PARAMETERS;

typedef
NTSTATUS
(*pHalDpReplaceBegin)(
    _In_ PHAL_DP_REPLACE_PARAMETERS Parameters,
    _Outptr_ PVOID *ReplaceContext
    );

typedef
VOID
(*pHalDpReplaceTarget)(
    _In_ PVOID ReplaceContext
    );

typedef
NTSTATUS
(*pHalDpReplaceControl)(
    _In_ ULONG Phase,
    _In_ PVOID ReplaceContext
    );

typedef
VOID
(*pHalDpReplaceEnd)(
    _In_ PVOID ReplaceContext
    );

typedef
NTSTATUS
(*pHalDpMaskLevelTriggeredInterrupts)(
    VOID
    );

typedef
NTSTATUS
(*pHalDpUnmaskLevelTriggeredInterrupts)(
    VOID
    );

typedef
NTSTATUS
(*pHalDpGetInterruptReplayState)(
    _In_ PVOID ReplaceContext,
    _Outptr_ PVOID *Buffer
    );

typedef
NTSTATUS
(*pHalDpReplayInterrupts)(
    _In_ PVOID InterruptState
    );

#define HAL_PREPARE_NMI_IN_PROGRESS     0x00000001UL

typedef
VOID
(*pHalPrepareForBugcheck)(
    _In_ ULONG Flags
    );

typedef
BOOLEAN
(*pHalQueryWakeTime)(
    _Out_ PULONGLONG WakeTime,
    _Out_opt_ PULONGLONG TscOffset
    );

typedef
BOOLEAN
(*pHalQueryIoPortAccessSupported)(
    VOID
    );

typedef
VOID
(*pHalReportIdleStateUsage)(
    _In_ UCHAR DeepestHardwareIdleState,
    _In_ PKAFFINITY_EX TargetSet
    );

typedef
VOID
(*pHalTscSynchronization)(
    _In_ BOOLEAN ForcedSynchronization,
    _In_opt_ PULONG TargetProcessor
    );

typedef struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR
    *PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR;

typedef struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION
    *PWHEA_PROCESSOR_GENERIC_ERROR_SECTION;

typedef
NTSTATUS
(*pHalWheaInitProcessorGenericSection)(
    _Out_ PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR Descriptor,
    _Out_ PWHEA_PROCESSOR_GENERIC_ERROR_SECTION Section
    );

typedef
VOID
(*pHalStopLegacyUsbInterrupts)(
    _In_ SYSTEM_POWER_STATE LastSystemState
    );

typedef
NTSTATUS
(*pHalReadWheaPhysicalMemory)(
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ ULONG Length,
    _Out_writes_bytes_(Length) PVOID Data
    );

typedef
NTSTATUS
(*pHalWriteWheaPhysicalMemory)(
    _In_ PHYSICAL_ADDRESS PhysicalAddress,
    _In_ ULONG Length,
    _In_reads_bytes_(Length) PVOID Data
    );


#if !defined(_ARM64_) && !defined(_ARM_)

#define _HAL_ENLIGHTENMENT_INFORMATION _HAL_INTEL_ENLIGHTENMENT_INFORMATION
#define  HAL_ENLIGHTENMENT_INFORMATION  HAL_INTEL_ENLIGHTENMENT_INFORMATION
#define PHAL_ENLIGHTENMENT_INFORMATION PHAL_INTEL_ENLIGHTENMENT_INFORMATION

#else

#define _HAL_ENLIGHTENMENT_INFORMATION _HAL_ARM_ENLIGHTENMENT_INFORMATION
#define  HAL_ENLIGHTENMENT_INFORMATION  HAL_ARM_ENLIGHTENMENT_INFORMATION
#define PHAL_ENLIGHTENMENT_INFORMATION PHAL_ARM_ENLIGHTENMENT_INFORMATION

#endif

typedef struct _HAL_ENLIGHTENMENT_INFORMATION
    HAL_ENLIGHTENMENT_INFORMATION, *PHAL_ENLIGHTENMENT_INFORMATION;

typedef
VOID
(*pHalGetEnlightenmentInformation)(
    PHAL_ENLIGHTENMENT_INFORMATION EnlightenmentInformation
    );

typedef
PVOID
(*pHalAllocateEarlyPages)(
    _In_ PLOADER_PARAMETER_BLOCK LoaderBlock,
    _In_ ULONG PageCount,
    _Out_ PULONG64 PhysicalAddress,
    _In_ ULONG Protection
    );

typedef
PVOID
(*pHalMapEarlyPages)(
    _In_ ULONG64 PhysicalAddress,
    _In_ ULONG PageCount,
    _In_ ULONG Protection
    );

//
// Flags to prepare processor for idle.
//

#define HAL_PREPARE_FOR_IDLE_INTERRUPTIBLE   (1 << 0)

typedef
NTSTATUS
(*pHalPrepareProcessorForIdle) (
    _In_ ULONG Flags
    );

typedef
VOID
(*pHalResumeProcessorFromIdle) (
   VOID
   );

typedef
VOID
(*pHalNotifyProcessorFreeze) (
    _In_ BOOLEAN Freezing,
    _In_ BOOLEAN ThawingToSpinLoop
    );

typedef
VOID
(*pHalRegisterLogRoutine) (
    _In_ PHAL_LOG_REGISTER_CONTEXT Context
    );

//
// Modes of clock timer operation.
//

typedef enum _HAL_CLOCK_TIMER_MODE {
    HalClockTimerModePeriodic,
    HalClockTimerModeOneShot,
    HalClockTimerModeMax
} HAL_CLOCK_TIMER_MODE, *PHAL_CLOCK_TIMER_MODE;

//
// Clock timer configuration.
//

typedef struct _HAL_CLOCK_TIMER_CONFIGURATION {
    union {
        BOOLEAN Flags;
        struct {
            BOOLEAN AlwaysOnTimer: 1;
            BOOLEAN HighLatency: 1;
            BOOLEAN PerCpuTimer: 1;
            BOOLEAN DynamicTickSupported: 1;
        };
    };

    ULONG KnownType;
    ULONG Capabilities;
    ULONG64 MaxIncrement;
    ULONG MinIncrement;
} HAL_CLOCK_TIMER_CONFIGURATION, *PHAL_CLOCK_TIMER_CONFIGURATION;

typedef
VOID
(*pHalGetClockConfiguration) (
    _Out_ PHAL_CLOCK_TIMER_CONFIGURATION Configuration
    );

typedef
VOID
(*pHalClockTimerActivate) (
    _In_ BOOLEAN ClockOwner
    );

typedef
VOID
(*pHalClockTimerInitialize) (
    VOID
    );

typedef
VOID
 (*pHalClockTimerStop) (
    VOID
    );

typedef
NTSTATUS
(*pHalClockTimerArm) (
    _In_ HAL_CLOCK_TIMER_MODE Mode,
    _In_ ULONG64 RequestedInteval,
    _Out_ PULONG64 ActualInterval
    );

typedef
BOOLEAN
(*pHalTimerOnlyClockInterruptPending) (
    VOID
    );

typedef struct _HAL_IOMMU_DISPATCH HAL_IOMMU_DISPATCH, *PHAL_IOMMU_DISPATCH;

typedef
VOID
(*pHalIommuRegisterDispatchTable) (
    _Inout_ PHAL_IOMMU_DISPATCH DispatchTable
    );

//
// Secondary interrupt services related routines.
//

//
// The difference between pHalVectorToIDTEntry and pHalVectorToIDTEntryEx is
// the return type. The old routine assumes that IDT entries can only range from
// 0 - 0xFF. The new routine supports IDT ranges beyond (0x0 - 0xFF). This is
// possible for entries within the secondary IDT, the range for which starts
// after the primary IDT range.
//

typedef
ULONG
(*pHalVectorToIDTEntryEx) (
    ULONG Vector
);

typedef
NTSTATUS
(*pHalSecondaryInterruptQueryPrimaryInformation) (
    _In_ PINTERRUPT_VECTOR_DATA VectorData,
    _Out_ PULONG PrimaryGsiv
    );

typedef
BOOLEAN
(*pHalIsInterruptTypeSecondary) (
    _In_ ULONG Type,                        // INTERRUPT_CONNECTION_TYPE
    _In_ ULONG InputGsiv
    );

// begin_wdm

#define HAL_MASK_UNMASK_FLAGS_NONE (0x0)
#define HAL_MASK_UNMASK_FLAGS_SERVICING_DEFERRED (0x1)
#define HAL_MASK_UNMASK_FLAGS_SERVICING_COMPLETE (0x2)

// end_wdm

typedef
NTSTATUS
(*pHalMaskInterrupt) (
    _In_ ULONG InputGsiv,
    _In_ ULONG Flags
    );

typedef
NTSTATUS
(*pHalUnmaskInterrupt) (
    _In_ ULONG InputGsiv,
    _In_ ULONG Flags
    );

typedef
NTSTATUS
(*pHalAllocateGsivForSecondaryInterrupt) (
    _In_reads_bytes_(OwnerNameLength) PCCHAR OwnerName,
    _In_ USHORT OwnerNameLength,
    _Out_ PULONG Gsiv
    );

typedef
NTSTATUS
(*pHalInterruptVectorDataToGsiv) (
    _In_ PINTERRUPT_VECTOR_DATA VectorData,
    _Out_ PULONG Gsiv
    );

typedef
NTSTATUS
(*pHalAddInterruptRemapping) (
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _In_ PPCI_BUSMASTER_DESCRIPTOR BusMasterDescriptor,
    _In_range_(0, 3) UCHAR PhantomBits,
    _Inout_updates_(VectorCount) PINTERRUPT_VECTOR_DATA VectorData,
    ULONG VectorCount
    );

typedef
VOID
(*pHalRemoveInterruptRemapping) (
    _In_ ULONG BusNumber,
    _In_ ULONG SlotNumber,
    _In_ PPCI_BUSMASTER_DESCRIPTOR BusMasterDescriptor,
    _In_range_(0, 3) UCHAR PhantomBits,
    _Inout_updates_(VectorCount) PINTERRUPT_VECTOR_DATA VectorData,
    ULONG VectorCount
    );

typedef
VOID
(*pHalSaveAndDisableHvEnlightenment) (
    VOID
    );

typedef
VOID
(*pHalRestoreHvEnlightenment) (
    VOID
    );

//
// Flush external cache if present
//

typedef
VOID
(*pHalFlushIoBuffersExternalCache) (
    IN PMDL  Mdl,
    IN BOOLEAN  ReadOperation
    );

typedef
VOID
(*pHalFlushIoRectangleExternalCache) (
    IN PMDL Mdl,
    IN ULONG StartOffset,
    IN ULONG Width,
    IN ULONG Height,
    IN ULONG Stride,
    IN BOOLEAN ReadOperation
    );

typedef
VOID
(*pHalFlushExternalCache) (
    IN BOOLEAN Invalidate
    );

typedef
VOID
(*pHalFlushAndInvalidatePageExternalCache) (
    IN PHYSICAL_ADDRESS PhysicalAddress
    );

typedef
NTSTATUS
(*pHalPciEarlyRestore) (
    _In_ SYSTEM_POWER_STATE SleepState
    );

typedef
VOID
(*pHalPciLateRestore) (
    VOID
    );

typedef
NTSTATUS
(*pHalGetProcessorId) (
    _In_ ULONG ProcessorIndex,
    _Out_ ULONG *Identifier
    );

//
// Pmc counter profiling interfaces
//

typedef struct _HAL_PMC_COUNTERS *PMC_HANDLE;

typedef
NTSTATUS
(*pHalAllocatePmcCounterSet) (
    _In_ ULONG ProcessorIndex,
    _In_reads_(SourceCount) KPROFILE_SOURCE *SourceList,
    _In_ ULONG SourceCount,
    _Out_ PMC_HANDLE *Handle
    );

typedef
VOID
(*pHalFreePmcCounterSet) (
    _In_ PMC_HANDLE Handle
    );

typedef
VOID
(*pHalCollectPmcCounters) (
    _In_ PMC_HANDLE Handle,
    _Out_ PULONG64 Data
    );

typedef
ULONGLONG
(*pHalTimerQueryCycleCounter) (
    _Out_opt_ PULONGLONG CycleCounterFrequency
    );

// begin_wdm

//
// Processor driver halt routine.
//

typedef
NTSTATUS
PROCESSOR_HALT_ROUTINE (
    _Inout_opt_ PVOID Context
    );

typedef PROCESSOR_HALT_ROUTINE *PPROCESSOR_HALT_ROUTINE;

// end_wdm

typedef
NTSTATUS
(*pHalProcessorHalt) (
    _In_ ULONG Flags,
    _Inout_opt_ PVOID Context,
    _In_ PPROCESSOR_HALT_ROUTINE Halt
    );

typedef
VOID
(*pHalPciMarkHiberPhase) (
    VOID
    );

typedef
NTSTATUS
(*pHalQueryProcessorRestartEntryPoint) (
    _Out_ PPHYSICAL_ADDRESS EntryPoint
    );

typedef
NTSTATUS
(*pHalRequestInterrupt) (
    _In_ ULONG Gsiv
    );

typedef
VOID
(*pHalPowerEarlyRestore) (
    ULONG Phase
    );

typedef
NTSTATUS
(*pHalUpdateCapsule) (
    _In_ PVOID CapsuleHeaderArray,
    _In_ ULONG CapsuleCount,
    _In_opt_ PHYSICAL_ADDRESS ScatterGatherList
    );

typedef
NTSTATUS
(*pHalQueryCapsuleCapabilities) (
    _In_ PVOID CapsuleHeaderArray,
    _In_ ULONG CapsuleCount,
    _Out_ PULONGLONG MaximumCapsuleSize,
    _Out_ PULONG ResetType
    );

typedef
BOOLEAN
(*pHalPciMultiStageResumeCapable) (
    VOID
    );

typedef
VOID
(*pHalDmaFreeCrashDumpRegisters) (
    _In_ ULONG Phase
    );

typedef
BOOLEAN
(*pHalAcpiAoacCapable) (
    VOID
    );

typedef
NTSTATUS
(*pHalInterruptSetDestination) (
    __in ULONG Gsiv,
    __in PINTERRUPT_VECTOR_DATA VectorData,
    __in PGROUP_AFFINITY TargetProcessors
    );

//
// N.B. This must match its PO counterpart (PEP_UNMASKED_INTERRUPT_INFORMATION).
//

#define HAL_UNMASKED_INTERRUPT_INFORMATION_V1 0x00000001
#define HAL_UNMASKED_INTERRUPT_INFORMATION_MINIMUM_SIZE \
    RTL_SIZEOF_THROUGH_FIELD(HAL_UNMASKED_INTERRUPT_INFORMATION, DeviceHandle)

typedef union _HAL_UNMASKED_INTERRUPT_FLAGS {
    struct {
        USHORT SecondaryInterrupt: 1;
        USHORT Reserved: 15;
    };

    USHORT AsUSHORT;

} HAL_UNMASKED_INTERRUPT_FLAGS, *PHAL_UNMASKED_INTERRUPT_FLAGS;

typedef struct _HAL_UNMASKED_INTERRUPT_INFORMATION {
    USHORT Version;
    USHORT Size;
    HAL_UNMASKED_INTERRUPT_FLAGS Flags;
    KINTERRUPT_MODE Mode;
    KINTERRUPT_POLARITY Polarity;
    ULONG Gsiv;
    USHORT PinNumber;
    PVOID DeviceHandle;
} HAL_UNMASKED_INTERRUPT_INFORMATION, *PHAL_UNMASKED_INTERRUPT_INFORMATION;

typedef
BOOLEAN
(HAL_ENUMERATE_INTERRUPT_SOURCE_CALLBACK)(
    _In_ PVOID Context,
    _In_ PHAL_UNMASKED_INTERRUPT_INFORMATION InterruptInformation
    );

typedef HAL_ENUMERATE_INTERRUPT_SOURCE_CALLBACK
    *PHAL_ENUMERATE_INTERRUPT_SOURCE_CALLBACK;

typedef
NTSTATUS
(*pHalEnumerateUnmaskedInterrupts) (
    _In_ PHAL_ENUMERATE_INTERRUPT_SOURCE_CALLBACK Callback,
    _In_ PVOID Context,
    _Out_ PHAL_UNMASKED_INTERRUPT_INFORMATION InterruptInformation
    );

typedef
PVOID
(*pHalAcpiGetMultiNode) (
    VOID
    );

typedef
void
(HALREBOOTHANDLER)(
    _In_ ULONG ProcessorNumber,
    _Inout_opt_ volatile LONG* ProcessorsStarted
    );

typedef HALREBOOTHANDLER *PHALREBOOTHANDLER;

typedef
PHALREBOOTHANDLER
(*pHalPowerSetRebootHandler) (
    _In_opt_ PHALREBOOTHANDLER NewHandler
    );

typedef
NTSTATUS
(*pHalTimerWatchdogStart) (
    VOID
    );

typedef
VOID
(*pHalTimerWatchdogResetCountdown) (
    _In_ LOGICAL SetWakeTimer
    );

typedef
NTSTATUS
(*pHalTimerWatchdogStop) (
    VOID
    );

typedef
BOOLEAN
(*pHalTimerWatchdogGeneratedLastReset) (
    VOID
    );

typedef
NTSTATUS
(*pHalTimerWatchdogTriggerSystemReset) (
    BOOLEAN ResetViaClockInterrupt
    );

typedef
NTSTATUS
(*pHalInterruptGetHighestPriorityInterrupt) (
    __out PULONG HighestPendingVector,
    __out PBOOLEAN SingleInterrupt
    );

typedef
NTSTATUS
(*pHalProcessorOn) (
    _In_ ULONG NtNumber
    );

typedef
NTSTATUS
(*pHalProcessorOff) (
    VOID
    );

typedef
NTSTATUS
(*pHalProcessorFreeze) (
    VOID
    );

typedef
NTSTATUS
(*pHalDmaLinkDeviceObjectByToken) (
    _In_ ULONG_PTR Token,
    _In_opt_ PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*pHalDmaCheckAdapterToken) (
    _In_ ULONG_PTR Token
    );

//
// Conversion between auxiliary counter and performance counter.
//

typedef
NTSTATUS
(*pHalTimerConvertAuxiliaryCounterToPerformanceCounter) (
    __in ULONG64 AuxiliaryCounterValue,
    __out PULONG64 PerformanceCounterValueOut,
    __out_opt PULONG64 ConversionErrorOut
    );

typedef
NTSTATUS
(*pHalTimerConvertPerformanceCounterToAuxiliaryCounter) (
    __in ULONG64 PerformanceCounterValue,
    __out PULONG64 AuxiliaryCounterValueOut,
    __out_opt PULONG64 ConversionErrorOut
    );

typedef
NTSTATUS
(*pHalTimerQueryAuxiliaryCounterFrequency) (
    __out PULONG64 AuxiliaryCounterFrequencyOut
    );

typedef
NTSTATUS
(*pHalConnectThermalInterrupt) (
    _In_ PKSERVICE_ROUTINE InterruptService
    );

typedef
BOOLEAN
(*pHalIsEFIRuntimeActive) (
    VOID
    );

// begin_ntddk

// end_nthal

typedef struct {
    ULONG                           Version;
    pHalQuerySystemInformation      HalQuerySystemInformation;
    pHalSetSystemInformation        HalSetSystemInformation;
    pHalQueryBusSlots               HalQueryBusSlots;
    ULONG                           Spare1;
    pHalExamineMBR                  HalExamineMBR;
    pHalIoReadPartitionTable        HalIoReadPartitionTable;
    pHalIoSetPartitionInformation   HalIoSetPartitionInformation;
    pHalIoWritePartitionTable       HalIoWritePartitionTable;

    pHalHandlerForBus               HalReferenceHandlerForBus;
    pHalReferenceBusHandler         HalReferenceBusHandler;
    pHalReferenceBusHandler         HalDereferenceBusHandler;

    pHalInitPnpDriver               HalInitPnpDriver;
    pHalInitPowerManagement         HalInitPowerManagement;

    pHalGetDmaAdapter               HalGetDmaAdapter;
    pHalGetInterruptTranslator      HalGetInterruptTranslator;

    pHalStartMirroring              HalStartMirroring;
    pHalEndMirroring                HalEndMirroring;
    pHalMirrorPhysicalMemory        HalMirrorPhysicalMemory;
    pHalEndOfBoot                   HalEndOfBoot;
    pHalMirrorVerify                HalMirrorVerify;

    pHalGetAcpiTable                HalGetCachedAcpiTable;
    pHalSetPciErrorHandlerCallback  HalSetPciErrorHandlerCallback;

} HAL_DISPATCH, *PHAL_DISPATCH;

// begin_nthal

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_DISPATCH   HalDispatchTable;
#define HALDISPATCH     HalDispatchTable

#else

extern  HAL_DISPATCH    HalDispatchTable;
#define HALDISPATCH     (&HalDispatchTable)

#endif

#define HAL_DISPATCH_VERSION        4

#define HalDispatchTableVersion         HALDISPATCH->Version
#define HalQuerySystemInformation       HALDISPATCH->HalQuerySystemInformation
#define HalSetSystemInformation         HALDISPATCH->HalSetSystemInformation
#define HalQueryBusSlots                HALDISPATCH->HalQueryBusSlots

#define HalReferenceHandlerForBus       HALDISPATCH->HalReferenceHandlerForBus
#define HalReferenceBusHandler          HALDISPATCH->HalReferenceBusHandler
#define HalDereferenceBusHandler        HALDISPATCH->HalDereferenceBusHandler

#define HalInitPnpDriver                HALDISPATCH->HalInitPnpDriver
#define HalInitPowerManagement          HALDISPATCH->HalInitPowerManagement

#define HalGetDmaAdapter                HALDISPATCH->HalGetDmaAdapter
#define HalGetInterruptTranslator       HALDISPATCH->HalGetInterruptTranslator

#define HalStartMirroring               HALDISPATCH->HalStartMirroring
#define HalEndMirroring                 HALDISPATCH->HalEndMirroring
#define HalMirrorPhysicalMemory         HALDISPATCH->HalMirrorPhysicalMemory
#define HalEndOfBoot                    HALDISPATCH->HalEndOfBoot
#define HalMirrorVerify                 HALDISPATCH->HalMirrorVerify

#define HalGetCachedAcpiTable           HALDISPATCH->HalGetCachedAcpiTable
#define HalSetPciErrorHandlerCallback   HALDISPATCH->HalSetPciErrorHandlerCallback

// end_ntddk

//
// The debugger binaries may rely on this interface and are required to
// work downlevel, so changes to this interface need to be
// backward-compatible
//

typedef struct {
    ULONG                                  Version;

    pHalHandlerForBus                      HalHandlerForBus;
    pHalHandlerForConfigSpace              HalHandlerForConfigSpace;
    pHalLocateHiberRanges                  HalLocateHiberRanges;

    pHalRegisterBusHandler                 HalRegisterBusHandler;

    pHalSetWakeEnable                      HalSetWakeEnable;
    pHalSetWakeAlarm                       HalSetWakeAlarm;

    pHalTranslateBusAddress                HalPciTranslateBusAddress;
    pHalAssignSlotResources                HalPciAssignSlotResources;

    pHalHaltSystem                         HalHaltSystem;

    pHalFindBusAddressTranslation          HalFindBusAddressTranslation;

    pHalResetDisplay                       HalResetDisplay;

    pHalAllocateMapRegisters               HalAllocateMapRegisters;

    pKdSetupPciDeviceForDebugging          KdSetupPciDeviceForDebugging;
    pKdReleasePciDeviceForDebugging        KdReleasePciDeviceForDebugging;

    pKdGetAcpiTablePhase0                  KdGetAcpiTablePhase0;
    pKdCheckPowerButton                    KdCheckPowerButton;

    pHalVectorToIDTEntry                   HalVectorToIDTEntry;

    pKdMapPhysicalMemory64                 KdMapPhysicalMemory64;
    pKdUnmapVirtualAddress                 KdUnmapVirtualAddress;

    pKdGetPciDataByOffset                  KdGetPciDataByOffset;
    pKdSetPciDataByOffset                  KdSetPciDataByOffset;

    pHalGetInterruptVector                 HalGetInterruptVectorOverride;
    pHalGetVectorInput                     HalGetVectorInputOverride;

    pHalLoadMicrocode                      HalLoadMicrocode;
    pHalUnloadMicrocode                    HalUnloadMicrocode;
    pHalPostMicrocodeUpdate                HalPostMicrocodeUpdate;

    pHalAllocateMessageTarget              HalAllocateMessageTargetOverride;
    pHalFreeMessageTarget                  HalFreeMessageTargetOverride;

    pHalDpReplaceBegin                     HalDpReplaceBegin;
    pHalDpReplaceTarget                    HalDpReplaceTarget;
    pHalDpReplaceControl                   HalDpReplaceControl;
    pHalDpReplaceEnd                       HalDpReplaceEnd;

    pHalPrepareForBugcheck                 HalPrepareForBugcheck;
    pHalQueryWakeTime                      HalQueryWakeTime;
    pHalReportIdleStateUsage               HalReportIdleStateUsage;
    pHalTscSynchronization                 HalTscSynchronization;

    pHalWheaInitProcessorGenericSection    HalWheaInitProcessorGenericSection;

    pHalStopLegacyUsbInterrupts            HalStopLegacyUsbInterrupts;

    pHalReadWheaPhysicalMemory             HalReadWheaPhysicalMemory;
    pHalWriteWheaPhysicalMemory            HalWriteWheaPhysicalMemory;

    pHalDpMaskLevelTriggeredInterrupts     HalDpMaskLevelTriggeredInterrupts;
    pHalDpUnmaskLevelTriggeredInterrupts   HalDpUnmaskLevelTriggeredInterrupts;
    pHalDpGetInterruptReplayState          HalDpGetInterruptReplayState;
    pHalDpReplayInterrupts                 HalDpReplayInterrupts;
    pHalQueryIoPortAccessSupported         HalQueryIoPortAccessSupported;

    //
    // Start of version 14 functions
    //

    pKdSetupIntegratedDeviceForDebugging   KdSetupIntegratedDeviceForDebugging;
    pKdReleaseIntegratedDeviceForDebugging KdReleaseIntegratedDeviceForDebugging;
    pHalGetEnlightenmentInformation        HalGetEnlightenmentInformation;
    pHalAllocateEarlyPages                 HalAllocateEarlyPages;
    pHalMapEarlyPages                      HalMapEarlyPages;

    PVOID                                  Dummy1;
    PVOID                                  Dummy2;
    pHalNotifyProcessorFreeze              HalNotifyProcessorFreeze;
    pHalPrepareProcessorForIdle            HalPrepareProcessorForIdle;
    pHalRegisterLogRoutine                 HalRegisterLogRoutine;
    pHalResumeProcessorFromIdle            HalResumeProcessorFromIdle;
    PVOID                                  Dummy;

    //
    // Start of version 15 functions
    //

    pHalVectorToIDTEntryEx              HalVectorToIDTEntryEx;
    pHalSecondaryInterruptQueryPrimaryInformation HalSecondaryInterruptQueryPrimaryInformation;
    pHalMaskInterrupt                   HalMaskInterrupt;
    pHalUnmaskInterrupt                 HalUnmaskInterrupt;
    pHalIsInterruptTypeSecondary        HalIsInterruptTypeSecondary;
    pHalAllocateGsivForSecondaryInterrupt   HalAllocateGsivForSecondaryInterrupt;
    pHalAddInterruptRemapping           HalAddInterruptRemapping;
    pHalRemoveInterruptRemapping        HalRemoveInterruptRemapping;
    pHalSaveAndDisableHvEnlightenment   HalSaveAndDisableHvEnlightenment;
    pHalRestoreHvEnlightenment          HalRestoreHvEnlightenment;

    //
    // Start of version 16 functions
    //

    pHalFlushIoBuffersExternalCache     HalFlushIoBuffersExternalCache;
    pHalFlushExternalCache              HalFlushExternalCache;

    //
    // Start of version 17 functions
    //

    pHalPciEarlyRestore                 HalPciEarlyRestore;
    pHalGetProcessorId                  HalGetProcessorId;
    pHalAllocatePmcCounterSet           HalAllocatePmcCounterSet;
    pHalCollectPmcCounters              HalCollectPmcCounters;
    pHalFreePmcCounterSet               HalFreePmcCounterSet;
    pHalProcessorHalt                   HalProcessorHalt;
    pHalTimerQueryCycleCounter          HalTimerQueryCycleCounter;
    PVOID                               Dummy3;
    pHalPciMarkHiberPhase               HalPciMarkHiberPhase;
    pHalQueryProcessorRestartEntryPoint HalQueryProcessorRestartEntryPoint;
    pHalRequestInterrupt                HalRequestInterrupt;
    pHalEnumerateUnmaskedInterrupts     HalEnumerateUnmaskedInterrupts;

    //
    // Start of version 18 functions
    //

    pHalFlushAndInvalidatePageExternalCache HalFlushAndInvalidatePageExternalCache;
    pKdEnumerateDebuggingDevices        KdEnumerateDebuggingDevices;

    //
    // Start of version 19 functions
    //

    pHalFlushIoRectangleExternalCache   HalFlushIoRectangleExternalCache;

    //
    // Start of version 20 functions
    //

    pHalPowerEarlyRestore               HalPowerEarlyRestore;

    //
    // Start of version 21 functions.
    //

    pHalQueryCapsuleCapabilities        HalQueryCapsuleCapabilities;
    pHalUpdateCapsule                   HalUpdateCapsule;
    pHalPciMultiStageResumeCapable      HalPciMultiStageResumeCapable;
    pHalDmaFreeCrashDumpRegisters       HalDmaFreeCrashDumpRegisters;

    pHalAcpiAoacCapable                 HalAcpiAoacCapable;
    pHalInterruptSetDestination         HalInterruptSetDestination;
    pHalGetClockConfiguration           HalGetClockConfiguration;
    pHalClockTimerActivate              HalClockTimerActivate;
    pHalClockTimerInitialize            HalClockTimerInitialize;
    pHalClockTimerStop                  HalClockTimerStop;
    pHalClockTimerArm                   HalClockTimerArm;
    pHalTimerOnlyClockInterruptPending  HalTimerOnlyClockInterruptPending;

    //
    // Start of version 22 functions.
    //

    pHalAcpiGetMultiNode                HalAcpiGetMultiNode;
    pHalPowerSetRebootHandler           HalPowerSetRebootHandler;

    //
    // Start of version 23 functions.
    //

    pHalIommuRegisterDispatchTable      HalIommuRegisterDispatchTable;
    pHalTimerWatchdogStart              HalTimerWatchdogStart;
    pHalTimerWatchdogResetCountdown     HalTimerWatchdogResetCountdown;
    pHalTimerWatchdogStop               HalTimerWatchdogStop;
    pHalTimerWatchdogGeneratedLastReset HalTimerWatchdogGeneratedLastReset;
    pHalTimerWatchdogTriggerSystemReset HalTimerWatchdogTriggerSystemReset;

    //
    // Start of version 24 functions.
    //

    pHalInterruptVectorDataToGsiv       HalInterruptVectorDataToGsiv;

    //
    // Start of version 25 functions.
    //

    pHalInterruptGetHighestPriorityInterrupt    HalInterruptGetHighestPriorityInterrupt;

    //
    // Start of version 26 functions.
    //

    pHalProcessorOn              HalProcessorOn;
    pHalProcessorOff             HalProcessorOff;

    //
    // Start of version 27 functions.
    //

    pHalProcessorFreeze          HalProcessorFreeze;

    //
    // Start of version 28 functions.
    //

    pHalDmaLinkDeviceObjectByToken  HalDmaLinkDeviceObjectByToken;

    //
    // Start of version 29 functions.
    //

    pHalDmaCheckAdapterToken     HalDmaCheckAdapterToken;

    //
    // Start of version 30 functions.
    //

    pHalPciLateRestore           HalPciLateRestore;
    pHalTimerConvertPerformanceCounterToAuxiliaryCounter HalTimerConvertPerformanceCounterToAuxiliaryCounter;
    pHalTimerConvertAuxiliaryCounterToPerformanceCounter HalTimerConvertAuxiliaryCounterToPerformanceCounter;
    pHalTimerQueryAuxiliaryCounterFrequency HalTimerQueryAuxiliaryCounterFrequency;

    //
    // Start of version 31 functions.
    //

    pHalConnectThermalInterrupt     HalConnectThermalInterrupt;

    //
    // Start of version 32 functions.
    //

    pHalIsEFIRuntimeActive      HalIsEFIRuntimeActive;
} HAL_PRIVATE_DISPATCH, *PHAL_PRIVATE_DISPATCH;

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_PRIVATE_DISPATCH           HalPrivateDispatchTable;
#define HALPDISPATCH                    HalPrivateDispatchTable

#else

extern  HAL_PRIVATE_DISPATCH            HalPrivateDispatchTable;
#define HALPDISPATCH                    (&HalPrivateDispatchTable)

#endif

#define HAL_PRIVATE_DISPATCH_VERSION        32

#define HalRegisterBusHandler           HALPDISPATCH->HalRegisterBusHandler
#define HalHandlerForBus                HALPDISPATCH->HalHandlerForBus
#define HalHandlerForConfigSpace        HALPDISPATCH->HalHandlerForConfigSpace
#define HalLocateHiberRanges            HALPDISPATCH->HalLocateHiberRanges
#define HalSetWakeEnable                HALPDISPATCH->HalSetWakeEnable
#define HalSetWakeAlarm                 HALPDISPATCH->HalSetWakeAlarm
#define HalHaltSystem                   HALPDISPATCH->HalHaltSystem
#define HalResetDisplay                 HALPDISPATCH->HalResetDisplay
#define HalAllocateMapRegisters         HALPDISPATCH->HalAllocateMapRegisters
#define KdEnumerateDebuggingDevices     HALPDISPATCH->KdEnumerateDebuggingDevices
#define KdSetupPciDeviceForDebugging    HALPDISPATCH->KdSetupPciDeviceForDebugging
#define KdReleasePciDeviceForDebugging  HALPDISPATCH->KdReleasePciDeviceForDebugging
#define KdSetupIntegratedDeviceForDebugging   HALPDISPATCH->KdSetupIntegratedDeviceForDebugging
#define KdReleaseIntegratedDeviceForDebugging HALPDISPATCH->KdReleaseIntegratedDeviceForDebugging
#define KdGetAcpiTablePhase0                  HALPDISPATCH->KdGetAcpiTablePhase0
#define KdCheckPowerButton                    HALPDISPATCH->KdCheckPowerButton
#define HalVectorToIDTEntry                   HALPDISPATCH->HalVectorToIDTEntry
#define KdMapPhysicalMemory64                 HALPDISPATCH->KdMapPhysicalMemory64
#define KdUnmapVirtualAddress                 HALPDISPATCH->KdUnmapVirtualAddress
#define KdGetPciDataByOffset                  HALPDISPATCH->KdGetPciDataByOffset
#define KdSetPciDataByOffset                  HALPDISPATCH->KdSetPciDataByOffset
#define HalLoadMicrocode                      HALPDISPATCH->HalLoadMicrocode
#define HalUnloadMicrocode                    HALPDISPATCH->HalUnloadMicrocode
#define HalPostMicrocodeUpdate                HALPDISPATCH->HalPostMicrocodeUpdate
#define HalDpReplaceBegin                     HALPDISPATCH->HalDpReplaceBegin
#define HalDpReplaceTarget                    HALPDISPATCH->HalDpReplaceTarget
#define HalDpReplaceControl                   HALPDISPATCH->HalDpReplaceControl
#define HalDpReplaceEnd                       HALPDISPATCH->HalDpReplaceEnd
#define HalPrepareForBugcheck                 HALPDISPATCH->HalPrepareForBugcheck
#define HalQueryWakeTime                      HALPDISPATCH->HalQueryWakeTime
#define HalReportIdleStateUsage               HALPDISPATCH->HalReportIdleStateUsage
#define HalTscSynchronization                 HALPDISPATCH->HalTscSynchronization
#define HalWheaInitProcessorGenericSection    HALPDISPATCH->HalWheaInitProcessorGenericSection
#define HalStopLegacyUsbInterrupts            HALPDISPATCH->HalStopLegacyUsbInterrupts
#define HalReadWheaPhysicalMemory             HALPDISPATCH->HalReadWheaPhysicalMemory
#define HalWriteWheaPhysicalMemory            HALPDISPATCH->HalWriteWheaPhysicalMemory
#define HalDpMaskLevelTriggeredInterrupts     HALPDISPATCH->HalDpMaskLevelTriggeredInterrupts
#define HalDpUnmaskLevelTriggeredInterrupts   HALPDISPATCH->HalDpUnmaskLevelTriggeredInterrupts
#define HalDpGetInterruptReplayState          HALPDISPATCH->HalDpGetInterruptReplayState
#define HalDpReplayInterrupts                 HALPDISPATCH->HalDpReplayInterrupts
#define HalQueryIoPortAccessSupported         HALPDISPATCH->HalQueryIoPortAccessSupported
#define HalGetEnlightenmentInformation        HALPDISPATCH->HalGetEnlightenmentInformation
#define HalAllocateEarlyPages                 HALPDISPATCH->HalAllocateEarlyPages
#define HalMapEarlyPages                      HALPDISPATCH->HalMapEarlyPages
#define HalNotifyProcessorFreeze              HALPDISPATCH->HalNotifyProcessorFreeze
#define HalPrepareProcessorForIdle            HALPDISPATCH->HalPrepareProcessorForIdle
#define HalRegisterLogRoutine                 HALPDISPATCH->HalRegisterLogRoutine
#define HalResumeProcessorFromIdle            HALPDISPATCH->HalResumeProcessorFromIdle
#define HalVectorToIDTEntryEx                 HALPDISPATCH->HalVectorToIDTEntryEx
#define HalSecondaryInterruptQueryPrimaryInformation       HALPDISPATCH->HalSecondaryInterruptQueryPrimaryInformation
#define HalMaskInterrupt                      HALPDISPATCH->HalMaskInterrupt
#define HalUnmaskInterrupt                    HALPDISPATCH->HalUnmaskInterrupt
#define HalIsInterruptTypeSecondary           HALPDISPATCH->HalIsInterruptTypeSecondary
#define HalAllocateGsivForSecondaryInterrupt  HALPDISPATCH->HalAllocateGsivForSecondaryInterrupt
#define HalAddInterruptRemapping              HALPDISPATCH->HalAddInterruptRemapping
#define HalRemoveInterruptRemapping           HALPDISPATCH->HalRemoveInterruptRemapping
#define HalSaveAndDisableHvEnlightenment      HALPDISPATCH->HalSaveAndDisableHvEnlightenment
#define HalRestoreHvEnlightenment             HALPDISPATCH->HalRestoreHvEnlightenment
#define HalFlushIoBuffersExternalCache        HALPDISPATCH->HalFlushIoBuffersExternalCache
#define HalFlushExternalCache                 HALPDISPATCH->HalFlushExternalCache
#define HalPciEarlyRestore                    HALPDISPATCH->HalPciEarlyRestore
#define HalGetProcessorId                     HALPDISPATCH->HalGetProcessorId
#define HalAllocatePmcCounterSet              HALPDISPATCH->HalAllocatePmcCounterSet
#define HalCollectPmcCounters                 HALPDISPATCH->HalCollectPmcCounters
#define HalFreePmcCounterSet                  HALPDISPATCH->HalFreePmcCounterSet
#define HalProcessorHalt                      HALPDISPATCH->HalProcessorHalt
#define HalTimerQueryCycleCounter             HALPDISPATCH->HalTimerQueryCycleCounter
#define HalPciMarkHiberPhase                  HALPDISPATCH->HalPciMarkHiberPhase
#define HalQueryProcessorRestartEntryPoint    HALPDISPATCH->HalQueryProcessorRestartEntryPoint
#define HalRequestInterrupt                   HALPDISPATCH->HalRequestInterrupt
#define HalEnumerateUnmaskedInterrupts        HALPDISPATCH->HalEnumerateUnmaskedInterrupts
#define HalFlushAndInvalidatePageExternalCache HALPDISPATCH->HalFlushAndInvalidatePageExternalCache
#define HalFlushIoRectangleExternalCache      HALPDISPATCH->HalFlushIoRectangleExternalCache
#define HalPowerEarlyRestore                  HALPDISPATCH->HalPowerEarlyRestore
#define HalQueryCapsuleCapabilities           HALPDISPATCH->HalQueryCapsuleCapabilities
#define HalUpdateCapsule                      HALPDISPATCH->HalUpdateCapsule
#define HalPciMultiStageResumeCapable         HALPDISPATCH->HalPciMultiStageResumeCapable
#define HalDmaFreeCrashDumpRegisters          HALPDISPATCH->HalDmaFreeCrashDumpRegisters
#define HalAcpiAoacCapable                    HALPDISPATCH->HalAcpiAoacCapable
#define HalInterruptSetDestination            HALPDISPATCH->HalInterruptSetDestination
#define HalGetClockConfiguration              HALPDISPATCH->HalGetClockConfiguration
#define HalClockTimerActivate                 HALPDISPATCH->HalClockTimerActivate
#define HalClockTimerInitialize               HALPDISPATCH->HalClockTimerInitialize
#define HalClockTimerStop                     HALPDISPATCH->HalClockTimerStop
#define HalClockTimerArm                      HALPDISPATCH->HalClockTimerArm
#define HalTimerOnlyClockInterruptPending     HALPDISPATCH->HalTimerOnlyClockInterruptPending
#define HalAcpiGetMultiNode                   HALPDISPATCH->HalAcpiGetMultiNode
#define HalPowerSetRebootHandler              HALPDISPATCH->HalPowerSetRebootHandler
#define HalIommuRegisterDispatchTable         HALPDISPATCH->HalIommuRegisterDispatchTable
#define HalTimerWatchdogStart                 HALPDISPATCH->HalTimerWatchdogStart
#define HalTimerWatchdogResetCountdown        HALPDISPATCH->HalTimerWatchdogResetCountdown
#define HalTimerWatchdogStop                  HALPDISPATCH->HalTimerWatchdogStop
#define HalTimerWatchdogGeneratedLastReset    HALPDISPATCH->HalTimerWatchdogGeneratedLastReset
#define HalTimerWatchdogTriggerSystemReset    HALPDISPATCH->HalTimerWatchdogTriggerSystemReset
#define HalInterruptVectorDataToGsiv          HALPDISPATCH->HalInterruptVectorDataToGsiv
#define HalInterruptGetHighestPriorityInterrupt HALPDISPATCH->HalInterruptGetHighestPriorityInterrupt
#define HalProcessorOn                        HALPDISPATCH->HalProcessorOn
#define HalProcessorOff                       HALPDISPATCH->HalProcessorOff
#define HalProcessorFreeze                    HALPDISPATCH->HalProcessorFreeze
#define HalDmaLinkDeviceObjectByToken         HALPDISPATCH->HalDmaLinkDeviceObjectByToken
#define HalDmaCheckAdapterToken               HALPDISPATCH->HalDmaCheckAdapterToken
#define HalPciLateRestore                     HALPDISPATCH->HalPciLateRestore
#define HalTimerConvertPerformanceCounterToAuxiliaryCounter \
        HALPDISPATCH->HalTimerConvertPerformanceCounterToAuxiliaryCounter

#define HalTimerConvertAuxiliaryCounterToPerformanceCounter \
        HALPDISPATCH->HalTimerConvertAuxiliaryCounterToPerformanceCounter

#define HalTimerQueryAuxiliaryCounterFrequency \
        HALPDISPATCH->HalTimerQueryAuxiliaryCounterFrequency

#define HalConnectThermalInterrupt            HALPDISPATCH->HalConnectThermalInterrupt
#define HalIsEFIRuntimeActive                 HALPDISPATCH->HalIsEFIRuntimeActive

//
// Define a dispatch table for the HAL's IOMMU support that is entirely private
// between the kernel and the HAL and is not exported from either binary.
//

typedef
BOOLEAN
(*pHalIommuSupportEnabled) (
    VOID
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuGetConfiguration) (
    _In_ ULONG Domain,
    _Out_ PULONG PageRequestQueues,
    _Out_ PULONG MaximumAsids,
    _Out_ PVOID *SystemContext
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuGetLibraryContext) (
    _In_ ULONG Pasid,
    _In_ ULONG Domain,
    _Out_ PVOID *LibraryContext
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuMapDevice) (
    _In_ PVOID LibraryContext,
    _In_ PIOMMU_DEVICE_PATH DevicePath,
    _In_ PIOMMU_SVM_CAPABILITIES DeviceCapabilities,
    _Out_ PVOID *DeviceHandle
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuEnableDevicePasid) (
    _In_ PVOID LibraryContext,
    _In_ PVOID DeviceHandle
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuSetAddressSpace) (
    _In_ PVOID LibraryContext,
    _In_ ULONG_PTR DirectoryBase
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuDisableDevicePasid) (
    _In_ PVOID LibraryContext,
    _In_ PVOID DeviceHandle
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuUnmapDevice) (
    _In_ PVOID SystemContext,
    _In_ PVOID DeviceHandle
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuFreeLibraryContext) (
    _In_ PVOID LibraryContext
    );

typedef
_IRQL_requires_max_(HIGH_LEVEL)
VOID
(*pHalIommuFlushTb) (
    _In_ PVOID LibraryContext,
    _In_ ULONG Number,
    _In_count_ (Number) KTB_FLUSH_VA Virtual[]
    );

typedef
_IRQL_requires_max_(HIGH_LEVEL)
VOID
(*pHalIommuFlushAllPasid) (
    _In_ PVOID LibraryContext,
    _In_ ULONG Number,
    _In_count_ (Number) KTB_FLUSH_VA VA[]
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN
(*pHalIommuProcessPageRequestQueue) (
    _In_ ULONG Index
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuDevicePowerChange) (
    _In_ PVOID SystemContext,
    _In_ PVOID DeviceHandle,
    _In_ BOOLEAN PowerActive
    );

typedef
_IRQL_requires_max_(HIGH_LEVEL)
VOID
(*pHalIommuFaultRoutine) (
    _In_ ULONG Index
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
PVOID
(*pHalIommuReferenceAsid) (
    _In_ ULONG Asid
    );

typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
(*pHalIommuDereferenceAsid) (
    _In_ ULONG Asid
    );

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
(*pHalIommuServicePageFault) (
    _In_ ULONG_PTR FaultStatus,
    _In_ PVOID FaultingVa,
    _In_ ULONG Asid
    );

struct _HAL_IOMMU_DISPATCH {
    pHalIommuSupportEnabled         HalIommuSupportEnabled;
    pHalIommuGetConfiguration       HalIommuGetConfiguration;
    pHalIommuGetLibraryContext      HalIommuGetLibraryContext;
    pHalIommuMapDevice              HalIommuMapDevice;
    pHalIommuEnableDevicePasid      HalIommuEnableDevicePasid;
    pHalIommuSetAddressSpace        HalIommuSetAddressSpace;
    pHalIommuDisableDevicePasid     HalIommuDisableDevicePasid;
    pHalIommuUnmapDevice            HalIommuUnmapDevice;
    pHalIommuFreeLibraryContext     HalIommuFreeLibraryContext;
    pHalIommuFlushTb                HalIommuFlushTb;
    pHalIommuFlushAllPasid          HalIommuFlushAllPasid;
    pHalIommuProcessPageRequestQueue HalIommuProcessPageRequestQueue;
    pHalIommuFaultRoutine           HalIommuFaultRoutine;
    pHalIommuReferenceAsid          HalIommuReferenceAsid;
    pHalIommuDereferenceAsid        HalIommuDereferenceAsid;
    pHalIommuServicePageFault       HalIommuServicePageFault;
    pHalIommuDevicePowerChange      HalIommuDevicePowerChange;
};

extern  PHAL_IOMMU_DISPATCH         HalIommuDispatch;

#define HalIommuSupportEnabled      HalIommuDispatch->HalIommuSupportEnabled
#define HalIommuGetConfiguration    HalIommuDispatch->HalIommuGetConfiguration
#define HalIommuGetLibraryContext   HalIommuDispatch->HalIommuGetLibraryContext
#define HalIommuMapDevice           HalIommuDispatch->HalIommuMapDevice
#define HalIommuEnableDevicePasid   HalIommuDispatch->HalIommuEnableDevicePasid
#define HalIommuSetAddressSpace     HalIommuDispatch->HalIommuSetAddressSpace
#define HalIommuDisableDevicePasid  HalIommuDispatch->HalIommuDisableDevicePasid
#define HalIommuUnmapDevice         HalIommuDispatch->HalIommuUnmapDevice
#define HalIommuFreeLibraryContext  HalIommuDispatch->HalIommuFreeLibraryContext
#define HalIommuFlushTb             HalIommuDispatch->HalIommuFlushTb
#define HalIommuFlushAllPasid       HalIommuDispatch->HalIommuFlushAllPasid
#define HalIommuProcessPageRequestQueue HalIommuDispatch->HalIommuProcessPageRequestQueue
#define HalIommuFaultRoutine        HalIommuDispatch->HalIommuFaultRoutine
#define HalIommuReferenceAsid       HalIommuDispatch->HalIommuReferenceAsid
#define HalIommuDereferenceAsid     HalIommuDispatch->HalIommuDereferenceAsid
#define HalIommuServicePageFault    HalIommuDispatch->HalIommuServicePageFault
#define HalIommuDevicePowerChange   HalIommuDispatch->HalIommuDevicePowerChange

// end_nthal
// begin_ntddk

//
// HAL System Information Structures.
//

// for the information class "HalInstalledBusInformation"
typedef struct _HAL_BUS_INFORMATION{
    INTERFACE_TYPE  BusType;
    BUS_DATA_TYPE   ConfigurationType;
    ULONG           BusNumber;
    ULONG           Reserved;
} HAL_BUS_INFORMATION, *PHAL_BUS_INFORMATION;

// for the information class "HalDispayBiosInformation"
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
    HalDisplayInt10Bios,
    HalDisplayEmulatedBios,
    HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION, *PHAL_DISPLAY_BIOS_INFORMATION;

// for the information class "HalPowerInformation"
typedef struct _HAL_POWER_INFORMATION {
    ULONG   TBD;
} HAL_POWER_INFORMATION, *PHAL_POWER_INFORMATION;

// for the information class "HalProcessorSpeedInformation"
typedef struct _HAL_PROCESSOR_SPEED_INFO {
    ULONG   ProcessorSpeed;
} HAL_PROCESSOR_SPEED_INFORMATION, *PHAL_PROCESSOR_SPEED_INFORMATION;

// for the information class "HalCallbackInformation"
typedef struct _HAL_CALLBACKS {
    PCALLBACK_OBJECT  SetSystemInformation;
    PCALLBACK_OBJECT  BusCheck;
} HAL_CALLBACKS, *PHAL_CALLBACKS;

// for the information class "HalProcessorFeatureInformation"
typedef struct _HAL_PROCESSOR_FEATURE {
    ULONG UsableFeatureBits;
} HAL_PROCESSOR_FEATURE;

// end_ntddk
// begin_nthal

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
    KPROFILE_SOURCE Source;
    BOOLEAN Supported;
    ULONG Interval;
    PCWSTR Description;
} HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION;

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION_EX {
    KPROFILE_SOURCE Source;
    BOOLEAN         Supported;
    ULONG_PTR       Interval;
    ULONG_PTR       DefInterval;
    ULONG_PTR       MaxInterval;
    ULONG_PTR       MinInterval;
} HAL_PROFILE_SOURCE_INFORMATION_EX, *PHAL_PROFILE_SOURCE_INFORMATION_EX;

// for the information class "HalProfileSourceInterval"
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
    KPROFILE_SOURCE Source;
    ULONG Interval;
} HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL;

// for the information class "HalQueryProfileSourceList"
typedef struct _HAL_PROFILE_SOURCE_LIST {
    ULONG NextEntryOffset;
    KPROFILE_SOURCE Source;
    ULONG MinInterval;
    ULONG MaxInterval;
    ULONG64 Reserved;
    WCHAR Description[ANYSIZE_ARRAY];
} HAL_PROFILE_SOURCE_LIST, *PHAL_PROFILE_SOURCE_LIST;

typedef enum _HAL_PLATFORM_TIMER_SOURCE {
    HalPlatformTimerNotSpecified = 0,
    HalPlatformTimer8254,
    HalPlatformTimerRtc,
    HalPlatformTimerAcpi,
    HalPlatformTimerAcpiBroken,
    HalPlatformTimerHpet,
    HalPlatformTimerProcessorCounter,
    HalPlatformTimerHvReferenceTime,
    HalPlatformTimerSfi,
    HalPlatformTimerApic,
    HalPlatformTimerHvSynthetic,
    HalPlatformTimerCustom,
    HalPlatformTimerCycleCounter,
    HalPlatformTimerGit,
} HAL_PLATFORM_TIMER_SOURCE;

// for the information class "HalPlatformTimerInformation"

#define HAL_PLATFORM_TIMER_INFORMATION_VERSION 1

typedef struct _HAL_PLATFORM_TIMER_INFORMATION {
    ULONG Version;
    HAL_PLATFORM_TIMER_SOURCE ClockInterruptSource;
    HAL_PLATFORM_TIMER_SOURCE PerformanceCounterSource;
} HAL_PLATFORM_TIMER_INFORMATION, *PHAL_PLATFORM_TIMER_INFORMATION;

// for the information class "HalAcpiAuditInformation"

typedef struct _HAL_ACPI_AUDIT_INFORMATION {
    ULONG RsdpCount;
    struct {
        ULONG SameRsdt:1;
        ULONG SlicPresent:1;
        ULONG SlicDifferent:1;
    };
} HAL_ACPI_AUDIT_INFORMATION, *PHAL_ACPI_AUDIT_INFORMATION;

// for the information class "HalParkingPageInformation"

typedef struct _HAL_PARKING_PAGE_INFORMATION {
    ULONG Processor;
    PHYSICAL_ADDRESS PhysicalPageAddress;
    PVOID VirtualPageAddress;
} HAL_PARKING_PAGE_INFORMATION, *PHAL_PARKING_PAGE_INFORMATION;

// for the information class "HalQueryIommuReservedRegionInformation"

typedef struct _HAL_IOMMU_RESERVED_REGION_INFORMATION {
    PDEVICE_OBJECT DeviceObject;
    BOOLEAN RequiresReservedRegion;
} HAL_IOMMU_RESERVED_REGION_INFORMATION, *PHAL_IOMMU_RESERVED_REGION_INFORMATION;

// for the information class "HalQueryProcessorEfficiencyInformation"

typedef struct _HAL_QUERY_PROCESSOR_EFFICIENCY_INFORMATION {
    ULONG ProcessorIndex;
    UCHAR PowerEfficiencyClass;
    UCHAR Spare[3];
} HAL_QUERY_PROCESSOR_EFFICIENCY_INFORMATION, *PHAL_QUERY_PROCESSOR_EFFICIENCY_INFORMATION;

// for the information class "HalEnlightenment"

typedef ULONG HAL_HV_LOGICAL_PROCESSOR_INDEX, *PHAL_HV_LOGICAL_PROCESSOR_INDEX;
typedef ULONG HAL_HV_VIRTUAL_PROCESSOR_INDEX, *PHAL_HV_VIRTUAL_PROCESSOR_INDEX;

typedef
VOID
(*PHAL_ENLIGHTENMENT_EOI) (
    VOID
    );

typedef
VOID
(*PHAL_ENLIGHTENMENT_WRITE_ICR) (
    _In_ ULONG Target,
    _In_ ULONG Command
    );

typedef
VOID
(*PHAL_LONG_SPIN_WAIT) (
    _In_ ULONG SpinCount
    );

typedef
ULONG64
(*PHAL_GET_REFERENCE_TIME) (
    VOID
    );

typedef
NTSTATUS
(*PHAL_SET_SYSTEM_SLEEP_PROPERTY)(
    _In_ UINT32 SleepState,
    _In_ UINT8 Pm1a_SLP_TYP,
    _In_ UINT8 Pm1b_SLP_TYP
    );

typedef
NTSTATUS
(*PHAL_SET_SYSTEM_MACHINE_CHECK_PROPERTY)(
    _In_ PVOID MachineCheckPropertyInfo
    );

typedef
NTSTATUS
(*PHAL_ENTER_SLEEP_STATE)(
    _In_ UINT32 SleepState
    );

typedef
NTSTATUS
(*PHAL_NOTIFY_DEBUG_DEVICE_AVAILABLE)(
    VOID
    );

typedef
NTSTATUS
(*PHAL_MAP_DEVICE_INTERRUPT)(
    _In_ UINT64 DeviceId,
    _In_ UINT64 Flags,
    _In_ PVOID InterruptDescriptor,
    _In_opt_ PGROUP_AFFINITY GroupAffinity,
    _Out_ PVOID InterruptEntry
    );

typedef
NTSTATUS
(*PHAL_UNMAP_DEVICE_INTERRUPT)(
    _In_ UINT64 DeviceId,
    _In_ PVOID InterruptEntry
    );

typedef
NTSTATUS
(*PHAL_SET_HPET_CONFIG)(
    _In_ PHYSICAL_ADDRESS BaseAddress,
    _In_ ULONG TimerIndex,
    _In_ UINT64 DeviceId,
    _In_ UCHAR TimerInterruptPin,
    _Out_ PVOID InterruptEntry
    );

typedef
NTSTATUS
(*PHAL_NOTIFY_HPET_ENABLED)(
    VOID
    );

typedef
NTSTATUS
(*PHAL_QUERY_ASSOCIATED_PROCESSORS) (
    _In_ ULONG VpIndex,
    _Inout_ PULONG Count,
    _Out_writes_to_opt_(*Count, *Count) PHAL_HV_LOGICAL_PROCESSOR_INDEX PpIndices
    );

typedef
NTSTATUS
(*PHAL_LP_READ_MULTIPLE_MSR) (
    _In_ HAL_HV_LOGICAL_PROCESSOR_INDEX HvLpIndex,
    _In_ ULONG Count,
    _In_reads_(Count) PULONG MsrIndices,
    _Out_writes_(Count) PULONG64 MsrValues
    );

typedef
NTSTATUS
(*PHAL_LP_WRITE_MULTIPLE_MSR) (
    _In_ HAL_HV_LOGICAL_PROCESSOR_INDEX HvLpIndex,
    _In_ ULONG Count,
    _In_reads_(Count) PULONG MsrIndices,
    _In_reads_(Count) PULONG64 MsrValues
    );

typedef
NTSTATUS
(*PHAL_LP_READ_CPUID) (
    _In_ HAL_HV_LOGICAL_PROCESSOR_INDEX HvLpIndex,
    _In_ ULONG InEax,
    _Out_ PULONG OutEax,
    _Out_ PULONG OutEbx,
    _Out_ PULONG OutEcx,
    _Out_ PULONG OutEdx
    );

typedef
NTSTATUS
(*PHAL_LP_WRITEBACK_INVALIDATE) (
    _In_ HAL_HV_LOGICAL_PROCESSOR_INDEX HvLpIndex
    );

typedef
NTSTATUS
(*PHAL_LP_GET_MACHINE_CHECK_CONTEXT) (
    _In_ HAL_HV_LOGICAL_PROCESSOR_INDEX HvLpIndex,
    _Out_ UINT32 *Source,
    _Out_ UINT64 *PartitionId,
    _Out_ UINT32 *VpIndex
    );

typedef
NTSTATUS
(*PHAL_SUSPEND_PARTITION) (
    _In_ UINT64 PartitionId
    );

typedef
NTSTATUS
(*PHAL_RESUME_PARTITION) (
    _In_ UINT64 PartitionId
    );

//
// _WHEA_RECOVERY_CONTEXT is defined in ntddk.h
//

typedef struct _WHEA_RECOVERY_CONTEXT *PWHEA_RECOVERY_CONTEXT;

typedef
NTSTATUS
(*PHAL_WHEA_ERROR_NOTIFICATION) (
    _In_ PWHEA_RECOVERY_CONTEXT RecoveryContext,
    _In_ BOOLEAN PlatformDirected,
    _In_ BOOLEAN Poisoned
    );

typedef
ULONG
(*PHAL_GET_PROCESSOR_INDEX_FROM_VP_INDEX) (
    _In_ ULONG VpIndex
    );

typedef
NTSTATUS
(*PHAL_SYNTHETIC_CLUSTER_IPI) (
    _In_ PKAFFINITY_EX Affinity,
    _In_ ULONG Vector
    );

typedef union _HAL_X64_SEGMENT_SELECTOR {
    UINT16 AsUINT16;
    struct {
        UINT16 Rpl:2;
        UINT16 LdtSelector:1;
        UINT16 TableIndex:13;
    };
} HAL_X64_SEGMENT_SELECTOR, *PHAL_X64_SEGMENT_SELECTOR;

typedef
BOOLEAN
(*PHAL_VP_START_ENABLED) (
    VOID
    );

typedef
NTSTATUS
(*PHAL_START_VIRTUAL_PROCESSOR) (
    _In_ ULONG VpIndex,
    _In_ PVOID Context
    );

typedef
NTSTATUS
(*PHAL_GET_VP_INDEX_FROM_APIC_ID) (
    _In_ ULONG ApicId,
    _Out_ PULONG VpIndex
    );

typedef struct _HAL_HV_SVM_SYSTEM_CAPABILITIES {
    struct {
        ULONG SvmSupported : 1;
        ULONG GpaAlwaysValid : 1;
    };
    ULONG MaxPasidSpaceCount;
    ULONG MaxPasidSpacePasidCount;
    ULONG MaxPrqSize;
    ULONG IommuCount;
    ULONG MinIommuPasidCount;
} HAL_HV_SVM_SYSTEM_CAPABILITIES, *PHAL_HV_SVM_SYSTEM_CAPABILITIES;

typedef
VOID
(*PHAL_SVM_GET_SYSTEM_CAPABILITIES) (
    _Out_ PHAL_HV_SVM_SYSTEM_CAPABILITIES Capabilities
    );

typedef
SIZE_T // EFI_STATUS
(*PHAL_IUM_EFI_RUNTIME_SERVICE) (
    _In_ ULONG Service,
    _Inout_updates_bytes_(Size) PVOID Data,
    _In_ ULONGLONG Size,
    _Inout_opt_ ULONGLONG Parameters[]
    );

typedef struct _HAL_HV_SVM_DEVICE_CAPABILITIES {
    struct {
        ULONG SvmSupported : 1;
        ULONG PciExecute : 1;
        ULONG NoExecute : 1;
        ULONG Reserved : 28;
        ULONG OverflowPossible : 1;
    };
    ULONG PasidCount;
    ULONG IommuIndex;
} HAL_HV_SVM_DEVICE_CAPABILITIES, *PHAL_HV_SVM_DEVICE_CAPABILITIES;

typedef
NTSTATUS
(*PHAL_SVM_GET_DEVICE_CAPABILITIES) (
    _In_ ULONG DeviceId,
    _Out_ PHAL_HV_SVM_DEVICE_CAPABILITIES Capabilities
    );

typedef
NTSTATUS
(*PHAL_SVM_CREATE_PASID_SPACE) (
    _In_ ULONG PasidSpaceId,
    _In_ ULONG PasidCount
    );

typedef
NTSTATUS
(*PHAL_SVM_SET_PASID_ADDRESS_SPACE) (
    _In_ ULONG PasidSpaceId,
    _In_ ULONG Pasid,
    _In_ ULONGLONG AddressSpace
    );

typedef
VOID
(*PHAL_SVM_FLUSH_PASID) (
    _In_ ULONG PasidSpaceId,
    _In_ ULONG Pasid,
    _In_ ULONG Number,
    _In_reads_opt_(Number) KTB_FLUSH_VA Virtual[]
    );

typedef
NTSTATUS
(*PHAL_SVM_ATTACH_PASID_SPACE) (
    _In_ ULONG DeviceId,
    _In_ ULONG PasidSpaceId,
    _In_ ULONG PrqId,
    _In_ ULONG PciCapabilities
    );

typedef
NTSTATUS
(*PHAL_SVM_DETACH_PASID_SPACE) (
    _In_ ULONG DeviceId
    );

typedef
NTSTATUS
(*PHAL_SVM_ENABLE_PASID) (
    _In_ ULONG DeviceId,
    _In_ ULONG Pasid
    );

typedef
NTSTATUS
(*PHAL_SVM_DISABLE_PASID) (
    _In_ ULONG DeviceId,
    _In_ ULONG Pasid
    );

typedef
NTSTATUS
(*PHAL_SVM_ACKNOWLEDGE_PAGE_REQUEST) (
    _In_ ULONG Count,
    _In_ PVOID PageRequestList,
    _Out_opt_ PULONG Processed
    );

typedef
NTSTATUS
(*PHAL_SVM_CREATE_PR_QUEUE) (
    _In_ ULONG QueueId,
    _In_ ULONG Size,
    _In_ PHYSICAL_ADDRESS BaseAddress,
    _In_ ULONG InterruptVector,
    _In_ ULONG InterruptProcessorIndex
    );

typedef
NTSTATUS
(*PHAL_SVM_DELETE_PR_QUEUE) (
    _In_ ULONG QueueId
    );

typedef
NTSTATUS
(*PHAL_SVM_CLEAR_PRQ_STALLED) (
    _In_ ULONG QueueId
    );

typedef
NTSTATUS
(*PHAL_SVM_SET_DEVICE_ENABLED) (
    _In_ ULONG DeviceId,
    _In_ BOOLEAN Enabled
    );

#if !defined(_ARM64_) && !defined(_ARM_)

typedef struct _HAL_INTEL_ENLIGHTENMENT_INFORMATION {
    ULONG Enlightenments;
    LOGICAL HypervisorConnected;
    PHAL_ENLIGHTENMENT_EOI EndOfInterrupt;
    PHAL_ENLIGHTENMENT_WRITE_ICR ApicWriteIcr;
    ULONG Reserved0;
    ULONG SpinCountMask;
    PHAL_LONG_SPIN_WAIT LongSpinWait;
    PHAL_GET_REFERENCE_TIME GetReferenceTime;
    PHAL_SET_SYSTEM_SLEEP_PROPERTY SetSystemSleepProperty;
    PHAL_ENTER_SLEEP_STATE EnterSleepState;
    PHAL_NOTIFY_DEBUG_DEVICE_AVAILABLE NotifyDebugDeviceAvailable;
    PHAL_MAP_DEVICE_INTERRUPT MapDeviceInterrupt;
    PHAL_UNMAP_DEVICE_INTERRUPT UnmapDeviceInterrupt;
    PHAL_SET_HPET_CONFIG SetHpetConfig;
    PHAL_NOTIFY_HPET_ENABLED NotifyHpetEnabled;
    PHAL_QUERY_ASSOCIATED_PROCESSORS QueryAssociatedProcessors;
    PHAL_LP_READ_MULTIPLE_MSR ReadMultipleMsr;
    PHAL_LP_WRITE_MULTIPLE_MSR WriteMultipleMsr;
    PHAL_LP_READ_CPUID ReadCpuid;
    PHAL_LP_WRITEBACK_INVALIDATE LpWritebackInvalidate;
    PHAL_LP_GET_MACHINE_CHECK_CONTEXT GetMachineCheckContext;
    PHAL_SUSPEND_PARTITION SuspendPartition;
    PHAL_RESUME_PARTITION ResumePartition;
    PHAL_SET_SYSTEM_MACHINE_CHECK_PROPERTY SetSystemMachineCheckProperty;
    PHAL_WHEA_ERROR_NOTIFICATION WheaErrorNotification;
    PHAL_GET_PROCESSOR_INDEX_FROM_VP_INDEX GetProcessorIndexFromVpIndex;
    PHAL_SYNTHETIC_CLUSTER_IPI SyntheticClusterIpi;
    PHAL_VP_START_ENABLED VpStartEnabled;
    PHAL_START_VIRTUAL_PROCESSOR StartVirtualProcessor;
    PHAL_GET_VP_INDEX_FROM_APIC_ID GetVpIndexFromApicId;
    PHAL_IUM_EFI_RUNTIME_SERVICE IumEfiRuntimeService;
    PHAL_SVM_GET_SYSTEM_CAPABILITIES SvmGetSystemCapabilities;
    PHAL_SVM_GET_DEVICE_CAPABILITIES SvmGetDeviceCapabilities;
    PHAL_SVM_CREATE_PASID_SPACE SvmCreatePasidSpace;
    PHAL_SVM_SET_PASID_ADDRESS_SPACE SvmSetPasidAddressSpace;
    PHAL_SVM_FLUSH_PASID SvmFlushPasid;
    PHAL_SVM_ATTACH_PASID_SPACE SvmAttachPasidSpace;
    PHAL_SVM_DETACH_PASID_SPACE SvmDetachPasidSpace;
    PHAL_SVM_ENABLE_PASID SvmEnablePasid;
    PHAL_SVM_DISABLE_PASID SvmDisablePasid;
    PHAL_SVM_ACKNOWLEDGE_PAGE_REQUEST SvmAcknowledgePageRequest;
    PHAL_SVM_CREATE_PR_QUEUE SvmCreatePrQueue;
    PHAL_SVM_DELETE_PR_QUEUE SvmDeletePrQueue;
    PHAL_SVM_CLEAR_PRQ_STALLED SvmClearPrqStalled;
    PHAL_SVM_SET_DEVICE_ENABLED SvmSetDeviceEnabled;
} HAL_INTEL_ENLIGHTENMENT_INFORMATION, *PHAL_INTEL_ENLIGHTENMENT_INFORMATION;

#else

typedef struct _HAL_ARM_ENLIGHTENMENT_INFORMATION {
    ULONG Enlightenments;
    LOGICAL HypervisorConnected;
    ULONG Reserved0;
    ULONG SpinCountMask;
    PHAL_LONG_SPIN_WAIT LongSpinWait;
    PHAL_GET_REFERENCE_TIME GetReferenceTime;
    PHAL_SET_SYSTEM_SLEEP_PROPERTY SetSystemSleepProperty;
    PHAL_ENTER_SLEEP_STATE EnterSleepState;
    PHAL_NOTIFY_DEBUG_DEVICE_AVAILABLE NotifyDebugDeviceAvailable;
    PHAL_MAP_DEVICE_INTERRUPT MapDeviceInterrupt;
    PHAL_UNMAP_DEVICE_INTERRUPT UnmapDeviceInterrupt;
    PHAL_QUERY_ASSOCIATED_PROCESSORS QueryAssociatedProcessors;
    PHAL_LP_GET_MACHINE_CHECK_CONTEXT GetMachineCheckContext;
    PHAL_SUSPEND_PARTITION SuspendPartition;
    PHAL_RESUME_PARTITION ResumePartition;
    PHAL_SET_SYSTEM_MACHINE_CHECK_PROPERTY SetSystemMachineCheckProperty;
    PHAL_WHEA_ERROR_NOTIFICATION WheaErrorNotification;
    PHAL_GET_PROCESSOR_INDEX_FROM_VP_INDEX GetProcessorIndexFromVpIndex;
    PHAL_SYNTHETIC_CLUSTER_IPI SyntheticClusterIpi;
} HAL_ARM_ENLIGHTENMENT_INFORMATION, *PHAL_ARM_ENLIGHTENMENT_INFORMATION;

#endif



// for the information class "HalNumaTopologyInterface"

typedef
NTSTATUS
(*PHALNUMAQUERYPROCESSORNODE)(
    _In_ ULONG ProcessorNumber,
    _Inout_ PULONG Identifier,
    _Out_ PUSHORT Node
    );

typedef
NTSTATUS
(*PHALNUMAQUERYPROXIMITYNODE)(
    _In_ ULONG ProximityId,
    _Out_ PUSHORT Node
    );

typedef
NTSTATUS
(*PHALNUMAADDRANGEPROXIMITY)(
    _In_ ULONG_PTR PhysicalPageNumber,
    _In_ ULONG_PTR Length,
    _In_ ULONG ProximityId
    );

typedef
NTSTATUS
(*PHALNUMAQUERYPROXIMITYID)(
    _In_ USHORT Node,
    _Out_ PULONG ProximityId,
    _Out_opt_ PULONG OrigProximityId
    );

typedef
NTSTATUS
(*PHALNUMAQUERYNODECAPACITY)(
    _In_ USHORT Node,
    _Out_ PULONG Capacity
    );

typedef
NTSTATUS
(*PHALNUMAQUERYNODEDISTANCE)(
    _In_ USHORT Node1,
    _In_ USHORT Node2,
    _Out_ PULONG Distance
    );

typedef struct _HAL_NUMA_TOPOLOGY_INTERFACE {
    USHORT                              NumberOfNodes;
    PHALNUMAQUERYPROCESSORNODE          QueryProcessorNode;
    PVOID                               Spare;
    PHALNUMAQUERYPROXIMITYNODE          QueryProximityNode;
    PHALNUMAADDRANGEPROXIMITY           AddRangeProximity;
    PHALNUMAQUERYPROXIMITYID            QueryProximityId;
    PHALNUMAQUERYNODECAPACITY           QueryNodeCapacity;
    PHALNUMAQUERYNODEDISTANCE           QueryNodeDistance;
} HAL_NUMA_TOPOLOGY_INTERFACE;

// for the information class "HalNumaRangeTableInformation"

typedef struct _HAL_NODE_RANGE {
    ULONG_PTR PageFrameIndex;
    ULONG Node;
} HAL_NODE_RANGE, *PHAL_NODE_RANGE;

// for the information class "HalIrtInformation"

typedef struct _HAL_IRT_INFORMATION {
    ULONG   SegmentCount;
    ULONG   IrtEntriesForParentOsPerSegment;
    ULONG   IrtEntriesForChildOsesPerSegment;
} HAL_IRT_INFORMATION, *PHAL_IRT_INFORMATION;

// for the information class "HalChannelTopologyInformation"

typedef struct _HAL_CHANNEL_MEMORY_RANGES {
    ULONG_PTR PageFrameIndex;
    USHORT MpnId;
    USHORT Node;
    USHORT Channel;
    BOOLEAN IsPowerManageable;
    UCHAR DeepPowerState;
} HAL_CHANNEL_MEMORY_RANGES, *PHAL_CHANNEL_MEMORY_RANGES;

// for the information class "HalGetChannelPowerInformation" and "HalSetChannelPowerInformation"

//
// The power command values are defined in ACPI SPEC 5.0.
// The order and initial value cannot be changed without checking SPEC.
//

typedef enum {
    HalPccChannelPowerCommandGetPowerState = 1,
    HalPccChannelPowerCommandSetPowerState,
    HalPccChannelPowerCommandGetExpectedPowerConsumed,
    HalPccChannelPowerCommandGetEnergyConsumed,
    HalPccChannelPowerCommandMax
} HAL_PCC_CHANNEL_POWER_COMMAND, *PHAL_PCC_CHANNEL_POWER_COMMAND;

typedef struct _HAL_CHANNEL_COMMAND {
    USHORT Node;
    USHORT Channel;
    HAL_PCC_CHANNEL_POWER_COMMAND Command;
    ULONG Status;
    ULONGLONG Data;
} HAL_CHANNEL_COMMAND, *PHAL_CHANNEL_COMMAND;

#define HAL_CHANNEL_POWER_STATE_HOT         0x0
#define HAL_CHANNEL_POWER_STATE_COOL        0x1

// for the information class "HalExternalCacheInfo"

typedef struct _HAL_EXTERNAL_CACHE_INFO {
    CACHE_DESCRIPTOR CacheDescriptor;
    BOOLEAN GlobalSyncRequired;
} HAL_EXTERNAL_CACHE_INFO, *PHAL_EXTERNAL_CACHE_INFO;

//
// For the information class "HalPsciInformation"
//

typedef union _HAL_PSCI_INFO {
    ULONG Flags;
    struct {
        ULONG CpuDefaultSuspendSupported: 1;
        ULONG Reserved: 31;
    };
} HAL_PSCI_INFO, *PHAL_PSCI_INFO;

//
// For the information class "HalInterruptControllerInformation"
//

typedef union _INTERRUPT_CONTROLLER_INFO {
    ULONG Flags;
    struct {
        ULONG LevelSensitiveInterruptSteering: 1;
        ULONG LatchedInterruptSteering: 1;
        ULONG Reserved: 30;
    };
} INTERRUPT_CONTROLLER_INFO, *PINTERRUPT_CONTROLLER_INFO;

C_ASSERT(sizeof(INTERRUPT_CONTROLLER_INFO) == sizeof(ULONG));

//
// For the information class "HalQueryArmErrataInformation"
//

typedef struct _ARM_ERRATA_INFO {
    union {
        ULONG Flags;
        struct {
            ULONG SignalIpiOnTlbFlush : 1;
            ULONG Reserved: 31;
        };
    };
} ARM_ERRATA_INFO, *PARM_ERRATA_INFO;

// begin_ntddk

typedef
NTSTATUS
(*PHALIOREADWRITEHANDLER)(
    _In_      BOOLEAN fRead,
    _In_      ULONG dwAddr,
    _In_      ULONG dwSize,
    _Inout_  PULONG pdwData
    );

// end_nthal

// for the information class "HalQueryIllegalIOPortAddresses"
typedef struct _HAL_AMLI_BAD_IO_ADDRESS_LIST
{
    ULONG                   BadAddrBegin;
    ULONG                   BadAddrSize;
    ULONG                   OSVersionTrigger;
    PHALIOREADWRITEHANDLER  IOHandler;
} HAL_AMLI_BAD_IO_ADDRESS_LIST, *PHAL_AMLI_BAD_IO_ADDRESS_LIST;

// begin_nthal

//
// Define a structure for communicating processor interrupt controller
// information.
//

typedef enum {
    InterruptTargetTypeApic,
    InterruptTargetTypeApicRequest,
    InterruptTargetTypeGlobal           // use for Interrupt Controller Input
} HAL_INTERRUPT_TARGET_TYPE;

#define INTERRUPT_TARGET_APIC_MSI_SUPPORTED             0x1
#define INTERRUPT_TARGET_APIC_PHYSICAL_MODE_SUPPORTED   0x2
#define INTERRUPT_TARGET_PM_REQUIRES_BREAK_EVENT        0x4
#define INTERRUPT_TARGET_ONE_PENDING_INTERRUPT_PER_IRQL 0x8

// end_nthal begin_ntddk

typedef enum {
    ApicDestinationModePhysical = 1,
    ApicDestinationModeLogicalFlat,
    ApicDestinationModeLogicalClustered,
    ApicDestinationModeUnknown
} HAL_APIC_DESTINATION_MODE, *PHAL_APIC_DESTINATION_MODE;

// end_ntddk begin_nthal

typedef struct _HAL_INTERRUPT_TARGET_INFORMATION {
    HAL_INTERRUPT_TARGET_TYPE Type;
    PROCESSOR_NUMBER ProcessorNumber;
    ULONG Flags;

    union {
        struct {
            ULONG LogicalApicId;
            ULONG ClusterId;
            HAL_APIC_DESTINATION_MODE DestinationMode;
        } Apic;

        struct {
            BOOLEAN Enabled;
            ULONG MinimumIndex;
            ULONG MaximumIndex;
        } Irt;
    };
} HAL_INTERRUPT_TARGET_INFORMATION, *PHAL_INTERRUPT_TARGET_INFORMATION;

//
// Define the format of interrupt remapping information.
//

typedef struct _INTERRUPT_REMAPPING_INFO {
    ULONG IrtIndex:30;
    ULONG FlagHalInternal:1;
    ULONG FlagTranslated:1;

    union {
        ULARGE_INTEGER RemappedFormat; // generic form

        struct {
            ULONG   MessageAddressLow;
            USHORT  MessageData;
            USHORT  Reserved;
        } Msi;
    } u;
} INTERRUPT_REMAPPING_INFO, *PINTERRUPT_REMAPPING_INFO;

typedef struct _HAL_MESSAGE_TARGET_REQUEST {
    HAL_INTERRUPT_TARGET_TYPE Type;

    struct {
        ULONG Vector;
        GROUP_AFFINITY TargetProcessors;
        HAL_APIC_DESTINATION_MODE DestinationMode;
        INTERRUPT_REMAPPING_INFO IntRemapInfo;
    } Apic;
} HAL_MESSAGE_TARGET_REQUEST, *PHAL_MESSAGE_TARGET_REQUEST;

NTHALAPI
NTSTATUS
HalGetInterruptTargetInformation (
    _In_ HAL_INTERRUPT_TARGET_TYPE TargetType,
    _In_ ULONG ProcessorId,
    _Out_ PHAL_INTERRUPT_TARGET_INFORMATION TargetInformation
    );

NTHALAPI
NTSTATUS
HalGetMessageRoutingInfo (
    _In_ PHAL_MESSAGE_TARGET_REQUEST Request,
    _Out_ PINTERRUPT_CONNECTION_DATA ConnectionData
    );

//
// Define extended information associated with an interrupt connection request
// This is stored as a property of a device.
//

typedef enum {
    InterruptTypeControllerInput,
    InterruptTypeXapicMessage,
    InterruptTypeHypertransport,
    InterruptTypeMessageRequest
} INTERRUPT_CONNECTION_TYPE;

//
// Define the format of hypertransport interrupt message information.
//

typedef struct _INTERRUPT_HT_INTR_INFO {

    union {
        struct {
            ULONG Mask:1;             // bit 0
            ULONG Polarity:1;         // bit 1
            ULONG MessageType:3;      // bits [4:2]
            ULONG RequestEOI:1;       // bit 5
            ULONG DestinationMode:1;  // bit 6
            ULONG MessageType3:1;     // bit 7
            ULONG Destination:8;      // bits [15:8]
            ULONG Vector:8;           // bits [23:16]
            ULONG ExtendedAddress:8;  // bits [31:24] -- always set to 0xF8
        } bits;

        ULONG AsULONG;

    } LowPart;

    union {
        struct {
            ULONG ExtendedDestination:24;
            ULONG Reserved:6;
            ULONG PassPW:1;
            ULONG WaitingForEOI:1;
        } bits;

        ULONG AsULONG;

    } HighPart;

} INTERRUPT_HT_INTR_INFO, *PINTERRUPT_HT_INTR_INFO;

//
// Define the format of a single interrupt vector connection information.
//

typedef struct _INTERRUPT_VECTOR_DATA {

    INTERRUPT_CONNECTION_TYPE Type;
    ULONG Vector;
    KIRQL Irql;

    //
    // N.B. If Polarity is InterruptActiveBothTriggerLow or
    //      InterruptActiveBothTriggerHigh, Mode will be Latched.
    //
    //      If the interrupt controller will be programmed to emulate
    //      ActiveBoth using levels, the KINTERRUPT object used in interrupt
    //      dispatching must be passed LevelSensitive instead of this Mode.
    //

    KINTERRUPT_POLARITY Polarity;
    KINTERRUPT_MODE Mode;
    GROUP_AFFINITY TargetProcessors;
    INTERRUPT_REMAPPING_INFO IntRemapInfo;

    struct {
        ULONG Gsiv;
        ULONG WakeInterrupt:1;
        ULONG ReservedFlags:31;
    } ControllerInput;

    union {
        struct {
            PHYSICAL_ADDRESS Address;
            ULONG DataPayload;
        } XapicMessage;

        struct {
            INTERRUPT_HT_INTR_INFO IntrInfo;
        } Hypertransport;

        struct {
            PHYSICAL_ADDRESS Address;
            ULONG DataPayload;
        } GenericMessage;

        struct {
            HAL_APIC_DESTINATION_MODE DestinationMode;
        } MessageRequest;
    };
} INTERRUPT_VECTOR_DATA, *PINTERRUPT_VECTOR_DATA;

//
// Define the format of the connection information for a device.  For an
// interrupt based off of an interrupt controller input, this will only describe
// a single vector.  For message-based interrupts, there may be multiple
// messages described.
//

typedef struct _INTERRUPT_CONNECTION_DATA {

    ULONG Count;

    _Field_size_full_(Count)
    INTERRUPT_VECTOR_DATA Vectors[ANYSIZE_ARRAY];

} INTERRUPT_CONNECTION_DATA, *PINTERRUPT_CONNECTION_DATA;


typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#if defined(_MSC_EXTENSIONS)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif

#else

struct _SCATTER_GATHER_LIST;
typedef struct _SCATTER_GATHER_LIST SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;

#endif

// end_ntndis

typedef struct _DMA_OPERATIONS *PDMA_OPERATIONS;

#define HAL_DMA_ADAPTER_VERSION_1 1

typedef struct _DMA_ADAPTER {
    USHORT Version;
    USHORT Size;
    PDMA_OPERATIONS DmaOperations;
    // Private Bus Device Driver data follows,
} DMA_ADAPTER, *PDMA_ADAPTER;

typedef enum {
    DmaComplete,
    DmaAborted,
    DmaError,
    DmaCancelled
} DMA_COMPLETION_STATUS;

// begin_nthal

typedef VOID (*PPUT_DMA_ADAPTER)(
    PDMA_ADAPTER DmaAdapter
    );

typedef PVOID (*PALLOCATE_COMMON_BUFFER)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ ULONG Length,
    _Out_ PPHYSICAL_ADDRESS LogicalAddress,
    _In_ BOOLEAN CacheEnabled
    );

typedef VOID (*PFREE_COMMON_BUFFER)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ ULONG Length,
    _In_ PHYSICAL_ADDRESS LogicalAddress,
    _In_ PVOID VirtualAddress,
    _In_ BOOLEAN CacheEnabled
    );

typedef NTSTATUS (*PALLOCATE_ADAPTER_CHANNEL)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG NumberOfMapRegisters,
    _In_ PDRIVER_CONTROL ExecutionRoutine,
    _In_ PVOID Context
    );

typedef BOOLEAN (*PFLUSH_ADAPTER_BUFFERS)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ PVOID CurrentVa,
    _In_ ULONG Length,
    _In_ BOOLEAN WriteToDevice
    );

typedef VOID (*PFREE_ADAPTER_CHANNEL)(
    _In_ PDMA_ADAPTER DmaAdapter
    );

typedef VOID (*PFREE_ADAPTER_OBJECT)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ IO_ALLOCATION_ACTION AllocationAction
    );

typedef VOID (*PFREE_MAP_REGISTERS)(
    _In_ PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

typedef PHYSICAL_ADDRESS (*PMAP_TRANSFER)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ PVOID CurrentVa,
    _Inout_ PULONG Length,
    _In_ BOOLEAN WriteToDevice
    );

typedef ULONG (*PGET_DMA_ALIGNMENT)(
    _In_ PDMA_ADAPTER DmaAdapter
    );

typedef ULONG (*PREAD_DMA_COUNTER)(
    _In_ PDMA_ADAPTER DmaAdapter
    );

typedef
_Function_class_(DRIVER_LIST_CONTROL)
_IRQL_requires_same_
VOID
DRIVER_LIST_CONTROL(
    _In_ struct _DEVICE_OBJECT *DeviceObject,
    _In_ struct _IRP *Irp,
    _In_ PSCATTER_GATHER_LIST ScatterGather,
    _In_ PVOID Context
    );
typedef DRIVER_LIST_CONTROL *PDRIVER_LIST_CONTROL;

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PMDL Mdl,
    _In_ PVOID CurrentVa,
    _In_ ULONG Length,
    _In_ PDRIVER_LIST_CONTROL ExecutionRoutine,
    _In_ PVOID Context,
    _In_ BOOLEAN WriteToDevice
    );

typedef VOID
(*PPUT_SCATTER_GATHER_LIST)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PSCATTER_GATHER_LIST ScatterGather,
    _In_ BOOLEAN WriteToDevice
    );

typedef NTSTATUS
(*PCALCULATE_SCATTER_GATHER_LIST_SIZE)(
     _In_ PDMA_ADAPTER DmaAdapter,
     _In_ OPTIONAL PMDL Mdl,
     _In_ PVOID CurrentVa,
     _In_ ULONG Length,
     _Out_ PULONG  ScatterGatherListSize,
     _Out_ OPTIONAL PULONG pNumberOfMapRegisters
     );

typedef NTSTATUS
(*PBUILD_SCATTER_GATHER_LIST)(
     _In_ PDMA_ADAPTER DmaAdapter,
     _In_ PDEVICE_OBJECT DeviceObject,
     _In_ PMDL Mdl,
     _In_ PVOID CurrentVa,
     _In_ ULONG Length,
     _In_ PDRIVER_LIST_CONTROL ExecutionRoutine,
     _In_ PVOID Context,
     _In_ BOOLEAN WriteToDevice,
     _In_ PVOID   ScatterGatherBuffer,
     _In_ ULONG   ScatterGatherLength
     );

typedef NTSTATUS
(*PBUILD_MDL_FROM_SCATTER_GATHER_LIST)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PSCATTER_GATHER_LIST ScatterGather,
    _In_ PMDL OriginalMdl,
    _Out_ PMDL *TargetMdl
    );

typedef NTSTATUS
(*PGET_DMA_ADAPTER_INFO)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _Inout_ PDMA_ADAPTER_INFO AdapterInfo
    );

typedef NTSTATUS
(*PGET_DMA_TRANSFER_INFO)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ ULONGLONG Offset,
    _In_ ULONG Length,
    _In_ BOOLEAN WriteOnly,
    _Inout_ PDMA_TRANSFER_INFO TransferInfo
    );

typedef NTSTATUS
(*PCONFIGURE_ADAPTER_CHANNEL)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ ULONG FunctionNumber,
    _In_ PVOID Context
    );

typedef NTSTATUS
(*PINITIALIZE_DMA_TRANSFER_CONTEXT)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _Out_ PVOID DmaTransferContext
    );

typedef PVOID
(*PALLOCATE_COMMON_BUFFER_EX)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_opt_ PPHYSICAL_ADDRESS MaximumAddress,
    _In_ ULONG Length,
    _Out_ PPHYSICAL_ADDRESS LogicalAddress,
    _In_ BOOLEAN CacheEnabled,
    _In_ NODE_REQUIREMENT PreferredNode
    );

typedef NTSTATUS
(*PALLOCATE_ADAPTER_CHANNEL_EX)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID DmaTransferContext,
    _In_ ULONG NumberOfMapRegisters,
    _In_ ULONG Flags,
    _In_opt_ PDRIVER_CONTROL ExecutionRoutine,
    _In_opt_ PVOID ExecutionContext,
    _Out_opt_ PVOID *MapRegisterBase
    );

typedef VOID
_Function_class_(DMA_COMPLETION_ROUTINE)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
DMA_COMPLETION_ROUTINE(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID CompletionContext,
    _In_ DMA_COMPLETION_STATUS Status
    );
typedef DMA_COMPLETION_ROUTINE *PDMA_COMPLETION_ROUTINE;

typedef NTSTATUS
(*PMAP_TRANSFER_EX)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ ULONGLONG Offset,
    _In_ ULONG DeviceOffset,
    _Inout_ PULONG Length,
    _In_ BOOLEAN WriteToDevice,
    _Out_writes_bytes_opt_(ScatterGatherBufferLength) PSCATTER_GATHER_LIST ScatterGatherBuffer,
    _In_ ULONG ScatterGatherBufferLength,
    _In_opt_ PDMA_COMPLETION_ROUTINE DmaCompletionRoutine,
    _In_opt_ PVOID CompletionContext
    );

typedef BOOLEAN
(*PCANCEL_ADAPTER_CHANNEL)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID DmaTransferContext
    );

typedef NTSTATUS
(*PCANCEL_MAPPED_TRANSFER)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PVOID DmaTransferContext
    );

typedef NTSTATUS
(*PFLUSH_ADAPTER_BUFFERS_EX)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ ULONGLONG Offset,
    _In_ ULONG Length,
    _In_ BOOLEAN WriteToDevice
    );

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST_EX)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID DmaTransferContext,
    _In_ PMDL Mdl,
    _In_ ULONGLONG Offset,
    _In_ ULONG Length,
    _In_ ULONG Flags,
    _In_opt_ PDRIVER_LIST_CONTROL ExecutionRoutine,
    _In_opt_ PVOID Context,
    _In_ BOOLEAN WriteToDevice,
    _In_opt_ PDMA_COMPLETION_ROUTINE DmaCompletionRoutine,
    _In_opt_ PVOID CompletionContext,
    _Out_opt_ PSCATTER_GATHER_LIST *ScatterGatherList
    );

typedef NTSTATUS
(*PBUILD_SCATTER_GATHER_LIST_EX)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PVOID DmaTransferContext,
    _In_ PMDL Mdl,
    _In_ ULONGLONG Offset,
    _In_ ULONG Length,
    _In_ ULONG Flags,
    _In_opt_ PDRIVER_LIST_CONTROL ExecutionRoutine,
    _In_opt_ PVOID Context,
    _In_ BOOLEAN WriteToDevice,
    _In_ PVOID ScatterGatherBuffer,
    _In_ ULONG ScatterGatherLength,
    _In_opt_ PDMA_COMPLETION_ROUTINE DmaCompletionRoutine,
    _In_opt_ PVOID CompletionContext,
    _Out_opt_ PVOID ScatterGatherList
    );

typedef NTSTATUS
(*PALLOCATE_DOMAIN_COMMON_BUFFER)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ HANDLE DomainHandle,
    _In_opt_ PPHYSICAL_ADDRESS MaximumAddress,
    _In_ ULONG Length,
    _In_ ULONG Flags,
    _In_opt_ MEMORY_CACHING_TYPE *CacheType,
    _In_ NODE_REQUIREMENT PreferredNode,
    _Out_ PPHYSICAL_ADDRESS LogicalAddress,
    _Out_ PVOID *VirtualAddress
    );

//
// Define the bits in the allocate domain common buffer flags.
//

#define DOMAIN_COMMON_BUFFER_LARGE_PAGE                 0x0001

typedef NTSTATUS
(*PFLUSH_DMA_BUFFER)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ BOOLEAN ReadOperation
);

typedef NTSTATUS
(*PJOIN_DMA_DOMAIN)(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ HANDLE DomainHandle
);

typedef NTSTATUS
(*PLEAVE_DMA_DOMAIN)(
    _In_ PDMA_ADAPTER DmaAdapter
);

typedef HANDLE
(*PGET_DMA_DOMAIN)(
    _In_ PDMA_ADAPTER DmaAdapter
);

// end_nthal

typedef struct _DMA_OPERATIONS {
    ULONG Size;
    PPUT_DMA_ADAPTER PutDmaAdapter;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    PFREE_COMMON_BUFFER FreeCommonBuffer;
    PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
    PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
    PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
    PFREE_MAP_REGISTERS FreeMapRegisters;
    PMAP_TRANSFER MapTransfer;
    PGET_DMA_ALIGNMENT GetDmaAlignment;
    PREAD_DMA_COUNTER ReadDmaCounter;
    PGET_SCATTER_GATHER_LIST GetScatterGatherList;
    PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
    PCALCULATE_SCATTER_GATHER_LIST_SIZE CalculateScatterGatherList;
    PBUILD_SCATTER_GATHER_LIST BuildScatterGatherList;
    PBUILD_MDL_FROM_SCATTER_GATHER_LIST BuildMdlFromScatterGatherList;
    PGET_DMA_ADAPTER_INFO GetDmaAdapterInfo;
    PGET_DMA_TRANSFER_INFO GetDmaTransferInfo;
    PINITIALIZE_DMA_TRANSFER_CONTEXT InitializeDmaTransferContext;
    PALLOCATE_COMMON_BUFFER_EX AllocateCommonBufferEx;
    PALLOCATE_ADAPTER_CHANNEL_EX AllocateAdapterChannelEx;
    PCONFIGURE_ADAPTER_CHANNEL ConfigureAdapterChannel;
    PCANCEL_ADAPTER_CHANNEL CancelAdapterChannel;
    PMAP_TRANSFER_EX MapTransferEx;
    PGET_SCATTER_GATHER_LIST_EX GetScatterGatherListEx;
    PBUILD_SCATTER_GATHER_LIST_EX BuildScatterGatherListEx;
    PFLUSH_ADAPTER_BUFFERS_EX FlushAdapterBuffersEx;
    PFREE_ADAPTER_OBJECT FreeAdapterObject;
    PCANCEL_MAPPED_TRANSFER CancelMappedTransfer;
    PALLOCATE_DOMAIN_COMMON_BUFFER AllocateDomainCommonBuffer;
    PFLUSH_DMA_BUFFER FlushDmaBuffer;
    PJOIN_DMA_DOMAIN JoinDmaDomain;
    PLEAVE_DMA_DOMAIN LeaveDmaDomain;
    PGET_DMA_DOMAIN GetDmaDomain;
} DMA_OPERATIONS;

// begin_nthal
// end_wdm
// begin_ntddk


#if defined(_WIN64) || defined(_ARM_)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64

// end_ntddk end_nthal
// begin_wdm

#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_) // ntddk

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
__drv_preferredFunction("AllocateCommonBuffer","Obsolete")
FORCEINLINE
PVOID
HalAllocateCommonBuffer(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ ULONG Length,
    _Out_ PPHYSICAL_ADDRESS LogicalAddress,
    _In_ BOOLEAN CacheEnabled
    ){

    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;

    allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
    NT_ASSERT( allocateCommonBuffer != NULL );

    commonBuffer = allocateCommonBuffer( DmaAdapter,
                                         Length,
                                         LogicalAddress,
                                         CacheEnabled );

    return commonBuffer;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
__drv_preferredFunction("FreeCommonBuffer","Obsolete")
FORCEINLINE
VOID
HalFreeCommonBuffer(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ ULONG Length,
    _In_ PHYSICAL_ADDRESS LogicalAddress,
    _In_ PVOID VirtualAddress,
    _In_ BOOLEAN CacheEnabled
    ){

    PFREE_COMMON_BUFFER freeCommonBuffer;

    freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
    NT_ASSERT( freeCommonBuffer != NULL );

    freeCommonBuffer( DmaAdapter,
                      Length,
                      LogicalAddress,
                      VirtualAddress,
                      CacheEnabled );
}

DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_min_(DISPATCH_LEVEL)
__drv_preferredFunction("AllocateAdapterChannel","obsolete")
FORCEINLINE
NTSTATUS
IoAllocateAdapterChannel(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG NumberOfMapRegisters,
    _In_ PDRIVER_CONTROL ExecutionRoutine,
    _In_ PVOID Context
    ){

    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    NTSTATUS status;

    allocateAdapterChannel =
        *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;

    NT_ASSERT( allocateAdapterChannel != NULL );

    status = allocateAdapterChannel( DmaAdapter,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

    return status;
}

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
__drv_preferredFunction("FlushAdapterBuffers","Obsolete")
FORCEINLINE
BOOLEAN
IoFlushAdapterBuffers(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ PVOID CurrentVa,
    _In_ ULONG Length,
    _In_ BOOLEAN WriteToDevice
    ){

    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    BOOLEAN result;

    flushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
    NT_ASSERT( flushAdapterBuffers != NULL );

    result = flushAdapterBuffers( DmaAdapter,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );
    return result;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
__drv_preferredFunction("FreeAdapterChannel","Obsolete")
FORCEINLINE
VOID
IoFreeAdapterChannel(
    _In_ PDMA_ADAPTER DmaAdapter
    ){

    PFREE_ADAPTER_CHANNEL freeAdapterChannel;

    freeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
    NT_ASSERT( freeAdapterChannel != NULL );

    freeAdapterChannel( DmaAdapter );
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
__drv_preferredFunction("FreeMapRegisters","Obsolete")
FORCEINLINE
VOID
IoFreeMapRegisters(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PVOID MapRegisterBase,
    _In_ ULONG NumberOfMapRegisters
    ){

    PFREE_MAP_REGISTERS freeMapRegisters;

    freeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
    NT_ASSERT( freeMapRegisters != NULL );

    freeMapRegisters( DmaAdapter,
                      MapRegisterBase,
                      NumberOfMapRegisters );
}


DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
__drv_preferredFunction("MapTransfer","Obsolete")
FORCEINLINE
PHYSICAL_ADDRESS
IoMapTransfer(
    _In_ PDMA_ADAPTER DmaAdapter,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ PVOID CurrentVa,
    _Inout_ PULONG Length,
    _In_ BOOLEAN WriteToDevice
    ){

    PHYSICAL_ADDRESS physicalAddress;
    PMAP_TRANSFER mapTransfer;

    mapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
    NT_ASSERT( mapTransfer != NULL );

    physicalAddress = mapTransfer( DmaAdapter,
                                   Mdl,
                                   MapRegisterBase,
                                   CurrentVa,
                                   Length,
                                   WriteToDevice );

    return physicalAddress;
}

DECLSPEC_DEPRECATED_DDK                 // Use GetDmaAlignment
FORCEINLINE
ULONG
HalGetDmaAlignment(
    _In_ PDMA_ADAPTER DmaAdapter
    )
{
    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG alignment;

    getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
    NT_ASSERT( getDmaAlignment != NULL );

    alignment = getDmaAlignment( DmaAdapter );
    return alignment;
}

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
__drv_preferredFunction("ReadDmaCounter","Obsolete")
FORCEINLINE
ULONG
HalReadDmaCounter(
    _In_ PDMA_ADAPTER DmaAdapter
    )
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG counter;

    readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
    NT_ASSERT( readDmaCounter != NULL );

    counter = readDmaCounter( DmaAdapter );
    return counter;
}

// end_wdm
// begin_ntddk

#else

//
// DMA adapter object functions.
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
NTHALAPI
NTSTATUS
HalAllocateAdapterChannel(
    _In_ PADAPTER_OBJECT AdapterObject,
    _In_ PWAIT_CONTEXT_BLOCK Wcb,
    _In_ ULONG NumberOfMapRegisters,
    _In_ PDRIVER_CONTROL ExecutionRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
__drv_preferredFunction("AllocateCommonBuffer","Obsolete")
NTHALAPI
PVOID
HalAllocateCommonBuffer(
    _In_ PADAPTER_OBJECT AdapterObject,
    _In_ ULONG Length,
    _Out_ PPHYSICAL_ADDRESS LogicalAddress,
    _In_ BOOLEAN CacheEnabled
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
__drv_preferredFunction("FreeCommonBuffer","Obsolete")
NTHALAPI
VOID
HalFreeCommonBuffer(
    _In_ PADAPTER_OBJECT AdapterObject,
    _In_ ULONG Length,
    _In_ PHYSICAL_ADDRESS LogicalAddress,
    _In_ PVOID VirtualAddress,
    _In_ BOOLEAN CacheEnabled
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
__drv_preferredFunction("ReadDmaCounter","Obsolete")
NTHALAPI
ULONG
HalReadDmaCounter(
    _In_ PADAPTER_OBJECT AdapterObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
__drv_preferredFunction("FlushAdapterBuffers","Obsolete")
NTHALAPI
BOOLEAN
IoFlushAdapterBuffers(
    _In_ PADAPTER_OBJECT AdapterObject,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ PVOID CurrentVa,
    _In_ ULONG Length,
    _In_ BOOLEAN WriteToDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
__drv_preferredFunction("FreeAdapterChannel","Obsolete")
NTHALAPI
VOID
IoFreeAdapterChannel(
    _In_ PADAPTER_OBJECT AdapterObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
__drv_preferredFunction("FreeMapRegisters","Obsolete")
NTHALAPI
VOID
IoFreeMapRegisters(
   _In_ PADAPTER_OBJECT AdapterObject,
   _In_ PVOID MapRegisterBase,
   _In_ ULONG NumberOfMapRegisters
   );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
__drv_preferredFunction("MapTransfer","Obsolete")
NTHALAPI
PHYSICAL_ADDRESS
IoMapTransfer(
    _In_ PADAPTER_OBJECT AdapterObject,
    _In_ PMDL Mdl,
    _In_ PVOID MapRegisterBase,
    _In_ PVOID CurrentVa,
    _Inout_ PULONG Length,
    _In_ BOOLEAN WriteToDevice
    );
#endif
// begin_wdm
#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_)

// end_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTSTATUS
HalGetScatterGatherList (               // Use GetScatterGatherList
    _In_ PADAPTER_OBJECT DmaAdapter,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PMDL Mdl,
    _In_ PVOID CurrentVa,
    _In_ ULONG Length,
    _In_ PDRIVER_LIST_CONTROL ExecutionRoutine,
    _In_ PVOID Context,
    _In_ BOOLEAN WriteToDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use PutScatterGatherList
VOID
HalPutScatterGatherList (
    _In_ PADAPTER_OBJECT DmaAdapter,
    _In_ PSCATTER_GATHER_LIST ScatterGather,
    _In_ BOOLEAN WriteToDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use PutDmaAdapter
VOID
HalPutDmaAdapter(
    _In_ PADAPTER_OBJECT DmaAdapter
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _WHEA_ERROR_SOURCE_DESCRIPTOR *PWHEA_ERROR_SOURCE_DESCRIPTOR;
typedef struct _WHEA_ERROR_RECORD *PWHEA_ERROR_RECORD;

NTHALAPI
VOID
HalBugCheckSystem (
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _In_ PWHEA_ERROR_RECORD ErrorRecord
    );

#elif (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _WHEA_ERROR_RECORD *PWHEA_ERROR_RECORD;

NTHALAPI
VOID
HalBugCheckSystem (
    _In_ PWHEA_ERROR_RECORD ErrorRecord
    );

#endif

//
//  Security operation codes
//

typedef enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor,
    QuerySecurityDescriptor,
    DeleteSecurityDescriptor,
    AssignSecurityDescriptor
    } SECURITY_OPERATION_CODE, *PSECURITY_OPERATION_CODE;

//
//  Data structure used to capture subject security context
//  for access validations and auditing.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_SUBJECT_CONTEXT {
    PACCESS_TOKEN ClientToken;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN PrimaryToken;
    PVOID ProcessAuditId;
    } SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                  ACCESS_STATE and related structures                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  Initial Privilege Set - Room for three privileges, which should
//  be enough for most applications.  This structure exists so that
//  it can be imbedded in an ACCESS_STATE structure.  Use PRIVILEGE_SET
//  for all other references to Privilege sets.
//

#define INITIAL_PRIVILEGE_COUNT         3

typedef struct _INITIAL_PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[INITIAL_PRIVILEGE_COUNT];
    } INITIAL_PRIVILEGE_SET, * PINITIAL_PRIVILEGE_SET;



//
// Combine the information that describes the state
// of an access-in-progress into a single structure
//


typedef struct _ACCESS_STATE {
   LUID OperationID;                // Currently unused, replaced by TransactionId in AUX_ACCESS_DATA
   BOOLEAN SecurityEvaluated;
   BOOLEAN GenerateAudit;
   BOOLEAN GenerateOnClose;
   BOOLEAN PrivilegesAllocated;
   ULONG Flags;
   ACCESS_MASK RemainingDesiredAccess;
   ACCESS_MASK PreviouslyGrantedAccess;
   ACCESS_MASK OriginalDesiredAccess;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
   PSECURITY_DESCRIPTOR SecurityDescriptor; // it stores SD supplied by caller when creating a new object.
   PVOID AuxData;
   union {
      INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
      PRIVILEGE_SET PrivilegeSet;
      } Privileges;

   BOOLEAN AuditPrivileges;
   UNICODE_STRING ObjectName;
   UNICODE_STRING ObjectTypeName;

   } ACCESS_STATE, *PACCESS_STATE;


typedef VOID
(*PNTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR)(
    _In_ PVOID  Vcb,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);


typedef struct _AUX_ACCESS_DATA {
    PPRIVILEGE_SET PrivilegesUsed;
    GENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessesToAudit;
    ACCESS_MASK MaximumAuditMask;
    GUID TransactionId;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor; // The new SD for a new object.
    PSECURITY_DESCRIPTOR ExistingSecurityDescriptor; // The exisiting SD that has been passed into SeAccessCheck.
    PSECURITY_DESCRIPTOR ParentSecurityDescriptor; // The parent SD that has been passed into SeAccessCheck to check delete and read attribute.
    PNTFS_DEREF_EXPORTED_SECURITY_DESCRIPTOR DeRefSecurityDescriptor;
    PVOID SDLock;
    ACCESS_REASONS AccessReasons;
    BOOLEAN GenerateStagingEvents;
} AUX_ACCESS_DATA, *PAUX_ACCESS_DATA;

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
SeAccessCheckWithHint(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG SecurityDescriptorFlags,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ BOOLEAN SubjectContextLocked,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK PreviouslyGrantedAccess,
    _Outptr_opt_ PPRIVILEGE_SET *Privileges,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
SeAccessCheckEx(
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ BOOLEAN SubjectContextLocked,
    _Inout_ PSE_ACCESS_REQUEST Request,
    _Inout_ PSE_ACCESS_REPLY Reply,
    _Inout_opt_ PSE_AUDIT_INFO AuditInfo,
    _In_ KPROCESSOR_MODE AccessMode
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
SeSrpAccessCheck(
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ BOOLEAN SubjectContextLocked,
    _Inout_ PSE_ACCESS_REQUEST Request,
    _Inout_ PSE_ACCESS_REPLY Reply,
    _Inout_opt_ PSE_AUDIT_INFO AuditInfo,
    _In_ KPROCESSOR_MODE AccessMode
    );

#endif

FORCEINLINE
VOID
SeSetAccessStateNewSecurityDescriptor(
    _Inout_ PACCESS_STATE AccessState,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    Updates ACCESS_STATE structure with updated through inheritance security
    descriptor.

Arguments:

    AccessState - Pointer to ACCESS_STATE structure.

    SecurityDescriptor - Pointer to inherited security descriptor.

Return Value:

    None

--*/
{
    PAUX_ACCESS_DATA AuxData = (PAUX_ACCESS_DATA)(AccessState->AuxData);

    if (AuxData->NewSecurityDescriptor != NULL)
    {
        ExFreePool(AuxData->NewSecurityDescriptor);
    }
    AuxData->NewSecurityDescriptor = SecurityDescriptor;
}


typedef struct _SE_EXPORTS {

    //
    // Privilege values
    //

    LUID    SeCreateTokenPrivilege;
    LUID    SeAssignPrimaryTokenPrivilege;
    LUID    SeLockMemoryPrivilege;
    LUID    SeIncreaseQuotaPrivilege;
    LUID    SeUnsolicitedInputPrivilege;
    LUID    SeTcbPrivilege;
    LUID    SeSecurityPrivilege;
    LUID    SeTakeOwnershipPrivilege;
    LUID    SeLoadDriverPrivilege;
    LUID    SeCreatePagefilePrivilege;
    LUID    SeIncreaseBasePriorityPrivilege;
    LUID    SeSystemProfilePrivilege;
    LUID    SeSystemtimePrivilege;
    LUID    SeProfileSingleProcessPrivilege;
    LUID    SeCreatePermanentPrivilege;
    LUID    SeBackupPrivilege;
    LUID    SeRestorePrivilege;
    LUID    SeShutdownPrivilege;
    LUID    SeDebugPrivilege;
    LUID    SeAuditPrivilege;
    LUID    SeSystemEnvironmentPrivilege;
    LUID    SeChangeNotifyPrivilege;
    LUID    SeRemoteShutdownPrivilege;


    //
    // Universally defined Sids
    //


    PSID  SeNullSid;
    PSID  SeWorldSid;
    PSID  SeLocalSid;
    PSID  SeCreatorOwnerSid;
    PSID  SeCreatorGroupSid;


    //
    // Nt defined Sids
    //


    PSID  SeNtAuthoritySid;
    PSID  SeDialupSid;
    PSID  SeNetworkSid;
    PSID  SeBatchSid;
    PSID  SeInteractiveSid;
    PSID  SeLocalSystemSid;
    PSID  SeAliasAdminsSid;
    PSID  SeAliasUsersSid;
    PSID  SeAliasGuestsSid;
    PSID  SeAliasPowerUsersSid;
    PSID  SeAliasAccountOpsSid;
    PSID  SeAliasSystemOpsSid;
    PSID  SeAliasPrintOpsSid;
    PSID  SeAliasBackupOpsSid;

    //
    // New Sids defined for NT5
    //

    PSID  SeAuthenticatedUsersSid;

    PSID  SeRestrictedSid;
    PSID  SeAnonymousLogonSid;

    //
    // New Privileges defined for NT5
    //

    LUID  SeUndockPrivilege;
    LUID  SeSyncAgentPrivilege;
    LUID  SeEnableDelegationPrivilege;

    //
    // New Sids defined for post-Windows 2000

    PSID  SeLocalServiceSid;
    PSID  SeNetworkServiceSid;

    //
    // New Privileges defined for post-Windows 2000
    //

    LUID  SeManageVolumePrivilege;
    LUID  SeImpersonatePrivilege;
    LUID  SeCreateGlobalPrivilege;

    //
    // New Privileges defined for post Windows Server 2003
    //

    LUID  SeTrustedCredManAccessPrivilege;
    LUID  SeRelabelPrivilege;
    LUID  SeIncreaseWorkingSetPrivilege;

    LUID  SeTimeZonePrivilege;
    LUID  SeCreateSymbolicLinkPrivilege;

    //
    // New Sids defined for post Windows Server 2003
    //

    PSID  SeIUserSid;

    //
    // Mandatory Sids, ordered lowest to highest.
    //

    PSID SeUntrustedMandatorySid;
    PSID SeLowMandatorySid;
    PSID SeMediumMandatorySid;
    PSID SeHighMandatorySid;
    PSID SeSystemMandatorySid;

    PSID SeOwnerRightsSid;

    //
    // Package/Capability Sids.
    //

    PSID SeAllAppPackagesSid;
    PSID SeUserModeDriversSid;

    //
    // Trusted Installer SID.
    //

    PSID SeTrustedInstallerSid;

} SE_EXPORTS, *PSE_EXPORTS;

#define SeDeleteClientSecurity(C)  {                                           \
            if (SeTokenType((C)->ClientToken) == TokenPrimary) {               \
                PsDereferencePrimaryToken( (C)->ClientToken );                 \
            } else {                                                           \
                PsDereferenceImpersonationToken( (C)->ClientToken );           \
            }                                                                  \
        }


//++
//VOID
//SeStopImpersonatingClient()
//
///*++
//
//Routine Description:
//
//    This service is used to stop impersonating a client using an
//    impersonation token.  This service must be called in the context
//    of the server thread which wishes to stop impersonating its
//    client.
//
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//--

#define SeStopImpersonatingClient() PsRevertToSelf()


//++
//
//  PACCESS_TOKEN
//  SeQuerySubjectContextToken(
//      _In_ PSECURITY_SUBJECT_CONTEXT SubjectContext
//      );
//
//  Routine Description:
//
//      This routine returns the effective token from the subject context,
//      either the client token, if present, or the process token.
//
//  Arguments:
//
//      SubjectContext - Context to query
//
//  Return Value:
//
//      This routine returns the PACCESS_TOKEN for the effective token.
//      The pointer may be passed to SeQueryInformationToken.  This routine
//      does not affect the lock status of the token, i.e. the token is not
//      locked.  If the SubjectContext has been locked, the token remains locked,
//      if not, the token remains unlocked.
//
//--

#define SeQuerySubjectContextToken( SubjectContext ) \
        ( ARGUMENT_PRESENT( ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken) ? \
            ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->ClientToken : \
            ((PSECURITY_SUBJECT_CONTEXT) SubjectContext)->PrimaryToken )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeCaptureSecurityDescriptor (
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _In_ KPROCESSOR_MODE RequestorMode,
    _In_ POOL_TYPE PoolType,
    _In_ BOOLEAN ForceCapture,
    _Outptr_ PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeReleaseSecurityDescriptor (
    _In_ PSECURITY_DESCRIPTOR CapturedSecurityDescriptor,
    _In_ KPROCESSOR_MODE RequestorMode,
    _In_ BOOLEAN ForceCapture
    );
#endif

// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeCaptureSubjectContextEx (
    _In_opt_ PETHREAD Thread,
    _In_ PEPROCESS Process,
    _Out_ PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeCaptureSubjectContext (
    _Out_ PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeLockSubjectContext(
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeUnlockSubjectContext(
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeReleaseSubjectContext (
    _Inout_ PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
SeAssignSecurity (
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ExplicitDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectContext,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ POOL_TYPE PoolType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
ULONG
SeComputeAutoInheritByObjectType(
    _In_ PVOID ObjectType,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ParentSecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeAssignSecurityEx (
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ExplicitDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *NewDescriptor,
    _In_opt_ GUID *ObjectType,
    _In_ BOOLEAN IsDirectoryObject,
    _In_ ULONG AutoInheritFlags,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectContext,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ POOL_TYPE PoolType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
SeDeassignSecurity (
    _Inout_ PSECURITY_DESCRIPTOR *SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
SeObjectCreateSaclAccessBits(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
SeAccessCheck (
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ BOOLEAN SubjectContextLocked,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK PreviouslyGrantedAccess,
    _Outptr_opt_ PPRIVILEGE_SET *Privileges,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );
#endif


#ifdef SE_NTFS_WORLD_CACHE

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
SeGetWorldRights (
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_ PACCESS_MASK GrantedAccess
    );
#endif

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
_At_(AuditParameters->ParameterCount, _Const_)
NTSTATUS
SeSetAuditParameter(
    _Inout_ PSE_ADT_PARAMETER_ARRAY AuditParameters,
    _In_ SE_ADT_PARAMETER_TYPE Type,
    _In_range_(<,SE_MAX_AUDIT_PARAMETERS) ULONG Index,
    _In_reads_(_Inexpressible_("depends on SE_ADT_PARAMETER_TYPE")) PVOID Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSTATUS
SeReportSecurityEvent(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING SourceName,
    _In_opt_ PSID UserSid,
    _In_ PSE_ADT_PARAMETER_ARRAY AuditParameters
    );
#endif

// end_wdm

// begin_ntifs

NTSTATUS
SeReportSecurityEventWithSubCategory(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING SourceName,
    _In_opt_ PSID UserSid,
    _In_ PSE_ADT_PARAMETER_ARRAY AuditParameters,
    _In_ ULONG AuditSubcategoryId
    );

BOOLEAN
SeAccessCheckFromState (
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PTOKEN_ACCESS_INFORMATION PrimaryTokenInformation,
    _In_opt_ PTOKEN_ACCESS_INFORMATION ClientTokenInformation,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK PreviouslyGrantedAccess,
    _Outptr_opt_result_maybenull_ PPRIVILEGE_SET *Privileges,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );

#if (NTDDI_VERSION >= NTDDI_WIN8)
BOOLEAN
SeAccessCheckFromStateEx (
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PACCESS_TOKEN PrimaryToken,
    _In_opt_ PACCESS_TOKEN ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK PreviouslyGrantedAccess,
    _Outptr_opt_result_maybenull_ PPRIVILEGE_SET *Privileges,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTSTATUS
SeTokenFromAccessInformation(
    _In_opt_ PTOKEN_ACCESS_INFORMATION AccessInformation,
    _Inout_opt_ PACCESS_TOKEN Token,
    _In_ ULONG Length,
    _Out_ PULONG RequiredLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SePrivilegeCheck(
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ KPROCESSOR_MODE AccessMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeFreePrivileges(
    _In_ PPRIVILEGE_SET Privileges
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeOpenObjectAuditAlarm (
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_opt_ PVOID Object,
    _In_opt_ PUNICODE_STRING AbsoluteObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PACCESS_STATE AccessState,
    _In_ BOOLEAN ObjectCreated,
    _In_ BOOLEAN AccessGranted,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeOpenObjectAuditAlarmWithTransaction (
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_opt_ PVOID Object,
    _In_opt_ PUNICODE_STRING AbsoluteObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PACCESS_STATE AccessState,
    _In_ BOOLEAN ObjectCreated,
    _In_ BOOLEAN AccessGranted,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_opt_ GUID *TransactionId,
    _Out_ PBOOLEAN GenerateOnClose
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeOpenObjectForDeleteAuditAlarm (
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_opt_ PVOID Object,
    _In_opt_ PUNICODE_STRING AbsoluteObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PACCESS_STATE AccessState,
    _In_ BOOLEAN ObjectCreated,
    _In_ BOOLEAN AccessGranted,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PBOOLEAN GenerateOnClose
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeOpenObjectForDeleteAuditAlarmWithTransaction (
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_opt_ PVOID Object,
    _In_opt_ PUNICODE_STRING AbsoluteObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PACCESS_STATE AccessState,
    _In_ BOOLEAN ObjectCreated,
    _In_ BOOLEAN AccessGranted,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_opt_ GUID *TransactionId,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTKERNELAPI
VOID
SeExamineSacl(
    _In_ PACL Sacl,
    _In_ PACL ResourceSacl,
    _In_ PACCESS_TOKEN Token,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateAudit,
    _Out_ PBOOLEAN GenerateAlarm
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeDeleteObjectAuditAlarm(
    _In_ PVOID Object,
    _In_ HANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeDeleteObjectAuditAlarmWithTransaction(
    _In_ PVOID Object,
    _In_ HANDLE Handle,
    _In_opt_ GUID *TransactionId
    );



#endif

// end_ntifs

NTKERNELAPI
VOID
SePrivilegeObjectAuditAlarm(
    _In_ HANDLE Handle,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted,
    _In_ KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
VOID
SeOpenObjectAuditAlarmForNonObObject(
    _In_ PUNICODE_STRING SubsystemName,
    _In_opt_ PVOID HandleId,
    _In_ PUNICODE_STRING ObjectTypeName,
    _In_opt_ PUNICODE_STRING ObjectName,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ACCESS_MASK GrantedAccess,
    _In_opt_ PPRIVILEGE_SET Privileges,
    _In_ BOOLEAN AccessGranted,
    _Out_ PBOOLEAN GenerateOnClose
    );

NTKERNELAPI
VOID
SeCloseObjectAuditAlarmForNonObObject(
    _In_ PUNICODE_STRING SubsystemName,
    _In_ PVOID HandleId,
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    _In_ BOOLEAN GenerateOnClose
    );

extern struct _OBJECT_TYPE *SeTokenObjectType;

#if (NTDDI_VERSION >= NTDDI_WIN2K)              // ntifs
NTKERNELAPI                                     // ntifs
TOKEN_TYPE                                      // ntifs
SeTokenType(                                    // ntifs
    _In_ PACCESS_TOKEN Token                    // ntifs
    );                                          // ntifs
#endif                                          // ntifs

SECURITY_IMPERSONATION_LEVEL
SeTokenImpersonationLevel(
    _In_ PACCESS_TOKEN Token
    );

// begin_ntifs
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeTokenIsAdmin(
    _In_ PACCESS_TOKEN Token
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeTokenIsRestricted(
    _In_ PACCESS_TOKEN Token
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || (NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_WS03))
NTKERNELAPI
BOOLEAN
SeTokenIsWriteRestricted(
    _In_ PACCESS_TOKEN Token
    );
#endif
// end_ntifs

NTKERNELAPI
NTSTATUS
SeGetLinkedToken(
    _In_ TOKEN_ELEVATION_TYPE Type,
    _In_ PACCESS_TOKEN Token,
    _Outptr_ PACCESS_TOKEN *NewToken
    );

NTKERNELAPI
NTSTATUS
SeTokenCanImpersonate(
    _In_ PACCESS_TOKEN ProcessToken,
    _In_ PACCESS_TOKEN Token,
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    _Out_ PBOOLEAN UseProcessTrust
    );
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeQueryAuthenticationIdToken(
    _In_ PACCESS_TOKEN Token,
    _Out_ PLUID AuthenticationId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
SeQueryTokenIntegrity(
    _In_ PACCESS_TOKEN Token,
    _Inout_ PSID_AND_ATTRIBUTES IntegritySA
    );
#endif
#if (NTDDI_VERSION >= NTDDI_THRESHOLD)
// Silo Support
// Return the ServerSilo the Token's logon session is associated with
// No Reference increment is done on the ServerSilo by this routine
NTKERNELAPI
NTSTATUS
SeQueryServerSiloToken(
    _In_ PACCESS_TOKEN Token,
    _Out_ PESILO *pServerSilo
    );

#endif
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeCreateClientSecurity (
    _In_ PETHREAD ClientThread,
    _In_ PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    _In_ BOOLEAN RemoteSession,
    _Out_ PSECURITY_CLIENT_CONTEXT ClientContext
    );
#endif
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeImpersonateClientEx(
    _In_ PSECURITY_CLIENT_CONTEXT ClientContext,
    _In_opt_ PETHREAD ServerThread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeCreateClientSecurityFromSubjectContext (
    _In_ PSECURITY_SUBJECT_CONTEXT SubjectContext,
    _In_ PSECURITY_QUALITY_OF_SERVICE ClientSecurityQos,
    _In_ BOOLEAN ServerIsRemote,
    _Out_ PSECURITY_CLIENT_CONTEXT ClientContext
    );
#endif

// end_ntifs
NTKERNELAPI
NTSTATUS
SeCreateAccessState(
   _Out_ PACCESS_STATE AccessState,
   _Out_ PAUX_ACCESS_DATA AuxData,
   _In_ ACCESS_MASK DesiredAccess,
   _In_ PGENERIC_MAPPING GenericMapping
   );

NTSTATUS
SeCreateAccessStateEx(
   _In_opt_ PETHREAD Thread,
   _In_ PEPROCESS Process,
   _Out_ PACCESS_STATE AccessState,
   _Out_ PAUX_ACCESS_DATA AuxData,
   _In_ ACCESS_MASK DesiredAccess,
   _In_opt_ PGENERIC_MAPPING GenericMapping
   );

NTKERNELAPI
VOID
SeDeleteAccessState(
    _In_ PACCESS_STATE AccessState
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeQuerySecurityDescriptorInfo (
    _In_ PSECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_(*Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Inout_ PULONG Length,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfo (
    _In_opt_ PVOID Object,
    _In_ PSECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR ModificationDescriptor,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ POOL_TYPE PoolType,
    _In_ PGENERIC_MAPPING GenericMapping
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfoEx (
    _In_opt_ PVOID Object,
    _In_ PSECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR ModificationDescriptor,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ ULONG AutoInheritFlags,
    _In_ POOL_TYPE PoolType,
    _In_ PGENERIC_MAPPING GenericMapping
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeAppendPrivileges(
    _Inout_ PACCESS_STATE AccessState,
    _In_ PPRIVILEGE_SET Privileges
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
SeSinglePrivilegeCheck(
    _In_ LUID PrivilegeValue,
    _In_ KPROCESSOR_MODE PreviousMode
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define QUERY_TYPE_ULONG(TokenInformationClass) TokenInformationClass == TokenIntegrityLevel        || \
                                                TokenInformationClass == TokenIsAppContainer        || \
                                                TokenInformationClass == TokenVirtualizationAllowed || \
                                                TokenInformationClass == TokenVirtualizationEnabled || \
                                                TokenInformationClass == TokenUIAccess              || \
                                                TokenInformationClass == TokenSessionId             || \
                                                TokenInformationClass == TokenHasRestrictions       || \
                                                TokenInformationClass == TokenAppContainerNumber    || \
                                                TokenInformationClass == TokenPrivateNameSpace

_When_(QUERY_TYPE_ULONG(TokenInformationClass), _At_((PULONG)TokenInformation, _Out_))
_When_(!QUERY_TYPE_ULONG(TokenInformationClass), _At_(TokenInformation, _Outptr_result_buffer_(_Inexpressible_(token-dependent))))
NTKERNELAPI
NTSTATUS
SeQueryInformationToken (
    _In_ PACCESS_TOKEN Token,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
         PVOID *TokenInformation
    );
#endif


NTSTATUS
SeLocateProcessImageName(
    _Inout_ PEPROCESS Process,
    _Outptr_ PUNICODE_STRING *pImageFileName
    );

//
//  Grants access to SeExports structure
//

extern NTKERNELAPI PSE_EXPORTS SeExports;


#if (NTDDI_VERSION >= NTDDI_WIN7)

NTKERNELAPI
VOID
SeExamineGlobalSacl(
    _In_ PUNICODE_STRING ObjectType,
    _In_ PACL ResourceSacl,
    _In_ PACCESS_TOKEN Token,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN AccessGranted,
    _Inout_ PBOOLEAN GenerateAudit,
    _Inout_opt_ PBOOLEAN GenerateAlarm
);

NTKERNELAPI
VOID
SeMaximumAuditMaskFromGlobalSacl(
    _In_opt_ PUNICODE_STRING ObjectTypeName,
    _In_ ACCESS_MASK GrantedAccess,
    _In_ PACCESS_TOKEN Token,
    _Inout_ PACCESS_MASK AuditMask
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
BOOLEAN
FASTCALL
SeAuditingWithTokenForSubcategory(
    _In_ ULONG Subcategory,
    _In_opt_ PACCESS_TOKEN AccessToken
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
BOOLEAN
SeSecurityAttributePresent(
    _In_ PACCESS_TOKEN AccessToken,
    _In_ PCUNICODE_STRING Name);

#endif
#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
SeGetLogonSessionToken(
    _In_ HANDLE TokenHandle,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PHANDLE LogonSessionToken
    );
#endif
#if (NTDDI_VERSION >= NTDDI_THRESHOLD)
NTKERNELAPI
NTSTATUS
SeAssignProcessToServerSilo(
    _In_ PESILO DestServerSilo,
    _In_ PEPROCESS Process
    );
#endif
#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
NTSTATUS
SeQuerySecureBootPolicyValue(
    _In_ PCUNICODE_STRING ValuePath,
    _In_ PCUNICODE_STRING ValueName,
    _In_ ULONG ValueType,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize
    );
#endif
#if (NTDDI_VERSION >= NTDDI_WINBLUE)
NTKERNELAPI
BOOLEAN
SeIsParentOfChildAppContainer(
    _In_ ULONG SessionId,
    _In_ ULONG LowboxNumber1,
    _In_ ULONG LowboxNumber2
    );
#endif


//
// Types of images.
//

typedef enum _SE_IMAGE_TYPE
{
  SeImageTypeElamDriver = 0,
  SeImageTypeDriver,
  SeImageTypeMax
} SE_IMAGE_TYPE, *PSE_IMAGE_TYPE;

typedef struct _BDCB_IMAGE_INFORMATION *PBDCB_IMAGE_INFORMATION;

typedef
_IRQL_requires_same_
_Function_class_(SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION)
VOID
SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION (
    _In_opt_ PVOID CallbackContext,
    _In_ SE_IMAGE_TYPE ImageType,
    _Inout_ PBDCB_IMAGE_INFORMATION ImageInformation
    );

typedef SE_IMAGE_VERIFICATION_CALLBACK_FUNCTION *PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION;

typedef enum _SE_IMAGE_VERIFICATION_CALLBACK_TYPE {
    SeImageVerificationCallbackInformational = 0
} SE_IMAGE_VERIFICATION_CALLBACK_TYPE, *PSE_IMAGE_VERIFICATION_CALLBACK_TYPE;

typedef PVOID SE_IMAGE_VERIFICATION_CALLBACK_TOKEN, *PSE_IMAGE_VERIFICATION_CALLBACK_TOKEN;

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
SeRegisterImageVerificationCallback(
    _In_ SE_IMAGE_TYPE ImageType,
    _In_ SE_IMAGE_VERIFICATION_CALLBACK_TYPE CallbackType,
    _In_ PSE_IMAGE_VERIFICATION_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID CallbackContext,
    _Reserved_ SE_IMAGE_VERIFICATION_CALLBACK_TOKEN Token,
    _Out_ PVOID* CallbackHandle
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
SeUnregisterImageVerificationCallback (
    _In_ PVOID CallbackHandle
    );
#endif


//
// Max length and count of EKU strings that can be passed in a single call to
// SeRegisterCodeIntegritySigningInformation.
//

#define SE_CODE_INTEGRITY_MAX_EKU_LENGTH 64
#define SE_CODE_INTEGRITY_MAX_EKU_COUNT 3

//
// Flag for SeQuerySigningPolicy to indicate process creation is requested to
// be protected.
//

#define SE_POLICY_PROTECTED_IMAGE 0x1


#define PCW_VERSION_1 0x0100
#define PCW_CURRENT_VERSION PCW_VERSION_1

typedef struct _PCW_INSTANCE *PPCW_INSTANCE;
typedef struct _PCW_REGISTRATION *PPCW_REGISTRATION;
typedef struct _PCW_BUFFER *PPCW_BUFFER;

typedef struct _PCW_COUNTER_DESCRIPTOR {
    USHORT Id;
    USHORT StructIndex;
    USHORT Offset;
    USHORT Size;
} PCW_COUNTER_DESCRIPTOR, *PPCW_COUNTER_DESCRIPTOR;

typedef struct _PCW_DATA {
    _In_reads_bytes_(Size) const VOID *Data;
    _In_ ULONG Size;
} PCW_DATA, *PPCW_DATA;

typedef struct _PCW_COUNTER_INFORMATION {
    ULONG64 CounterMask;
    PCUNICODE_STRING InstanceMask;
} PCW_COUNTER_INFORMATION, *PPCW_COUNTER_INFORMATION;

typedef struct _PCW_MASK_INFORMATION {
    ULONG64 CounterMask;
    PCUNICODE_STRING InstanceMask;
    ULONG InstanceId;
    BOOLEAN CollectMultiple;
    PPCW_BUFFER Buffer;
    PKEVENT CancelEvent;
} PCW_MASK_INFORMATION, *PPCW_MASK_INFORMATION;

typedef union _PCW_CALLBACK_INFORMATION {
    PCW_COUNTER_INFORMATION AddCounter;
    PCW_COUNTER_INFORMATION RemoveCounter;
    PCW_MASK_INFORMATION EnumerateInstances;
    PCW_MASK_INFORMATION CollectData;
} PCW_CALLBACK_INFORMATION, *PPCW_CALLBACK_INFORMATION;

typedef enum _PCW_CALLBACK_TYPE {
    PcwCallbackAddCounter = 0,
    PcwCallbackRemoveCounter,
    PcwCallbackEnumerateInstances,
    PcwCallbackCollectData,
} PCW_CALLBACK_TYPE, *PPCW_CALLBACK_TYPE;

typedef
NTSTATUS NTAPI
PCW_CALLBACK(
    _In_ PCW_CALLBACK_TYPE Type,
    _In_ PPCW_CALLBACK_INFORMATION Info,
    _In_opt_ PVOID Context
    );

typedef PCW_CALLBACK *PPCW_CALLBACK;

typedef struct _PCW_REGISTRATION_INFORMATION {
    _In_ ULONG Version;
    _In_ PCUNICODE_STRING Name;
    _In_ ULONG CounterCount;
    _In_reads_(CounterCount) PPCW_COUNTER_DESCRIPTOR Counters;
    _In_opt_ PPCW_CALLBACK Callback;
    _In_opt_ PVOID CallbackContext;
} PCW_REGISTRATION_INFORMATION, *PPCW_REGISTRATION_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
NTAPI
PcwRegister(
    _Outptr_ PPCW_REGISTRATION *Registration,
    _In_ PPCW_REGISTRATION_INFORMATION Info
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
VOID
NTAPI
PcwUnregister(
    _In_ PPCW_REGISTRATION Registration
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
NTAPI
PcwCreateInstance(
    _Outptr_ PPCW_INSTANCE *Instance,
    _In_ PPCW_REGISTRATION Registration,
    _In_ PCUNICODE_STRING Name,
    _In_ ULONG Count,
    _In_reads_(Count) PPCW_DATA Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
VOID
NTAPI
PcwCloseInstance(
    _In_ PPCW_INSTANCE Instance
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
NTAPI
PcwAddInstance(
    _In_ PPCW_BUFFER Buffer,
    _In_ PCUNICODE_STRING Name,
    _In_ ULONG Id,
    _In_ ULONG Count,
    _In_reads_(Count) PPCW_DATA Data
    );
#endif

// end_wdm

typedef
NTSTATUS
NTAPI
PCW_REGISTER_PROC(
    _Outptr_ PPCW_REGISTRATION *Registration,
    _In_ PPCW_REGISTRATION_INFORMATION Info
    );

typedef
VOID
NTAPI
PCW_UNREGISTER_PROC(
    _In_ PPCW_REGISTRATION Registration
    );

typedef
NTSTATUS
NTAPI
PCW_CREATE_INSTANCE_PROC(
    _Outptr_ PPCW_INSTANCE *Instance,
    _In_ PPCW_REGISTRATION Registration,
    _In_ PCUNICODE_STRING Name,
    _In_ ULONG Count,
    _In_reads_(Count) PPCW_DATA Data
    );

typedef
VOID
NTAPI
PCW_CLOSE_INSTANCE_PROC(
    _In_ PPCW_INSTANCE Instance
    );

typedef
NTSTATUS
NTAPI
PCW_ADD_INSTANCE_PROC(
    _In_ PPCW_BUFFER Buffer,
    _In_ PCUNICODE_STRING Name,
    _In_ ULONG Id,
    _In_ ULONG Count,
    _In_reads_(Count) PPCW_DATA Data
    );

typedef struct _PCW_CALLBACK_TABLE {
    PCW_REGISTER_PROC *Register;
    PCW_UNREGISTER_PROC *Unregister;
    PCW_CREATE_INSTANCE_PROC *CreateInstance;
    PCW_CLOSE_INSTANCE_PROC *CloseInstance;
    PCW_ADD_INSTANCE_PROC *AddInstance;
} PCW_CALLBACK_TABLE, *PPCW_CALLBACK_TABLE;


#define PO_FIXED_WAKE_SOURCE_POWER_BUTTON 0x00000001
#define PO_FIXED_WAKE_SOURCE_SLEEP_BUTTON 0x00000002
#define PO_FIXED_WAKE_SOURCE_RTC          0x00000004
#define PO_FIXED_WAKE_SOURCE_AC_ALARM     0x00000008
#define PO_FIXED_WAKE_SOURCE_DC_ALARM     0x00000010

VOID
PoSetFixedWakeSource (
    _In_ ULONG WakeMask
    );


NTKERNELAPI
VOID
PoSetHiberRange (
    _In_opt_ PVOID MemoryMap,
    _In_ ULONG     Flags,
    _In_ PVOID     Address,
    _In_ ULONG_PTR Length,
    _In_ ULONG     Tag
    );

// memory_range.Type
#define PO_MEM_PRESERVE         0x00000001      // memory range needs preserved
#define PO_MEM_CLONE            0x00000002      // Clone this range
#define PO_MEM_CL_OR_NCHK       0x00000004      // Either clone or do not checksum
#define PO_MEM_DISCARD          0x00008000      // This range to be removed
#define PO_MEM_PAGE_ADDRESS     0x00004000      // Arguments passed are physical pages
#define PO_MEM_BOOT_PHASE       0x00010000


_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoDisableSleepStates (
    _In_ PO_SLEEP_DISABLE_REASON Reason,
    _In_ ULONG SleepMask,
    _Outptr_ PVOID *Token
    );

NTKERNELAPI
_IRQL_requires_max_(APC_LEVEL)
VOID
PoReenableSleepStates (
    _In_ PVOID Token
    );

//
// Callback definition for shutdown notification request. This is registered
// via ZwPowerInformation.
//

typedef
_Function_class_(POSHUTDOWNNOTIFICATIONFUNC)
VOID
POSHUTDOWNNOTIFICATIONFUNC (
    _Inout_opt_ PVOID Context
    );

typedef POSHUTDOWNNOTIFICATIONFUNC *PPOSHUTDOWNNOTIFICATIONFUNC;

typedef struct _PO_SHUTDOWN_NOTIFICATION {
    PPOSHUTDOWNNOTIFICATIONFUNC Callback;
    PVOID Context;
} PO_SHUTDOWN_NOTIFICATION, *PPO_SHUTDOWN_NOTIFICATION;

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PoUserShutdownInitiated (
    VOID
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PoUserShutdownCancelled (
    VOID
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoRequestShutdownEvent(
    _Outptr_opt_ PVOID *Event
    );

NTKERNELAPI
BOOLEAN
PoCpuIdledSinceLastCallImprecise(
    _In_ ULONG ProcessorNumber,
    _Inout_ PULONGLONG IdleTimeReturned
    );

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoSetUserPresent (
    _In_ POWER_MONITOR_REQUEST_REASON RequestReason
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoSetSystemState (
    _In_ EXECUTION_STATE Flags
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PVOID
PoRegisterSystemState (
    _Inout_opt_ PVOID StateHandle,
    _In_ EXECUTION_STATE Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoCreatePowerRequest (
    _Outptr_ PVOID *PowerRequest,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_opt_ PCOUNTED_REASON_CONTEXT Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PoSetPowerRequest (
    _Inout_ PVOID PowerRequest,
    _In_ POWER_REQUEST_TYPE Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PoClearPowerRequest (
    _Inout_ PVOID PowerRequest,
    _In_ POWER_REQUEST_TYPE Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PoDeletePowerRequest (
    _Inout_ PVOID PowerRequest
    );
#endif


typedef
_Function_class_(REQUEST_POWER_COMPLETE)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_same_
VOID
REQUEST_POWER_COMPLETE (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ UCHAR MinorFunction,
    _In_ POWER_STATE PowerState,
    _In_opt_ PVOID Context,
    _In_ PIO_STATUS_BLOCK IoStatus
    );

typedef REQUEST_POWER_COMPLETE *PREQUEST_POWER_COMPLETE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PoRequestPowerIrp (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ UCHAR MinorFunction,
    _In_ POWER_STATE PowerState,
    _In_opt_ PREQUEST_POWER_COMPLETE CompletionFunction,
    _In_opt_ __drv_aliasesMem PVOID Context,
    _Outptr_opt_ PIRP *Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoSetSystemWake (
    _Inout_ PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
PoGetSystemWake (
    _In_ PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PoUnregisterSystemState (
    _Inout_ PVOID StateHandle
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
POWER_STATE
PoSetPowerState (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ POWER_STATE_TYPE Type,
    _In_ POWER_STATE State
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PoCallDriver (
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ __drv_aliasesMem PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoStartNextPowerIrp(
    _Inout_ PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PULONG
PoRegisterDeviceForIdleDetection (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG ConservationIdleTime,
    _In_ ULONG PerformanceIdleTime,
    _In_ DEVICE_POWER_STATE State
    );
#endif

#define PoSetDeviceBusy(IdlePointer) \
    *IdlePointer = 0

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
NTKERNELAPI
VOID
PoSetDeviceBusyEx (
    _Inout_ PULONG IdlePointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
PoStartDeviceBusy (
    _Inout_ PULONG IdlePointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
PoEndDeviceBusy (
    _Inout_ PULONG IdlePointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
PoQueryWatchdogTime (
    _In_ PDEVICE_OBJECT Pdo,
    _Out_ PULONG SecondsRemaining
    );
#endif

typedef
_Function_class_(POWER_SETTING_CALLBACK)
_IRQL_requires_same_
NTSTATUS
POWER_SETTING_CALLBACK (
    _In_ LPCGUID SettingGuid,
    _In_reads_bytes_(ValueLength) PVOID Value,
    _In_ ULONG ValueLength,
    _Inout_opt_ PVOID Context
);

typedef POWER_SETTING_CALLBACK *PPOWER_SETTING_CALLBACK;

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoRegisterPowerSettingCallback (
    _In_opt_ PDEVICE_OBJECT DeviceObject,
    _In_ LPCGUID SettingGuid,
    _In_ PPOWER_SETTING_CALLBACK Callback,
    _In_opt_ PVOID Context,
    _Outptr_opt_ PVOID *Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoUnregisterPowerSettingCallback (
    _Inout_ PVOID Handle
    );
#endif

// begin_wudfwdm
//
// \Callback\PowerState values
//

#define PO_CB_SYSTEM_POWER_POLICY       0
#define PO_CB_AC_STATUS                 1
#define PO_CB_BUTTON_COLLISION          2 // deprecated
#define PO_CB_SYSTEM_STATE_LOCK         3
#define PO_CB_LID_SWITCH_STATE          4
#define PO_CB_PROCESSOR_POWER_POLICY    5 // deprecated


//
// Runtime Power Management Framework
//

#define PO_FX_VERSION_V1 0x00000001
#define PO_FX_VERSION_V2 0x00000002
#define PO_FX_VERSION PO_FX_VERSION_V1

DECLARE_HANDLE(POHANDLE);

typedef
_Function_class_(PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK (
    _In_ PVOID Context,
    _In_ ULONG Component
    );

typedef PO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK
    *PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK;

typedef
_Function_class_(PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK (
    _In_ PVOID Context,
    _In_ ULONG Component
    );

typedef PO_FX_COMPONENT_IDLE_CONDITION_CALLBACK
    *PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK;

typedef
_Function_class_(PO_FX_COMPONENT_IDLE_STATE_CALLBACK)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PO_FX_COMPONENT_IDLE_STATE_CALLBACK (
    _In_ PVOID Context,
    _In_ ULONG Component,
    _In_ ULONG State
    );

typedef PO_FX_COMPONENT_IDLE_STATE_CALLBACK
    *PPO_FX_COMPONENT_IDLE_STATE_CALLBACK;

typedef
_Function_class_(PO_FX_DEVICE_POWER_REQUIRED_CALLBACK)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PO_FX_DEVICE_POWER_REQUIRED_CALLBACK (
    _In_ PVOID Context
    );

typedef PO_FX_DEVICE_POWER_REQUIRED_CALLBACK
    *PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK;

typedef
_Function_class_(PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK (
    _In_ PVOID Context
    );

typedef PO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK
    *PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK;

typedef
_Function_class_(PO_FX_POWER_CONTROL_CALLBACK)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTSTATUS
PO_FX_POWER_CONTROL_CALLBACK (
    _In_ PVOID DeviceContext,
    _In_ LPCGUID PowerControlCode,
    _In_reads_bytes_opt_(InBufferSize) PVOID InBuffer,
    _In_ SIZE_T InBufferSize,
    _Out_writes_bytes_opt_(OutBufferSize) PVOID OutBuffer,
    _In_ SIZE_T OutBufferSize,
    _Out_opt_ PSIZE_T BytesReturned
    );

typedef PO_FX_POWER_CONTROL_CALLBACK *PPO_FX_POWER_CONTROL_CALLBACK;

typedef
_Function_class_(PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK)
_IRQL_requires_max_(HIGH_LEVEL)
VOID
PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK (
    _In_ PVOID Context,
    _In_ ULONG Component,
    _In_ BOOLEAN Active
    );

typedef PO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK
    *PPO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK;

typedef struct _PO_FX_COMPONENT_IDLE_STATE {
    ULONGLONG TransitionLatency;
    ULONGLONG ResidencyRequirement;
    ULONG NominalPower;
} PO_FX_COMPONENT_IDLE_STATE, *PPO_FX_COMPONENT_IDLE_STATE;

typedef struct _PO_FX_COMPONENT_V1 {
    GUID Id;
    ULONG IdleStateCount;
    ULONG DeepestWakeableIdleState;
    _Field_size_full_(IdleStateCount) PPO_FX_COMPONENT_IDLE_STATE IdleStates;
} PO_FX_COMPONENT_V1, *PPO_FX_COMPONENT_V1;

typedef struct _PO_FX_DEVICE_V1 {
    ULONG Version;
    ULONG ComponentCount;
    PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK ComponentActiveConditionCallback;
    PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK ComponentIdleConditionCallback;
    PPO_FX_COMPONENT_IDLE_STATE_CALLBACK ComponentIdleStateCallback;
    PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK DevicePowerRequiredCallback;
    PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK DevicePowerNotRequiredCallback;
    PPO_FX_POWER_CONTROL_CALLBACK PowerControlCallback;
    PVOID DeviceContext;
    _Field_size_full_(ComponentCount) PO_FX_COMPONENT_V1 Components[ANYSIZE_ARRAY];
} PO_FX_DEVICE_V1, *PPO_FX_DEVICE_V1;

#define PO_FX_COMPONENT_FLAG_F0_ON_DX 0x0000000000000001
#define PO_FX_COMPONENT_FLAG_NO_DEBOUNCE 0x0000000000000002

typedef struct _PO_FX_COMPONENT_V2 {
    GUID Id;
    ULONGLONG Flags;
    ULONG DeepestWakeableIdleState;
    ULONG IdleStateCount;
    _Field_size_full_(IdleStateCount) PPO_FX_COMPONENT_IDLE_STATE IdleStates;
    ULONG ProviderCount;
    _Field_size_full_(ProviderCount) PULONG Providers;
} PO_FX_COMPONENT_V2, *PPO_FX_COMPONENT_V2;

typedef struct _PO_FX_DEVICE_V2 {
    ULONG Version;
    ULONGLONG Flags;
    PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK ComponentActiveConditionCallback;
    PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK ComponentIdleConditionCallback;
    PPO_FX_COMPONENT_IDLE_STATE_CALLBACK ComponentIdleStateCallback;
    PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK DevicePowerRequiredCallback;
    PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK DevicePowerNotRequiredCallback;
    PPO_FX_POWER_CONTROL_CALLBACK PowerControlCallback;
    PVOID DeviceContext;
    ULONG ComponentCount;
    _Field_size_full_(ComponentCount) PO_FX_COMPONENT_V2 Components[ANYSIZE_ARRAY];
} PO_FX_DEVICE_V2, *PPO_FX_DEVICE_V2;

#if (PO_FX_VERSION == PO_FX_VERSION_V1)
typedef PO_FX_COMPONENT_V1 PO_FX_COMPONENT, *PPO_FX_COMPONENT;
typedef PO_FX_DEVICE_V1 PO_FX_DEVICE, *PPO_FX_DEVICE;
#elif (PO_FX_VERSION == PO_FX_VERSION_V2)
typedef PO_FX_COMPONENT_V2 PO_FX_COMPONENT, *PPO_FX_COMPONENT;
typedef PO_FX_DEVICE_V2 PO_FX_DEVICE, *PPO_FX_DEVICE;
#else
#error PO_FX_VERSION undefined!
#endif

typedef enum _PO_FX_PERF_STATE_UNIT {
    PoFxPerfStateUnitOther,
    PoFxPerfStateUnitFrequency,
    PoFxPerfStateUnitBandwidth,
    PoFxPerfStateUnitMaximum
} PO_FX_PERF_STATE_UNIT, *PPO_FX_PERF_STATE_UNIT;

typedef enum _PO_FX_PERF_STATE_TYPE {
    PoFxPerfStateTypeDiscrete,
    PoFxPerfStateTypeRange,
    PoFxPerfStateTypeMaximum
} PO_FX_PERF_STATE_TYPE, *PPO_FX_PERF_STATE_TYPE;

typedef struct _PO_FX_PERF_STATE {
    ULONGLONG Value;
    PVOID Context;
} PO_FX_PERF_STATE, *PPO_FX_PERF_STATE;

typedef struct _PO_FX_COMPONENT_PERF_SET {
    UNICODE_STRING Name;
    ULONGLONG Flags;
    PO_FX_PERF_STATE_UNIT Unit;
    PO_FX_PERF_STATE_TYPE Type;
    union {
        struct {
            ULONG Count;
            _Field_size_full_(Count) PPO_FX_PERF_STATE States;
        } Discrete;
        struct {
            ULONGLONG Minimum;
            ULONGLONG Maximum;
        } Range;
    };
} PO_FX_COMPONENT_PERF_SET, *PPO_FX_COMPONENT_PERF_SET;

typedef struct _PO_FX_COMPONENT_PERF_INFO {
    ULONG PerfStateSetsCount;
    PO_FX_COMPONENT_PERF_SET PerfStateSets[ANYSIZE_ARRAY];
} PO_FX_COMPONENT_PERF_INFO, *PPO_FX_COMPONENT_PERF_INFO;

typedef struct _PO_FX_PERF_STATE_CHANGE {
    ULONG Set;
    union {
        ULONG StateIndex;
        ULONGLONG StateValue;
    };
} PO_FX_PERF_STATE_CHANGE, *PPO_FX_PERF_STATE_CHANGE;
// end_wudfwdm 
// end_wdm
// begin_nthal
typedef struct _PO_FX_PRIMARY_DEVICE {
    ULONG Version;
    ULONG ComponentCount;
    PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK ComponentActiveConditionCallback;
    PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK ComponentIdleConditionCallback;
    PPO_FX_COMPONENT_IDLE_STATE_CALLBACK ComponentIdleStateCallback;
    PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK DevicePowerRequiredCallback;
    PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK DevicePowerNotRequiredCallback;
    PPO_FX_POWER_CONTROL_CALLBACK PowerControlCallback;
    PPO_FX_COMPONENT_CRITICAL_TRANSITION_CALLBACK ComponentCriticalTransitionCallback;
    PVOID DeviceContext;
    _Field_size_full_(ComponentCount) PO_FX_COMPONENT Components[ANYSIZE_ARRAY];
} PO_FX_PRIMARY_DEVICE, *PPO_FX_PRIMARY_DEVICE;
// end_nthal
// begin_wdm begin_wudfpwdm

//
// Driver interfaces for runtime framework.
//

#define PO_FX_UNKNOWN_POWER                         0xFFFFFFFF
#define PO_FX_UNKNOWN_TIME                          0xFFFFFFFFFFFFFFFF
#define PO_FX_FLAG_BLOCKING                         0x01
#define PO_FX_FLAG_ASYNC_ONLY                       0x02

#define PO_FX_FLAG_PERF_PEP_OPTIONAL                0x01
#define PO_FX_FLAG_PERF_QUERY_ON_F0                 0x02
#define PO_FX_FLAG_PERF_QUERY_ON_ALL_IDLE_STATES    0x04
// end_wudfpwdm end_wdm
// begin_nthal
#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxRegisterPrimaryDevice (
    _In_ PDEVICE_OBJECT Pdo,
    _In_ PPO_FX_PRIMARY_DEVICE Device,
    _Out_ POHANDLE *Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxEnableDStateReporting (
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

// end_nthal
// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxRegisterDevice (
    _In_ PDEVICE_OBJECT Pdo,
    _In_ PPO_FX_DEVICE Device,
    _Out_ POHANDLE *Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PoFxStartDevicePowerManagement (
    _In_ POHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PoFxUnregisterDevice (
    _In_ POHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxRegisterCrashdumpDevice (
    _In_ POHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_max_(HIGH_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxPowerOnCrashdumpDevice(
    _In_ POHANDLE Handle,
    _In_opt_ PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxActivateComponent (
    _In_ POHANDLE Handle,
    _In_ ULONG Component,
    _In_ ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxCompleteDevicePowerNotRequired (
    _In_ POHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxCompleteIdleCondition (
    _In_ POHANDLE Handle,
    _In_ ULONG Component
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxCompleteIdleState (
    _In_ POHANDLE Handle,
    _In_ ULONG Component
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxIdleComponent (
    _In_ POHANDLE Handle,
    _In_ ULONG Component,
    _In_ ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxSetComponentLatency (
    _In_ POHANDLE Handle,
    _In_ ULONG Component,
    _In_ ULONGLONG Latency
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxSetComponentResidency (
    _In_ POHANDLE Handle,
    _In_ ULONG Component,
    _In_ ULONGLONG Residency
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxSetComponentWake (
    _In_ POHANDLE Handle,
    _In_ ULONG Component,
    _In_ BOOLEAN WakeHint
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxSetDeviceIdleTimeout (
    _In_ POHANDLE Handle,
    _In_ ULONGLONG IdleTimeout
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxReportDevicePoweredOn (
    _In_ POHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxPowerControl (
    _In_ POHANDLE Handle,
    _In_ LPCGUID PowerControlCode,
    _In_opt_ PVOID InBuffer,
    _In_ SIZE_T InBufferSize,
    _Out_opt_ PVOID OutBuffer,
    _In_ SIZE_T OutBufferSize,
    _Out_opt_ PSIZE_T BytesReturned
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxNotifySurprisePowerOn(
      _In_ PDEVICE_OBJECT Pdo
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
typedef
_Function_class_(PO_FX_COMPONENT_PERF_STATE_CALLBACK)
VOID
PO_FX_COMPONENT_PERF_STATE_CALLBACK(
    _In_ PVOID Context,
    _In_ ULONG Component,
    _In_ BOOLEAN Succeeded,
    _In_ PVOID RequestContext
    );

typedef PO_FX_COMPONENT_PERF_STATE_CALLBACK
    *PPO_FX_COMPONENT_PERF_STATE_CALLBACK;

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxRegisterComponentPerfStates (
    _In_ POHANDLE Handle,
    _In_ ULONG Component,
    _In_ ULONGLONG Flags, 
    _In_ PPO_FX_COMPONENT_PERF_STATE_CALLBACK ComponentPerfStateCallback,
    _In_ PPO_FX_COMPONENT_PERF_INFO InputStateInfo,
    _Out_ PPO_FX_COMPONENT_PERF_INFO* OutputStateInfo
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxIssueComponentPerfStateChange (
    _In_ POHANDLE Handle,
    _In_ ULONG Flags,
    _In_ ULONG Component,
    _In_ PPO_FX_PERF_STATE_CHANGE PerfChange,
    _In_ PVOID Context
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
VOID
PoFxIssueComponentPerfStateChangeMultiple (
    _In_ POHANDLE Handle,
    _In_ ULONG Flags,
    _In_ ULONG Component,
    _In_ ULONG PerfChangesCount,
    _In_ PO_FX_PERF_STATE_CHANGE PerfChanges[],
    _In_ PVOID Context
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxQueryCurrentComponentPerfState (
    _In_ POHANDLE Handle,
    _In_ ULONG Flags,
    _In_ ULONG Component,
    _In_ ULONG SetIndex,
    _Out_ PULONGLONG CurrentPerf
    );
#endif
// end_wdm
// begin_ntifs

// Used for queuing work items to be performed at shutdown time.  Same
// rules apply as per Ex work queues.
#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoQueueShutdownWorkItem(
    _Inout_ __drv_aliasesMem PWORK_QUEUE_ITEM WorkItem
    );
#endif


typedef struct _PO_SESSION_INIT {
    BOOLEAN volatile *Sleeping;
    BOOLEAN volatile *HybridShutdown;
    ULONG DisplayTimeout;
    ULONG DisplayDimTimeout;
    ULONG AwayMode;
    ULONG AcDc;
    ULONG NormalBrightnessLevel;
    ULONG DimBrightnessLevel;
    ULONG AlsOffset;
    ULONG EsOffset;
    BOOLEAN EsEngaged;
    ULONG AlsEnabled;
} PO_SESSION_INIT, *PPO_SESSION_INIT;

typedef struct _PO_SESSION_DISPLAY_STATE {
    ULONG SessionId;
    ULONG DisplayState;
    POWER_MONITOR_REQUEST_REASON RequestReason;
    BOOLEAN IsConsole;
    BOOLEAN LogicalTransition;
    BOOLEAN VisibleTransition;
} PO_SESSION_DISPLAY_STATE, *PPO_SESSION_DISPLAY_STATE;

typedef enum {
    PoLatencyHintMouse,
    PoLatencyHintKeyboard,
    PoLatencyHintTouch,
    PoLatencyHintLowLatencyWorkload,
    PoLatencyHintDeadline,
    PoLatencyHintMaximum
} PO_LATENCY_HINT_TYPE, *PPO_LATENCY_HINT_TYPE;

//
// Connected Standby device compliance notification information.
//

typedef struct _PO_CS_DEVICE_NOTIFICATION {
    PVOID Device;
    PO_CS_DEVICE_NOTIFICATION_TYPE DeviceType;
    BOOLEAN Arriving;
    BOOLEAN Compliant;
} PO_CS_DEVICE_NOTIFICATION, *PPO_CS_DEVICE_NOTIFICATION;

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(HIGH_LEVEL)
NTKERNELAPI
NTSTATUS
PoFxProcessorNotification (
    _In_ POHANDLE Handle,
    _In_ ULONG Notification,
    _Inout_opt_ PVOID Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PoLatencySensitivityHint (
    _In_ PO_LATENCY_HINT_TYPE HintType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(APC_LEVEL)
_Requires_lock_not_held_(PopFxSystemLatencyLock)
NTKERNELAPI
VOID
FASTCALL
PoNotifyVSyncChange (
    _In_ BOOLEAN Enable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
NTKERNELAPI
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
FASTCALL
PoNotifyMediaBuffering (
    __in BOOLEAN Engaged
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINBLUE)

//
// Internal PEP defines.
//

#define PEP_FLAG_TEST                   0x80000000
#endif


#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
NTKERNELAPI
BOOLEAN
PoEnergyEstimationEnabled (
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoCreateThermalRequest (
    _Outptr_ PVOID *ThermalRequest,
    _In_ PDEVICE_OBJECT TargetDeviceObject,
    _In_ PDEVICE_OBJECT PolicyDeviceObject,
    _In_ PCOUNTED_REASON_CONTEXT Context,
    _In_ ULONG Flags
    );
#endif

typedef enum _PO_THERMAL_REQUEST_TYPE {
    PoThermalRequestPassive,
    PoThermalRequestActive,
} PO_THERMAL_REQUEST_TYPE, *PPO_THERMAL_REQUEST_TYPE;

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
PoGetThermalRequestSupport (
    _In_ PVOID ThermalRequest,
    _In_ PO_THERMAL_REQUEST_TYPE Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoSetThermalPassiveCooling (
    _Inout_ PVOID ThermalRequest,
    _In_ UCHAR Throttle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PoSetThermalActiveCooling (
    _Inout_ PVOID ThermalRequest,
    _In_ BOOLEAN Engaged
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PoDeleteThermalRequest (
    _Inout_ PVOID ThermalRequest
    );
#endif

// end_wdm

#define PO_THERMAL_REQUEST_SKIP_PROTECTION 0x80000000
#define PO_THERMAL_REQUEST_INVALID_FLAGS   (~0x80000000)


//
// Enum for state of a EM rule
//
typedef
enum {
    STATE_FALSE,
    STATE_UNKNOWN,
    STATE_TRUE
} EM_RULE_STATE, *PEM_RULE_STATE;

//
// Define the entry data structure
//

typedef struct _EM_ENTRY_DATA {
    PVOID Data;
    ULONG DataLength;
} EM_ENTRY_DATA, *PEM_ENTRY_DATA;

typedef const EM_ENTRY_DATA *PCEM_ENTRY_DATA;

//
// Define the Callback function pointer declaration
//

_Function_class_(EM_CALLBACK_ROUTINE)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_same_
typedef
EM_RULE_STATE
(EM_CALLBACK_ROUTINE) (
    _In_reads_opt_(NumberofEntries) EM_ENTRY_DATA **InputEntries,
    _In_ ULONG NumberofEntries,
    _In_reads_opt_(NumberofStrings) LPCSTR *InputStrings,
    _In_ ULONG NumberofStrings,
    _In_reads_opt_(NumberofNumerics) PULONG InputNumerics,
    _In_ ULONG NumberofNumerics,
    _In_opt_ PVOID Context
    );

typedef EM_CALLBACK_ROUTINE *PEM_CALLBACK_ROUTINE;
typedef PEM_CALLBACK_ROUTINE EM_CALLBACK_FUNC;

//
// Define the lazy entry registration callback function
//

_Function_class_(EM_LAZYENTRY_CALLBACK_ROUTINE)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_same_
typedef
VOID
(EM_LAZYENTRY_CALLBACK_ROUTINE) (
    _In_ LPCGUID EntryGuid,
    _In_opt_ PVOID Context
    );

typedef EM_LAZYENTRY_CALLBACK_ROUTINE *PEM_LAZYENTRY_CALLBACK_ROUTINE;
typedef PEM_LAZYENTRY_CALLBACK_ROUTINE EM_LAZYENTRY_CALLBACK;


//
//  Define the Lazy Registration Structure
//

typedef struct _EM_ENTRY_REGISTRATION {
    LPCGUID EntryGuid;

    //
    // If LazyEntryCallback is provided, the Entry will be considered lazy
    //

    EM_LAZYENTRY_CALLBACK LazyEntryCallback;
    PVOID LazyCallbackContext;
} EM_ENTRY_REGISTRATION, *PEM_ENTRY_REGISTRATION;

typedef const EM_ENTRY_REGISTRATION *PCEM_ENTRY_REGISTRATION;

//
// Define the Callback registration structure
//

typedef struct _EM_CALLBACK_REGISTRATION {
    LPCGUID CallbackGuid;
    EM_CALLBACK_FUNC CallbackFunction;
    PVOID Context;
} EM_CALLBACK_REGISTRATION, *PEM_CALLBACK_REGISTRATION;

typedef const EM_CALLBACK_REGISTRATION *PCEM_CALLBACK_REGISTRATION;


//
// Define client rule notification function
//

_Function_class_(EM_RULE_STATE_NOTIFY_ROUTINE)
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_same_
typedef
VOID
(EM_RULE_STATE_NOTIFY_ROUTINE) (
    _In_ EM_RULE_STATE State,
    _In_ LPCGUID RuleId,
    _In_opt_ PVOID Context
    );

typedef EM_RULE_STATE_NOTIFY_ROUTINE *PEM_RULE_STATE_NOTIFY_ROUTINE;
typedef PEM_RULE_STATE_NOTIFY_ROUTINE EM_RULE_STATE_NOTIFY;

//
// Define client rule notification registration structure
//

typedef struct _EM_CLIENT_NOTIFICATION_REGISTRATION {
    LPCGUID RuleId;
    EM_RULE_STATE_NOTIFY RuleNotifyCallback;
    PVOID Context;
} EM_CLIENT_NOTIFICATION_REGISTRATION, *PEM_CLIENT_NOTIFICATION_REGISTRATION;

//
// Em Provider APIs
//

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
EmProviderRegister(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_reads_opt_(NumberOfEntry) PCEM_ENTRY_REGISTRATION EntryRegistration,
    _In_ ULONG NumberOfEntry,
    _In_reads_opt_(NumberOfCallback) PCEM_CALLBACK_REGISTRATION CallbackRegistration,
    _In_ ULONG NumberOfCallback,
    _Out_ PVOID *ProviderHandle
    );

_IRQL_requires_max_(APC_LEVEL)
VOID
EmProviderDeregister(
    _In_ PVOID ProviderHandle
    );

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
EmProviderRegisterEntry(
    _In_ PVOID ProviderHandle,
    _In_ LPCGUID EntryId,
    _In_ PCEM_ENTRY_DATA EntryData,
    _Out_ PVOID *EntryHandle
    );


_IRQL_requires_max_(APC_LEVEL)
VOID
EmProviderDeregisterEntry(
    _In_ PVOID EntryHandle
    );

//
// Em Client APIs
//

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
EmClientRuleEvaluate(
    _In_ LPCGUID RuleId,
    _In_reads_(NumberOfEntries) EM_ENTRY_DATA **InputEntries,
    _In_ ULONG NumberOfEntries,
    _Out_ PEM_RULE_STATE State
    );

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
EmClientRuleRegisterNotification(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_reads_(NumberOfNotificatoinRegistration) PEM_CLIENT_NOTIFICATION_REGISTRATION RuleNotificationsRegistration,
    _In_ ULONG NumberOfNotificatoinRegistration,
    _Out_ PVOID *NotificationHandle
    );

_IRQL_requires_max_(APC_LEVEL)
VOID
EmClientRuleDeregisterNotification(
    _In_ PVOID NotificationHandle
    );

_IRQL_requires_max_(APC_LEVEL)
NTSTATUS
EmClientQueryRuleState(
    _In_ LPCGUID RuleId,
    _Out_ PEM_RULE_STATE State
    );

//
// Kernel Provider Registration API
//

NTSTATUS
EmpProviderRegister(
    _In_opt_ PDRIVER_OBJECT DriverObject,
    _In_reads_opt_(NumberOfEntryRegistration) PCEM_ENTRY_REGISTRATION EntryRegistration,
    _In_ ULONG NumberOfEntryRegistration,
    _In_reads_opt_(NumberOfCallbackRegistration) PCEM_CALLBACK_REGISTRATION CallbackRegistration,
    _In_ ULONG NumberOfCallbackRegistration,
    _Out_ PVOID *ProviderHandle
    );


FORCEINLINE
PKTHREAD
PsGetKernelThread(
    _In_ PETHREAD ThreadObject
    )
{
    return (PKTHREAD)ThreadObject;
}

FORCEINLINE
PKPROCESS
PsGetKernelProcess(
    _In_ PEPROCESS ProcessObject
    )
{
    return (PKPROCESS)ProcessObject;
}

NTKERNELAPI
NTSTATUS
PsGetContextThread(
    _In_ PETHREAD Thread,
    _Inout_ PCONTEXT ThreadContext,
    _In_ KPROCESSOR_MODE Mode
    );

NTKERNELAPI
NTSTATUS
PsSetContextThread(
    _In_ PETHREAD Thread,
    _In_ PCONTEXT ThreadContext,
    _In_ KPROCESSOR_MODE Mode
    );


extern NTKERNELAPI PEPROCESS PsInitialSystemProcess;


_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PEPROCESS
PsGetCurrentProcess(
    VOID
    );

// begin_wdm begin_ntddk begin_ntifs

#if !defined(_PSGETCURRENTTHREAD_)

#define _PSGETCURRENTTHREAD_

_IRQL_requires_max_(DISPATCH_LEVEL)
CFORCEINLINE
PETHREAD
PsGetCurrentThread (
    VOID
    )

/*++

Routine Description:

    This function returns a pointer to the current executive thread object.

Arguments:

    None.

Return Value:

    A pointer to the current executive thread object.

--*/

{

    return (PETHREAD)KeGetCurrentThread();
}

#endif

// end_wdm end_ntddk end_ntifs


#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
_Must_inspect_result_
NTSTATUS
PsCreateSystemThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_  HANDLE ProcessHandle,
    _Out_opt_ PCLIENT_ID ClientId,
    _In_ PKSTART_ROUTINE StartRoutine,
    _In_opt_ _When_(return >= 0, __drv_aliasesMem) PVOID StartContext,
    _In_opt_ PGROUP_AFFINITY GroupAffinity,
    _In_opt_ PULONG IdealProcessor
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
_Must_inspect_result_
NTSTATUS
PsCreateSystemThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ULONG DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_  HANDLE ProcessHandle,
    _Out_opt_ PCLIENT_ID ClientId,
    _In_ PKSTART_ROUTINE StartRoutine,
    _In_opt_ _When_(return >= 0, __drv_aliasesMem) PVOID StartContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsTerminateSystemThread(
    _In_ NTSTATUS ExitStatus
    );
#endif

NTKERNELAPI
NTSTATUS
PsWrapApcWow64Thread (
    _Inout_ PVOID *ApcContext,
    _Inout_ PVOID *ApcRoutine);


// end_wdm
// begin_ntddk

typedef
VOID
(*PCREATE_PROCESS_NOTIFY_ROUTINE)(
    _In_ HANDLE ParentId,
    _In_ HANDLE ProcessId,
    _In_ BOOLEAN Create
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsSetCreateProcessNotifyRoutine(
    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
    _In_ BOOLEAN Remove
    );
#endif

typedef struct _PS_CREATE_NOTIFY_INFO {
    _In_ SIZE_T Size;
    union {
        _In_ ULONG Flags;
        struct {
            _In_ ULONG FileOpenNameAvailable : 1;
            _In_ ULONG Reserved : 31;
        };
    };
    _In_ HANDLE ParentProcessId;
    _In_ CLIENT_ID CreatingThreadId;
    _Inout_ struct _FILE_OBJECT *FileObject;
    _In_ PCUNICODE_STRING ImageFileName;
    _In_opt_ PCUNICODE_STRING CommandLine;
    _Inout_ NTSTATUS CreationStatus;
} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;

typedef
VOID
(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX) (
    _Inout_ PEPROCESS Process,
    _In_ HANDLE ProcessId,
    _Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo
    );

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsSetCreateProcessNotifyRoutineEx (
    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,
    _In_ BOOLEAN Remove
    );
#endif

typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
    _In_ HANDLE ProcessId,
    _In_ HANDLE ThreadId,
    _In_ BOOLEAN Create
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsSetCreateThreadNotifyRoutine(
    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
typedef enum _PSCREATETHREADNOTIFYTYPE {
    PsCreateThreadNotifyNonSystem = 0
} PSCREATETHREADNOTIFYTYPE;

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsSetCreateThreadNotifyRoutineEx(
    _In_ PSCREATETHREADNOTIFYTYPE NotifyType,
    _In_ PVOID NotifyInformation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
PsRemoveCreateThreadNotifyRoutine (
    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );
#endif

//
// Structures for Load Image Notify
//

#define IMAGE_ADDRESSING_MODE_32BIT     3

typedef struct _IMAGE_INFO {
    union {
        ULONG Properties;
        struct {
            ULONG ImageAddressingMode  : 8;  // Code addressing mode
            ULONG SystemModeImage      : 1;  // System mode image
            ULONG ImageMappedToAllPids : 1;  // Image mapped into all processes
            ULONG ExtendedInfoPresent  : 1;  // IMAGE_INFO_EX available
            ULONG MachineTypeMismatch  : 1;  // Architecture type mismatch
            ULONG ImageSignatureLevel  : 4;  // Signature level
            ULONG ImageSignatureType   : 3;  // Signature type
            ULONG ImagePartialMap      : 1;  // Nonzero if entire image is not mapped
            ULONG Reserved             : 12;
        };
    };
    PVOID       ImageBase;
    ULONG       ImageSelector;
    SIZE_T      ImageSize;
    ULONG       ImageSectionNumber;
} IMAGE_INFO, *PIMAGE_INFO;

typedef struct _IMAGE_INFO_EX {
    SIZE_T              Size;
    IMAGE_INFO          ImageInfo;
    struct _FILE_OBJECT *FileObject;
} IMAGE_INFO_EX, *PIMAGE_INFO_EX;

typedef
VOID
(*PLOAD_IMAGE_NOTIFY_ROUTINE)(
    _In_opt_ PUNICODE_STRING FullImageName,
    _In_ HANDLE ProcessId,                // pid into which image is being mapped
    _In_ PIMAGE_INFO ImageInfo
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsSetLoadImageNotifyRoutine(
    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsRemoveLoadImageNotifyRoutine(
    _In_ PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
    );
#endif

// end_ntddk
// begin_ntifs

//
// Security Support
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsAssignImpersonationToken(
    _In_ PETHREAD Thread,
    _In_opt_ HANDLE Token
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
PACCESS_TOKEN
PsReferencePrimaryToken (
    _Inout_ PEPROCESS Process
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsDereferencePrimaryToken(
    _In_ PACCESS_TOKEN PrimaryToken
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsDereferenceImpersonationToken(
    _In_ PACCESS_TOKEN ImpersonationToken
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTASP1)
typedef union _PS_EXCEPTION_FLAGS {
    ULONG Flags;
    struct {
        ULONG ProcessUsingVEH : 1;
        ULONG ProcessUsingVCH : 1;
        ULONG Reserved : 30;
    };
} PS_EXCEPTION_FLAGS, *PPS_EXCEPTION_FLAGS;

#define PS_EXCEPTION_FLAGS_QUERY_WOW64  0x00000001UL

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsQueryProcessExceptionFlags (
    _Inout_ PEPROCESS TargetProcess,
    _In_ ULONG Flags,
    _Out_ PPS_EXCEPTION_FLAGS ExceptionFlags
    );
#endif

// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PACCESS_TOKEN
PsReferenceImpersonationToken(
    _Inout_ PETHREAD Thread,
    _Out_ PBOOLEAN CopyOnOpen,
    _Out_ PBOOLEAN EffectiveOnly,
    _Out_ PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
#endif

// end_ntifs
// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
LARGE_INTEGER
PsGetProcessExitTime(
    VOID
    );
#endif

// end_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
BOOLEAN
PsIsThreadTerminating(
    _In_ PETHREAD Thread
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsImpersonateClient(
    _Inout_ PETHREAD Thread,
    _In_opt_ PACCESS_TOKEN Token,
    _In_ BOOLEAN CopyOnOpen,
    _In_ BOOLEAN EffectiveOnly,
    _In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsRevertToSelf(
    VOID
    );
#endif

// end_ntifs

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsRevertThreadToSelf(
    _Inout_ PETHREAD Thread
    );


_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
    _In_ HANDLE ProcessId,
    _Outptr_ PEPROCESS *Process
    );

_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsLookupThreadByThreadId(
    _In_ HANDLE ThreadId,
    _Outptr_ PETHREAD *Thread
    );

NTSTATUS
PsLookupSiloBySiloId(
    _In_ HANDLE SiloId,
    _Outptr_ PESILO *Silo
    );

//
// Quota Operations
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PsChargePoolQuota (
    _In_ PEPROCESS Process,
    _In_ POOL_TYPE PoolType,
    _In_ ULONG_PTR Amount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsChargeProcessPoolQuota (
    _In_ PEPROCESS Process,
    _In_ POOL_TYPE PoolType,
    _In_ ULONG_PTR Amount
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PsReturnPoolQuota(
    _In_ PEPROCESS Process,
    _In_ POOL_TYPE PoolType,
    _In_ ULONG_PTR Amount
    );
#endif

// end_ntifs

NTSTATUS
PsRootSiloInformation(
    PSYSTEM_ROOT_SILO_INFORMATION RootSiloInformation,
    ULONG BufferLength,
    PULONG ReturnLength
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsChargeProcessNonPagedPoolQuota (
    _Inout_ PEPROCESS Process,
    _In_ SIZE_T Amount
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PsReturnProcessNonPagedPoolQuota (
    _Inout_ PEPROCESS Process,
    _In_ SIZE_T Amount
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsChargeProcessPagedPoolQuota (
    _Inout_ PEPROCESS Process,
    _In_ SIZE_T Amount
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PsReturnProcessPagedPoolQuota (
    _Inout_ PEPROCESS Process,
    _In_ SIZE_T Amount
    );



typedef struct _WIN32_PROCESS_CALLOUT_PARAMETERS {
    PEPROCESS Process;
    union {
        ULONG Flags;
        struct {
            ULONG Initialize    : 1;
            ULONG WindowsSigned : 1;
            ULONG Reserved      : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} WIN32_PROCESS_CALLOUT_PARAMETERS, *PKWIN32_PROCESS_CALLOUT_PARAMETERS;

typedef enum _PSW32JOBCALLOUTTYPE {
    PsW32JobCalloutSetInformation,
    PsW32JobCalloutAddProcess,
    PsW32JobCalloutTerminate
} PSW32JOBCALLOUTTYPE;

typedef struct _WIN32_JOBCALLOUT_PARAMETERS {
    PVOID Job;
    PSW32JOBCALLOUTTYPE CalloutType;
    _In_ PVOID Data;
} WIN32_JOBCALLOUT_PARAMETERS, *PKWIN32_JOBCALLOUT_PARAMETERS;

typedef enum _PSW32THREADCALLOUTTYPE {
    PsW32ThreadCalloutInitialize,
    PsW32ThreadCalloutExit
} PSW32THREADCALLOUTTYPE;

typedef struct _WIN32_THREAD_CALLOUT_PARAMETERS {
    PETHREAD Thread;
    PSW32THREADCALLOUTTYPE CalloutType;
} WIN32_THREAD_CALLOUT_PARAMETERS, *PKWIN32_THREAD_CALLOUT_PARAMETERS;

typedef enum _PSPOWEREVENTTYPE {
    PsW32FullWake,
    PsW32EventCode,
    PsW32SystemPowerState,
    PsW32SystemTime,
    PsW32MonitorOn,
    PsW32MonitorOff,
    PsW32ScreenSaver,
    PsW32MonitorDim,
    PsW32RITActive,
    PsW32RITTimeout,
    PsW32PostMonitorOn,
    PsW32PostMonitorOff,
    PsW32DisplayBurst
} PSPOWEREVENTTYPE, *PPSPOWEREVENTTYPE;

typedef struct _WIN32_POWEREVENT_PARAMETERS {
    PSPOWEREVENTTYPE EventNumber;
    ULONG_PTR Code;
} WIN32_POWEREVENT_PARAMETERS, *PKWIN32_POWEREVENT_PARAMETERS;

typedef enum _POWERSTATETASK {
    PowerState_BlockSessionSwitch,
    PowerState_Init,
    PowerState_SuspendApps,
    PowerState_SuspendServices,
    PowerState_NotifyWL,
    PowerState_ResumeApps,
    PowerState_ResumeServices,
    PowerState_UnBlockSessionSwitch,
    PowerState_End,
    PowerState_Flush,
    PowerState_StartPartitionReplace,
    PowerState_EndPartitionReplace,
    PowerState_MonitorOff
} POWERSTATETASK;

typedef struct _WIN32_POWERSTATE_PARAMETERS {
    BOOLEAN Promotion;
    POWER_ACTION SystemAction;
    SYSTEM_POWER_STATE MinSystemState;
    ULONG Flags;
    POWERSTATETASK PowerStateTask;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} WIN32_POWERSTATE_PARAMETERS, *PKWIN32_POWERSTATE_PARAMETERS;

typedef enum _WIN32_POWERINFO_TYPE {
    PowerInfo_PolicyChange,
    PowerInfo_UserPresent,
    PowerInfo_DisplayRequired,
    PowerInfo_Monitor,
    PowerInfo_Input,
    PowerInfo_Max
} WIN32_POWERINFO_TYPE, *PWIN32_POWERINFO_TYPE;

typedef enum _WIN32K_INPUT_MODE {
    PowerInputEnabled,
    PowerInputSuppressed,
    PowerInputFiltered,
} WIN32K_INPUT_MODE, *PWIN32K_INPUT_MODE;

//
// GUID determining display off timeout. This is the value only used for
// a console session. It doesn't have any impact on TS sessions where
// display state is currently derived from session connected/disconnected
// state.
// {6F5E16B8-8575-4014-B209-215FD159D7CD}
DEFINE_GUID(GUID_CONSOLE_VIDEO_TIMEOUT, 0x6f5e16b8, 0x8575, 0x4014, 0xb2, 0x9, 0x21, 0x5f, 0xd1, 0x59, 0xd7, 0xcd);

//
// GUID determining "no input" timeout. This is used in Adaptive Power to
// control how long Win32k waits before "no input" callout
// (SessionRITState == FALSE) is made to PO. This GUID is used *only* for
// the non-console sessions
//
// {8592A7F6-022C-4f42-8C81-D7745F8CA920}
DEFINE_GUID(GUID_TS_INPUT_TIMEOUT, 0x8592a7f6, 0x22c, 0x4f42, 0x8c, 0x81, 0xd7, 0x74, 0x5f, 0x8c, 0xa9, 0x20);

//
// GUID determining "no input" timeout for the current console session. This
//  is used in Adaptive Power to control how long Win32k waits before
// the "no input" callout (SessionRITState == FALSE) is made to PO. This GUID
// is used *only* for console sessions
//
// {34A64C3B-8317-4171-ABD8-A3B1EE3E4331}
DEFINE_GUID(GUID_CONSOLE_INPUT_TIMEOUT, 0x34a64c3b, 0x8317, 0x4171, 0xab, 0xd8, 0xa3, 0xb1, 0xee, 0x3e, 0x43, 0x31);

typedef struct _WIN32_POWERINFO_POLICYCHANGE {
    GUID Guid;
    ULONG Value;
} WIN32_POWERINFO_POLICYCHANGE, *PKWIN32_POWERINFO_POLICYCHANGE;

typedef struct _WIN32_POWERINFO_DISPLAYREQUIRED {
    LONG RequestCountChange;
} WIN32_POWERINFO_DISPLAYREQUIRED, *PKWIN32_POWERINFO_DISPLAYREQUIRED;

typedef struct _WIN32_POWERINFO_USERPRESENT {
    BOOLEAN Virtual;
    BOOLEAN UpdateLastInputOnly;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} WIN32_POWERINFO_USERPRESENT, *PKWIN32_POWERINFO_USERPRESENT;

typedef struct _WIN32_POWERINFO_MONITOR {
    BOOLEAN On;
    BOOLEAN AssertPresence;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} WIN32_POWERINFO_MONITOR, *PKWIN32_POWERINFO_MONITOR;

typedef struct _WIN32_POWERINFO_CALLOUT_PARAMETERS {
    WIN32_POWERINFO_TYPE Type;
    BOOLEAN Synchronous;
    ULONG InputSize;
    PVOID InputBuffer;
    ULONG OutputSize;
    PVOID OutputBuffer;
} WIN32_POWERINFO_CALLOUT_PARAMETERS, *PKWIN32_POWERINFO_CALLOUT_PARAMETERS;

typedef struct _WIN32_JOBINTERFERENCEINFO_CALLOUT_PARAMETERS {
    PEPROCESS Process;
    ULONG* InterferenceCount;               // How many times the process interfered with rendering since process start.
} WIN32_JOBINTERFERENCEINFO_CALLOUT_PARAMETERS, *PWIN32_JOBINTERFERENCEINFO_CALLOUT_PARAMETERS;

//
// Define structure to query subsystem process.
//
// N.B.  The size of this structure is fixed.
//

typedef struct _WIN32_SUBSYSTEM_PROCESS_QUERY_CALLOUT_PARAMETERS {
    PEPROCESS SubsystemProcess;             // Caller must dereference
} WIN32_SUBSYSTEM_PROCESS_QUERY_CALLOUT_PARAMETERS, *PWIN32_SUBSYSTEM_PROCESS_QUERY_CALLOUT_PARAMETERS;

C_ASSERT(sizeof(WIN32_SUBSYSTEM_PROCESS_QUERY_CALLOUT_PARAMETERS) == sizeof(PVOID));

typedef enum _WIN32_CALLOUTS_OPERATION {
    Win32ProcessCallout = 0,
    Win32ThreadCallout,
    Win32GlobalAtomTableCallout,
    Win32PowerEventCallout,
    Win32PowerStateCallout,
    Win32PowerInfoCallout,
    Win32JobCallout,
    Win32BatchFlushCallout,
    Win32DesktopOpenCallout,
    Win32DesktopOkToCloseCallout,
    Win32DesktopCloseCallout,
    Win32DesktopDeleteCallout,
    Win32WindowStationOkToCloseCallout,
    Win32WindowStationCloseCallout,
    Win32WindowStationDeleteCallout,
    Win32WindowStationParseCallout,
    Win32WindowStationOpenCallout,
    Win32LicensingCallout,
    Win32CompositionObjectOpenCallout,
    Win32CompositionObjectOkToCloseCallout,
    Win32CompositionObjectCloseCallout,
    Win32CompositionObjectDeleteCallout,
    Win32ProcessFreezeCallout,
    Win32ProcessThawCallout,
    Win32JobGetInterferenceCountsCallout,
    Win32GetGpuStatisticsCallout,
    Win32SubsystemProcessQueryCallout,

    Win32RawInputManagerObjectOpenCallout,
    Win32RawInputManagerObjectOkToCloseCallout,
    Win32RawInputManagerObjectCloseCallout,
    Win32RawInputManagerObjectDeleteCallout,

    Win32WakeRitForShutdownCallout,

    Win32CalloutsMax
} WIN32_CALLOUTS_OPERATION, *PKWIN32_CALLOUTS_OPERATION;

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsEstablishWin32Callouts(
    _In_ PEX_CALLBACK_FUNCTION CalloutDispatchRoutine
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PsReferenceKernelStack (
    _Inout_ PETHREAD Thread
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PsDereferenceKernelStack (
    _Inout_ PETHREAD Thread
    );

typedef enum _PSPROCESSPRIORITYMODE {
    PsProcessPriorityBackground,
    PsProcessPriorityForeground,
    PsProcessPrioritySpinning
} PSPROCESSPRIORITYMODE;

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
PsSetProcessPriorityByClass(
    _Inout_ PEPROCESS Process,
    _In_ PSPROCESSPRIORITYMODE PriorityMode
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
HANDLE
PsGetCurrentProcessId(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
HANDLE
PsGetCurrentThreadId(
    VOID
    );
#endif


_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
ULONG
PsGetCurrentProcessSessionId(
    VOID
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
PsGetCurrentThreadStackLimit(
    VOID
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
PsGetCurrentThreadStackBase(
    VOID
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
CCHAR
PsGetCurrentThreadPreviousMode(
    VOID
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PERESOURCE
PsGetJobLock(
    _In_ PEJOB Job
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
PsGetJobProperty(
    _In_ PEJOB Thread,
    _In_ ULONG_PTR Key
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
ULONG
PsGetJobSessionId(
    _In_ PEJOB Job
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
ULONG
PsGetJobUIRestrictionsClass(
    _In_ PEJOB Job
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
ULONG
PsGetJobEffectiveFreezeCount(
    _In_ PEJOB Job
    );

// begin_ntddk
#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONGLONG
PsGetProcessCreateTimeQuadPart(
    _In_ PEPROCESS Process
    );
#endif
// end_ntddk

NTKERNELAPI
PVOID
PsGetProcessDebugPort(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
BOOLEAN
PsIsProcessBeingDebugged(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
BOOLEAN
PsGetProcessExitProcessCalled(
    _In_ PEPROCESS Process
    );

// begin_ntddk
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsGetProcessExitStatus(
    _In_ PEPROCESS Process
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
PsGetThreadExitStatus(
    _In_ PETHREAD Thread
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
HANDLE
PsGetProcessId(
    _In_ PEPROCESS Process
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
HANDLE
PsGetThreadId(
    _In_ PETHREAD Thread
     );
#endif

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
PVOID
PsGetThreadProperty(
    _In_ PETHREAD Thread,
    _In_ ULONG_PTR Key,
    _In_ ULONG Flags
    );

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
HANDLE
PsGetThreadProcessId(
    _In_ PETHREAD Thread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
NTKERNELAPI
LONGLONG
PsGetThreadCreateTime(
    _In_ PETHREAD Thread
    );
#endif

// end_ntddk

NTKERNELAPI
UCHAR *
PsGetProcessImageFileName(
    _In_ PEPROCESS Process
    );

#define PsGetCurrentProcessImageFileName() PsGetProcessImageFileName(PsGetCurrentProcess())

NTKERNELAPI
HANDLE
PsGetProcessInheritedFromUniqueProcessId(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
PEJOB
PsGetProcessJob(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
PESILO
PsGetProcessSilo(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
PESILO
PsGetCurrentSilo(
    );

NTKERNELAPI
BOOLEAN
PsIsProcessInAppSilo(
    _In_ PEPROCESS Process
    );


NTKERNELAPI
BOOLEAN
PsIsProcessInSilo(
    _In_ PEPROCESS Process,
    _In_ PESILO Silo
    );

NTKERNELAPI
BOOLEAN
PsIsThreadInSilo(
    _In_ PETHREAD Thread,
    _In_ PESILO Silo
    );

NTKERNELAPI
PESILO
PsGetProcessServerSilo(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
BOOLEAN
PsTerminateAllProcessesInSilo(
    _In_ PESILO Silo,
    _In_ NTSTATUS Status
    );

NTKERNELAPI
NTSTATUS
PsTerminateServerSilo(
    _In_ PESILO pServerSilo,
    _In_ NTSTATUS ExitStatus
    );

NTKERNELAPI
BOOLEAN
PsIsThreadAttachedToProcessServerSilo(
    );

NTKERNELAPI
NTSTATUS
PsSetSiloObjectRootDirectory (
    _In_opt_ HANDLE SiloHandle,
    _In_ PSILOOBJECT_ROOT_DIRECTORY RootInfo
    );

NTKERNELAPI
NTSTATUS
PsSetSiloObjectRootDirectoryByPointer (
    _In_ PESILO Silo,
    _In_ PSILOOBJECT_ROOT_DIRECTORY RootInfo
    );

NTKERNELAPI
NTSTATUS
PsSetSiloObjectServerProperty (
    _In_opt_ HANDLE SiloHandle,
    _In_ PESILO Silo,
    _In_ COMPARTMENT_ID* CompartmentId
    );

NTKERNELAPI
NTSTATUS
PsSetSiloObjectServerPropertyByPointer (
    _In_ PESILO Silo,
    _In_ COMPARTMENT_ID* CompartmentId
    );

NTKERNELAPI
ULONG
PsGetProcessSessionId(
    _In_ PEPROCESS Process
    );

// begin_ntosifs

NTKERNELAPI
ULONG
PsGetProcessSessionIdEx(
    _In_ PEPROCESS Process
    );

// end_ntosifs

NTKERNELAPI
PVOID
PsGetProcessSectionBaseAddress(
    _In_ PEPROCESS Process
    );

#define PsGetProcessPcb(Process) ((PKPROCESS)(Process))

NTKERNELAPI
PPEB
PsGetProcessPeb(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
UCHAR
PsGetProcessPriorityClass(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
HANDLE
PsGetProcessWin32WindowStation(
    _In_ PEPROCESS Process
    );

#define PsGetCurrentProcessWin32WindowStation() PsGetProcessWin32WindowStation(PsGetCurrentProcess())

NTKERNELAPI
PVOID
PsGetProcessWin32Process(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
PVOID
PsGetCurrentProcessWin32Process(
    VOID
    );

#if BUILD_WOW64_ENABLED

NTKERNELAPI
PVOID
PsGetProcessWow64Process(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
PVOID
PsGetCurrentProcessWow64Process(
    VOID
    );

#endif

NTKERNELAPI
ULONG
PsGetThreadFreezeCount(
    _In_ PETHREAD Thread
    );

NTKERNELAPI
BOOLEAN
PsGetThreadHardErrorsAreDisabled(
    _In_ PETHREAD Thread
    );

// begin_ntifs

NTKERNELAPI
PEPROCESS
PsGetThreadProcess(
    _In_ PETHREAD Thread
    );

// end_ntifs

NTKERNELAPI
PEPROCESS
PsGetCurrentThreadProcess(
    VOID
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
HANDLE
PsGetCurrentThreadProcessId(
    VOID
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
ULONG
PsGetThreadSessionId(
    _In_ PETHREAD Thread
    );

#define  PsGetThreadTcb(Thread) ((PKTHREAD)(Thread))

NTKERNELAPI
PVOID
PsGetThreadTeb(
    _In_ PETHREAD Thread
    );

// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

NTKERNELAPI
PVOID
PsGetCurrentThreadTeb(
    VOID
    );

#endif

// end_ntddk

NTKERNELAPI
PVOID
PsGetThreadWin32Thread(
    _In_ PETHREAD Thread
    );

NTKERNELAPI
PVOID
PsGetCurrentThreadWin32Thread(
    VOID
    );

NTKERNELAPI
PVOID
PsGetCurrentThreadWin32ThreadAndEnterCriticalRegion(
    _Out_ PHANDLE ProcessId
    );

NTKERNELAPI
LOGICAL
PsIsProtectedProcess (
    _In_ PEPROCESS Process
    );

NTKERNELAPI
LOGICAL
PsIsProtectedProcessLight (
    _In_ PEPROCESS Process
    );

SE_SIGNING_LEVEL
PsGetProcessSignatureLevel (
    _In_ PEPROCESS Process,
    _Out_opt_ PSE_SIGNING_LEVEL SectionSignatureLevel
    );

PS_PROTECTION
PsGetProcessProtection (
    _In_ PEPROCESS Process
    );

// begin_ntosifs

NTKERNELAPI
VOID
PsEnterPriorityRegion (
    VOID
    );

NTKERNELAPI
VOID
PsLeavePriorityRegion (
    VOID
    );


#if (NTDDI_VERSION >= NTDDI_WINXP)  // ntifs
NTKERNELAPI                         // ntifs
BOOLEAN                             // ntifs
PsIsSystemThread(                   // ntifs
    _In_ PETHREAD Thread            // ntifs
    );                              // ntifs
#endif                              // ntifs

NTKERNELAPI
BOOLEAN
PsIsSystemProcess(
    _In_ PEPROCESS Process
     );

NTKERNELAPI
BOOLEAN
PsIsThreadImpersonating (
    _In_ PETHREAD Thread
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsAcquireProcessExitSynchronization (
    _Inout_ PEPROCESS Process
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsReleaseProcessExitSynchronization (
    _Inout_ PEPROCESS Process
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsReferenceProcessFilePointer (
    _In_ PEPROCESS Process,
    _Out_ PVOID *pFilePointer
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PsSetJobProperty(
    _In_ PEJOB Job,
    _In_ ULONG_PTR Key,
    _In_ PVOID Object
);

NTKERNELAPI
VOID
PsSetProcessPriorityClass(
    _Out_ PEPROCESS Process,
    _In_ UCHAR PriorityClass
    );

NTKERNELAPI
NTSTATUS
PsSetProcessWin32Process(
    _In_ PEPROCESS Process,
    _In_opt_ PVOID Win32Process,
    _In_ PVOID PrevWin32Process
    );

NTKERNELAPI
VOID
PsSetProcessWindowStation(
    _Out_ PEPROCESS Process,
    _In_opt_ HANDLE Win32WindowStation
    );

NTKERNELAPI
VOID
PsSetThreadHardErrorsAreDisabled(
    _In_ PETHREAD Thread,
    _In_ BOOLEAN HardErrorsAreDisabled
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PsSetThreadProperty(
    _In_ PETHREAD Thread,
    _In_ ULONG_PTR Key,
    _In_ PVOID Object
);

NTKERNELAPI
VOID
PsSetThreadWin32Thread(
    _Inout_ PETHREAD Thread,
    _In_opt_ PVOID Win32Thread,
    _In_ PVOID PrevWin32Thread
    );

NTKERNELAPI
PVOID
PsGetProcessSecurityPort(
    _In_ PEPROCESS Process
    );

NTKERNELAPI
NTSTATUS
PsSetProcessSecurityPort(
    _Out_ PEPROCESS Process,
    _In_ PVOID Port
    );

NTSTATUS
PsSuspendProcess (
    _Inout_ PEPROCESS Process
    );

NTSTATUS
PsResumeProcess (
    _Inout_ PEPROCESS Process
    );

NTSTATUS
PsTerminateProcess (
    _Inout_ PEPROCESS Process,
    _In_ NTSTATUS Status
    );

typedef
NTSTATUS
PS_SUSPEND_THREAD (
    _In_ PETHREAD Thread,
    _Out_opt_ PULONG PreviousSuspendCount
    );

typedef PS_SUSPEND_THREAD *PPS_SUSPEND_THREAD;

PS_SUSPEND_THREAD PsSuspendThread;

typedef
NTSTATUS
PS_RESUME_THREAD (
    _In_ PETHREAD Thread,
    _Out_opt_ PULONG PreviousSuspendCount
    );

typedef PS_RESUME_THREAD *PPS_RESUME_THREAD;

PS_RESUME_THREAD PsResumeThread;

#if !defined(_WIN64) && !defined(_ARM_)

NTSTATUS
PsSetLdtEntries (
    _In_ ULONG Selector0,
    _In_ ULONG Entry0Low,
    _In_ ULONG Entry0Hi,
    _In_ ULONG Selector1,
    _In_ ULONG Entry1Low,
    _In_ ULONG Entry1Hi
    );

NTSTATUS
PsSetProcessLdtInfo (
    _In_ PPROCESS_LDT_INFORMATION LdtInformation,
    _In_ ULONG LdtInformationLength
    );

#endif


NTSTATUS
PsCaptureUserProcessParameters (
    _Outptr_ PRTL_USER_PROCESS_PARAMETERS *CapturedProcessParameters,
    _In_ PRTL_USER_PROCESS_PARAMETERS UserProcessParameters
    );

PVOID
PsGetProcessCommonJob (
    _In_ PEPROCESS Process1,
    _In_ PEPROCESS Process2
    );

#define PS_WAKE_COUNTER_CONDITIONAL_CHARGE  0x00000001UL
#define PS_WAKE_COUNTER_NO_WAKE_CHARGE      0x00000002UL
#define PS_WAKE_COUNTER_BREAK_IF_SUSPENDED  0x80000000UL

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
PVOID
PsChargeProcessWakeCounter (
    _Inout_ PEPROCESS Process,
    _In_ ULONG Flags,
    _In_ PS_WAKE_REASON WakeReason,
    _In_ ULONG_PTR Tag
    );

NTKERNELAPI
VOID
PsReleaseProcessWakeCounter (
    _In_ PVOID Reference,
    _In_ ULONG_PTR Tag
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
VOID
PsQueryProcessAttributesByToken (
    _Inout_ PACCESS_TOKEN Token,
    _Out_opt_ PBOOLEAN SystemAppIdentifier,
    _Out_opt_ PBOOLEAN PackagedApplication
    );
#endif

// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
ULONG64
PsQueryTotalCycleTimeProcess (
    _Inout_ PEPROCESS Process,
    _Out_ PULONG64 CycleTimeStamp
    );
#endif
// end_wdm

// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
VOID
PsUpdateDiskCounters (
    _Inout_ PEPROCESS Process,
    _In_ ULONG64 BytesRead,
    _In_ ULONG64 BytesWritten,
    _In_ ULONG ReadOperationCount,
    _In_ ULONG WriteOperationCount,
    _In_ ULONG FlushOperationCount
    );
#endif

// end_ntifs

// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTKERNELAPI
BOOLEAN
PsIsDiskCountersEnabled (
    VOID
    );
#endif

// end_ntifs

// begin_ntddk

#if (NTDDI_VERSION >= NTDDI_THRESHOLD)

//
// As an aid to debugging silo object reference counts, PsReferenceSiloObject
// and PsDereferenceSilo object call private Psp equivalents. At some point
// we will probably want to go back to calling the Ob functions directly.
//

#if 0
#define PsReferenceSiloObject(Silo)   { if ((Silo) != NULL) ObReferenceObject(Silo); }
#define PsDereferenceSiloObject(Silo) { if ((Silo) != NULL) ObDereferenceObject(Silo); }
#else
NTKERNELAPI
VOID
PspReferenceSiloObject(
    _In_ PESILO Silo
    );
NTKERNELAPI
VOID
PspDereferenceSiloObject(
    _In_ PESILO Silo
    );
#define PsReferenceSiloObject(Silo)   { if ((Silo) != NULL) PspReferenceSiloObject(Silo); }
#define PsDereferenceSiloObject(Silo) { if ((Silo) != NULL) PspDereferenceSiloObject(Silo); }
#endif

NTKERNELAPI
PESILO
PsAttachSiloToCurrentThread (
    _In_ PESILO Silo
    );

NTKERNELAPI
VOID
PsDetachSiloFromCurrentThread(
    _In_ PESILO PreviousSilo
    );

NTKERNELAPI
NTSTATUS
PsInsertSiloObject(
    HANDLE SiloHandle,
    ULONG_PTR ObjectTag,
    PVOID Object
    );

NTKERNELAPI
NTSTATUS
PsInsertSiloObjectFromJob(
    HANDLE JobHandle,
    ULONG_PTR ObjectTag,
    PVOID Object
    );

NTKERNELAPI
NTSTATUS
PsInsertSiloObjectByPointer(
    PESILO Silo,
    ULONG_PTR ObjectTag,
    PVOID Object
    );

NTKERNELAPI
NTSTATUS
PsRemoveSiloObject(
    HANDLE SiloHandle,
    ULONG_PTR ObjectTag
    );

NTKERNELAPI
NTSTATUS
PsRemoveSiloObjectFromJob(
    HANDLE JobHandle,
    ULONG_PTR ObjectTag
    );

NTKERNELAPI
NTSTATUS
PsGetSiloObject(
    HANDLE SiloHandle,
    ULONG_PTR ObjectTag,
    PVOID *Object
    );

NTKERNELAPI
NTSTATUS
PsGetSiloObjectFromJob(
    HANDLE JobHandle,
    ULONG_PTR ObjectTag,
    PVOID *Object
    );

NTKERNELAPI
NTSTATUS
PsGetSiloObjectByPointer(
    PESILO Silo,
    ULONG_PTR ObjectTag,
    PVOID *Object
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
PESILO
PsGetCurrentServerSilo(
    VOID
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
PsIsCurrentThreadInServerSilo(
    VOID
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
PsEqualCurrentServerSilo(
    _In_ PESILO OtherSilo
    );

NTKERNELAPI
BOOLEAN
PsEqualCurrentSilo(
    _In_ PESILO OtherSilo
    );

NTKERNELAPI
BOOLEAN
PsIsHostSilo(
    _In_ PESILO ServerSilo
    );

//
// Silo create callback, called when a new silo is created and for existing
// silos when a monitor starts.
//

typedef
NTSTATUS
(*PSERVER_SILO_MONITOR_CREATE_CALLBACK)(
    _In_ PESILO ServerSilo
    );

//
// Silo terminate callback, called when a silo is terminating and for
// existing silos when a monitor unregisters.
//

typedef
VOID
(*PSERVER_SILO_MONITOR_TERMINATE_CALLBACK)(
    _In_ PESILO ServerSilo,
    _In_ PVOID Context
    );

//
// Driver load callback, called when a monitor's driver is loaded in a silo.
//

typedef
VOID
(*PSERVER_SILO_MONITOR_DRIVER_LOAD_CALLBACK)(
    _In_ PESILO ServerSilo,
    _In_ PVOID Context
    );

//
// Driver unload callback, called when a monitor's driver is unloaded in a silo.
//

typedef
VOID
(*PSERVER_SILO_MONITOR_DRIVER_UNLOAD_CALLBACK)(
    _In_ PESILO ServerSilo,
    _In_ PVOID Context
    );

//
// Context cleanup callback, called when the reference count on a monitor
// context goes to zero.
//

typedef
VOID
(*PSERVER_SILO_MONITOR_CONTEXT_CLEANUP_CALLBACK)(
    _In_ PVOID Context
    );

//
// Version number of the monitor registration structure. Must be incremented
// when new fields are added (to the end!) of the structure.
//

#define SERVER_SILO_MONITOR_REGISTRATION_VERSION 1

typedef struct _SERVER_SILO_MONITOR_REGISTRATION {

    union {
        struct {
            USHORT Version;
            USHORT UsePagedPoolForContexts : 1;
        };
        ULONG_PTR Reserved;
    };

    PSERVER_SILO_MONITOR_CREATE_CALLBACK CreateCallback;
    PSERVER_SILO_MONITOR_TERMINATE_CALLBACK TerminateCallback;
    PSERVER_SILO_MONITOR_DRIVER_LOAD_CALLBACK DriverLoadCallback;
    PSERVER_SILO_MONITOR_DRIVER_UNLOAD_CALLBACK DriverUnloadCallback;
    PSERVER_SILO_MONITOR_CONTEXT_CLEANUP_CALLBACK ContextCleanupCallback;

} SERVER_SILO_MONITOR_REGISTRATION, *PSERVER_SILO_MONITOR_REGISTRATION;

typedef struct _SERVER_SILO_MONITOR *PSERVER_SILO_MONITOR;

NTKERNELAPI
NTSTATUS
PsRegisterMonitorServerSilo(
    _In_opt_ struct _DRIVER_OBJECT *DriverObject,
    _In_opt_ PWSTR ComponentName,
    _In_ PSERVER_SILO_MONITOR_REGISTRATION Registration,
    _Outptr_ PSERVER_SILO_MONITOR *Monitor
    );

NTKERNELAPI
NTSTATUS
PsStartMonitorServerSilo(
    _In_ PSERVER_SILO_MONITOR Monitor
    );

NTKERNELAPI
VOID
PsUnregisterMonitorServerSilo(
    _In_ PSERVER_SILO_MONITOR Monitor
    );

NTKERNELAPI
NTSTATUS
PsAllocateMonitorContextServerSilo(
    _In_ PSERVER_SILO_MONITOR Monitor,
    _In_ SIZE_T Size,
    _Outptr_result_bytebuffer_(Size) PVOID *Context
    );

NTKERNELAPI
NTSTATUS
PsSetMonitorContextServerSilo(
    _In_ PSERVER_SILO_MONITOR Monitor,
    _In_ PESILO ServerSilo,
    _In_ BOOLEAN ReplaceIfExists,
    _In_ PVOID NewContext,
    _Outptr_opt_result_maybenull_ PVOID *OldContext
    );

NTKERNELAPI
NTSTATUS
PsGetMonitorContextServerSilo(
    _In_ PSERVER_SILO_MONITOR Monitor,
    _In_ PESILO ServerSilo,
    _Outptr_ PVOID *Context
    );

NTKERNELAPI
VOID
PsDeleteMonitorContextServerSilo(
    _In_ PVOID Context
    );

NTKERNELAPI
VOID
PsReferenceMonitorContextServerSilo(
    _In_ PVOID Context
    );

NTKERNELAPI
VOID
PsDereferenceMonitorContextServerSilo(
    _In_ PVOID Context
    );

// Accessor methods on ESERVERSILO_GLOBALS
NTKERNELAPI
COMPARTMENT_ID
PsGetServerSiloDefaultCompartmentId(
    _In_ PESILO Silo
    );

NTKERNELAPI
ULONG
PsGetServerSiloServiceSessionId(
    _In_ PESILO Silo
    );

// Detect if we're running in a DPC.
NTKERNELAPI
BOOLEAN
PsIsDpcActive();

#endif


#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
NTKERNELAPI
VOID
PsUpdateComponentPower (
    _Inout_ PEPROCESS Process,
    _In_ PROCESS_ENERGY_COMPONENT_TYPE_NUM ComponentType,
    _In_ ULONG64 IncrementEnergy
    );
#endif

typedef
NTSTATUS
PS_SET_CONTEXT_THREAD_INTERNAL (
    __in PETHREAD Thread,
    __in PCONTEXT ThreadContext,
    __in KPROCESSOR_MODE ProbeMode,
    __in KPROCESSOR_MODE CtxMode,
    __in BOOLEAN PerformUnwind
    );

typedef PS_SET_CONTEXT_THREAD_INTERNAL *PPS_SET_CONTEXT_THREAD_INTERNAL;

typedef
NTSTATUS
PS_GET_CONTEXT_THREAD_INTERNAL (
    __in PETHREAD Thread,
    __inout PCONTEXT ThreadContext,
    __in KPROCESSOR_MODE ProbeMode,
    __in KPROCESSOR_MODE CtxMode,
    __in BOOLEAN PerformUnwind
    );

typedef PS_GET_CONTEXT_THREAD_INTERNAL *PPS_GET_CONTEXT_THREAD_INTERNAL;

typedef
NTSTATUS
PS_TERMINATE_THREAD (
    __inout PETHREAD Thread,
    __in NTSTATUS ExitStatus,
    __in BOOLEAN DirectTerminate
    );

typedef PS_TERMINATE_THREAD *PPS_TERMINATE_THREAD;

#define PS_PICO_CREATE_PROCESS_CLONE_PARENT             0x1
#define PS_PICO_CREATE_PROCESS_INHERIT_HANDLES          0x2
#define PS_PICO_CREATE_PROCESS_CLONE_REDUCED_COMMIT     0x4
#define PS_PICO_CREATE_PROCESS_BREAKAWAY                0x8
#define PS_PICO_CREATE_PROCESS_PACKAGED_PROCESS         0x10

#define PS_PICO_CREATE_PROCESS_FLAGS_MASK ( \
    PS_PICO_CREATE_PROCESS_CLONE_PARENT | \
    PS_PICO_CREATE_PROCESS_INHERIT_HANDLES | \
    PS_PICO_CREATE_PROCESS_CLONE_REDUCED_COMMIT | \
    PS_PICO_CREATE_PROCESS_BREAKAWAY | \
    PS_PICO_CREATE_PROCESS_PACKAGED_PROCESS)

typedef struct _PS_PICO_PROCESS_ATTRIBUTES {
    HANDLE ParentProcess;
    HANDLE Token;
    PVOID Context;
    ULONG Flags;
} PS_PICO_PROCESS_ATTRIBUTES, *PPS_PICO_PROCESS_ATTRIBUTES;

typedef struct _PS_PICO_THREAD_ATTRIBUTES {
    HANDLE Process;
    ULONG_PTR UserStack;
    ULONG_PTR StartRoutine;
    ULONG_PTR StartParameter1;
    ULONG_PTR StartParameter2;

#if defined(_AMD64_)

    ULONG UserFsBase;
    ULONG64 UserGsBase;

#elif defined(_X86_)

    ULONG UserFsBase;
    ULONG UserGsBase;

    USHORT UserFsSeg;
    USHORT UserGsSeg;

    ULONG_PTR Eax;
    ULONG_PTR Ebx;
    ULONG_PTR Ecx;
    ULONG_PTR Edx;
    ULONG_PTR Edi;
    ULONG_PTR Esi;
    ULONG_PTR Ebp;

#elif defined(_ARM_)

    ULONG UserRoBase;
    ULONG UserRwBase;

    ULONG Lr;
    ULONG R2;
    ULONG R3;
    ULONG R4;
    ULONG R5;
    ULONG R6;
    ULONG R7;
    ULONG R8;
    ULONG R9;
    ULONG R10;
    ULONG R11;
    ULONG R12;

#endif

    PVOID Context;

} PS_PICO_THREAD_ATTRIBUTES, *PPS_PICO_THREAD_ATTRIBUTES;

typedef
NTSTATUS
PS_PICO_CREATE_PROCESS (
    _In_ PPS_PICO_PROCESS_ATTRIBUTES ProcessAttributes,
    _Outptr_ PHANDLE ProcessHandle
    );

typedef PS_PICO_CREATE_PROCESS *PPS_PICO_CREATE_PROCESS;

typedef
NTSTATUS
PS_PICO_CREATE_THREAD (
    _In_ PPS_PICO_THREAD_ATTRIBUTES ThreadAttributes,
    _Outptr_ PHANDLE ThreadHandle
    );

typedef PS_PICO_CREATE_THREAD *PPS_PICO_CREATE_THREAD;

typedef
PVOID
PS_PICO_GET_PROCESS_CONTEXT (
    _In_ PEPROCESS Process
    );

typedef PS_PICO_GET_PROCESS_CONTEXT *PPS_PICO_GET_PROCESS_CONTEXT;

typedef
PVOID
PS_PICO_GET_THREAD_CONTEXT (
    _In_ PETHREAD Thread
    );

typedef PS_PICO_GET_THREAD_CONTEXT *PPS_PICO_GET_THREAD_CONTEXT;

typedef enum _PS_PICO_THREAD_DESCRIPTOR_TYPE {

#if defined(_X86_) || defined(_AMD64_)

    PicoThreadDescriptorTypeFs,
    PicoThreadDescriptorTypeGs,

#elif defined(_ARM_)

    PicoThreadDescriptorTypeUserRo,
    PicoThreadDescriptorTypeUserRw,

#endif

    PicoThreadDescriptorTypeMax

} PS_PICO_THREAD_DESCRIPTOR_TYPE, *PPS_PICO_THREAD_DESCRIPTOR_TYPE;

typedef
VOID
PS_PICO_SET_THREAD_DESCRIPTOR_BASE (
    _In_ PS_PICO_THREAD_DESCRIPTOR_TYPE Type,
    _In_ ULONG_PTR Base
    );

typedef PS_PICO_SET_THREAD_DESCRIPTOR_BASE *PPS_PICO_SET_THREAD_DESCRIPTOR_BASE;

typedef struct _PS_PICO_ROUTINES {
    SIZE_T Size;
    PPS_PICO_CREATE_PROCESS CreateProcess;
    PPS_PICO_CREATE_THREAD CreateThread;
    PPS_PICO_GET_PROCESS_CONTEXT GetProcessContext;
    PPS_PICO_GET_THREAD_CONTEXT GetThreadContext;
    PPS_GET_CONTEXT_THREAD_INTERNAL GetContextThreadInternal;
    PPS_SET_CONTEXT_THREAD_INTERNAL SetContextThreadInternal;
    PPS_TERMINATE_THREAD TerminateThread;
    PPS_RESUME_THREAD ResumeThread;
    PPS_PICO_SET_THREAD_DESCRIPTOR_BASE SetThreadDescriptorBase;
    PPS_SUSPEND_THREAD SuspendThread;
} PS_PICO_ROUTINES, *PPS_PICO_ROUTINES;

typedef struct _PS_PICO_SYSTEM_CALL_INFORMATION {
    PKTRAP_FRAME TrapFrame;

#if defined(_ARM_)

    ULONG R4;
    ULONG R5;
    ULONG R7;

#endif

} PS_PICO_SYSTEM_CALL_INFORMATION, *PPS_PICO_SYSTEM_CALL_INFORMATION;

#if defined(_ARM_)

//
// Structure offsets known to assembler code that does not use genxx, verify
// that the offsets are the same for PsPicoSystemCallDispatch.
//

C_ASSERT(FIELD_OFFSET(PS_PICO_SYSTEM_CALL_INFORMATION, TrapFrame) == 0x00);
C_ASSERT(FIELD_OFFSET(PS_PICO_SYSTEM_CALL_INFORMATION, R4) == 0x04);
C_ASSERT(FIELD_OFFSET(PS_PICO_SYSTEM_CALL_INFORMATION, R5) == 0x08);
C_ASSERT(FIELD_OFFSET(PS_PICO_SYSTEM_CALL_INFORMATION, R7) == 0x0C);

#endif

typedef
VOID
PS_PICO_PROVIDER_SYSTEM_CALL_DISPATCH (
    _In_ PPS_PICO_SYSTEM_CALL_INFORMATION SystemCall
    );

typedef PS_PICO_PROVIDER_SYSTEM_CALL_DISPATCH *PPS_PICO_PROVIDER_SYSTEM_CALL_DISPATCH;

typedef
VOID
PS_PICO_PROVIDER_THREAD_EXIT (
    _In_ PETHREAD Thread
    );

typedef PS_PICO_PROVIDER_THREAD_EXIT *PPS_PICO_PROVIDER_THREAD_EXIT;

typedef
VOID
PS_PICO_PROVIDER_PROCESS_EXIT (
    _In_ PEPROCESS Process
    );

typedef PS_PICO_PROVIDER_PROCESS_EXIT *PPS_PICO_PROVIDER_PROCESS_EXIT;

typedef
BOOLEAN
PS_PICO_PROVIDER_DISPATCH_EXCEPTION (
    _Inout_ PEXCEPTION_RECORD ExceptionRecord,
    _Inout_ PKEXCEPTION_FRAME ExceptionFrame,
    _Inout_ PKTRAP_FRAME TrapFrame,
    _In_ ULONG Chance,
    _In_ KPROCESSOR_MODE PreviousMode
    );

typedef PS_PICO_PROVIDER_DISPATCH_EXCEPTION *PPS_PICO_PROVIDER_DISPATCH_EXCEPTION;

typedef
NTSTATUS
PS_PICO_PROVIDER_TERMINATE_PROCESS (
    _In_ PEPROCESS Process,
    _In_ NTSTATUS TerminateStatus
    );

typedef PS_PICO_PROVIDER_TERMINATE_PROCESS *PPS_PICO_PROVIDER_TERMINATE_PROCESS;

typedef
_Ret_range_(<=, FrameCount)
ULONG
PS_PICO_PROVIDER_WALK_USER_STACK (
    _In_ PKTRAP_FRAME TrapFrame,
    _Out_writes_to_(FrameCount, return) PVOID *Callers,
    _In_ ULONG FrameCount
    );

typedef PS_PICO_PROVIDER_WALK_USER_STACK *PPS_PICO_PROVIDER_WALK_USER_STACK;

typedef struct _PS_PICO_PROVIDER_ROUTINES {
    SIZE_T Size;
    PPS_PICO_PROVIDER_SYSTEM_CALL_DISPATCH DispatchSystemCall;
    PPS_PICO_PROVIDER_THREAD_EXIT ExitThread;
    PPS_PICO_PROVIDER_PROCESS_EXIT ExitProcess;
    PPS_PICO_PROVIDER_DISPATCH_EXCEPTION DispatchException;
    PPS_PICO_PROVIDER_TERMINATE_PROCESS TerminateProcess;
    PPS_PICO_PROVIDER_WALK_USER_STACK WalkUserStack;
    CONST KADDRESS_RANGE_DESCRIPTOR *ProtectedRanges;
} PS_PICO_PROVIDER_ROUTINES, *PPS_PICO_PROVIDER_ROUTINES;

#if (NTDDI_VERSION >= NTDDI_THRESHOLD)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
PsRegisterPicoProvider (
    _In_ PPS_PICO_PROVIDER_ROUTINES ProviderRoutines,
    _Inout_ PPS_PICO_ROUTINES PicoRoutines
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

//
// SILOS:
//
// Other components in NTOS can add fields here and cleanup code in PsServerSiloDelete
//

#define SILO_KCB_LOCK_ENTRIES 0x40

typedef struct _ESERVERSILO_GLOBALS {
    ULONG               ServiceSessionId;
    UNICODE_STRING      SiloRootDirectoryName;
    HANDLE              SiloRootDirectoryHandle;

    // Hard Error handling - default error port and process in server silo
    ULONG     HardErrorState;
    PEPROCESS ExpDefaultErrorPortProcess;
    HANDLE    ExpDefaultErrorPort;

    // MM Session Leader
    PEPROCESS MiSessionLeaderProcess;

    //Misc. data for other drivers and components

    _Field_size_(MonitorContextArrayLength)
    PVOID *MonitorContextArray;

    ULONG MonitorContextArrayLength;

    // Preallocate a work item to not have to handle error case in terminate
    WORK_QUEUE_ITEM    TerminateWorkItem;

    // State of Server Silo Object
    SERVERSILO_STATE  State;

    //
    // Default network compartment ID for the silo.
    //
    COMPARTMENT_ID DefaultCompartmentId;

    // Security Port for SystemProcess
    PVOID          SystemProcessSecurityPort;

} ESERVERSILO_GLOBALS, *PESERVERSILO_GLOBALS;

NTKERNELAPI
SERVERSILO_STATE
PsGetServerSiloState(
    _In_opt_ PESILO Silo
    );

//
// Get pointer to the server silo globals
//
// Note that this does not keep a reference to the Silo so caller should ensure current silo does not go away
//
NTKERNELAPI
PESERVERSILO_GLOBALS
PsGetServerSiloGlobals(
    _In_ PESILO Silo
    );

//
// Get pointer to the current server silo globals
//
NTKERNELAPI
PESERVERSILO_GLOBALS
PsGetCurrentServerSiloGlobals(
    );

//
// Returns the Silo that corresponds to the Server Silo this Silo is in.
//
// Often this is the same. For Nested App Silo this returns the parent silo
// that is a server silo.
//
// No object references are held by calling this routine
//
NTKERNELAPI
PESILO
PspGetServerSiloForSilo(
    _In_ PESILO Silo
    );
#endif

// begin_ntosifs

#define CONTAINER_INFO_FLAG_CHARGE_ONLY 1

typedef struct _CONTAINER_ID_INFO {
    GUID ContainerId;
    ULONG Flags;
} CONTAINER_ID_INFO, *PCONTAINER_ID_INFO;

typedef enum _CONTAINER_TYPE {
    ContainerTypeCpu,
    ContainerTypeDiskIo,
    ContainerTypeNetIo,
//    ContainerTypeWorkingSet,
    ContainerTypeHeap,
    ContainerTypeImmediate,
    ContainerTypeMaximumList
} CONTAINER_TYPE, *PCONTAINER_TYPE;

#if (NTDDI_VERSION >= NTDDI_WIN10)

_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
PsGetEffectiveContainerId(
    _In_ CONTAINER_TYPE ContainerType,
    _In_ PETHREAD Thread,
    _Out_ PCONTAINER_ID_INFO ContainerIdInfo
    );

#endif


typedef struct _OBJECT_DUMP_CONTROL {
    PVOID Stream;
    ULONG Detail;
} OB_DUMP_CONTROL, *POB_DUMP_CONTROL;

typedef VOID (*OB_DUMP_METHOD)(
    _In_ PVOID Object,
    _In_opt_ POB_DUMP_CONTROL Control
    );

typedef enum _OB_OPEN_REASON {
    ObCreateHandle,
    ObOpenHandle,
    ObDuplicateHandle,
    ObInheritHandle,
    ObMaxOpenReason
} OB_OPEN_REASON;

typedef NTSTATUS (*OB_OPEN_METHOD)(
    _In_ OB_OPEN_REASON OpenReason,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_opt_ PEPROCESS Process,
    _In_ PVOID Object,
    _Inout_ PACCESS_MASK GrantedAccess,
    _In_ ULONG HandleCount
    );

typedef BOOLEAN (*OB_OKAYTOCLOSE_METHOD)(
    _In_opt_ PEPROCESS Process,
    _In_ PVOID Object,
    _In_ HANDLE Handle,
    _In_ KPROCESSOR_MODE PreviousMode
    );

typedef VOID (*OB_CLOSE_METHOD)(
    _In_opt_ PEPROCESS Process,
    _In_ PVOID Object,
    _In_ ULONG_PTR ProcessHandleCount,
    _In_ ULONG_PTR SystemHandleCount
    );

typedef VOID (*OB_DELETE_METHOD)(
    _In_  PVOID   Object
    );

typedef NTSTATUS (*OB_PARSE_METHOD)(
    _In_ PVOID ParseObject,
    _In_ PVOID ObjectType,
    _Inout_ PACCESS_STATE AccessState,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ ULONG Attributes,
    _Inout_ PUNICODE_STRING CompleteName,
    _Inout_ PUNICODE_STRING RemainingName,
    _Inout_opt_ PVOID Context,
    _In_opt_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Out_ PVOID *Object
    );

typedef NTSTATUS (*OB_SECURITY_METHOD)(
    _In_ PVOID Object,
    _In_ SECURITY_OPERATION_CODE OperationCode,
    _In_ PSECURITY_INFORMATION SecurityInformation,
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Inout_ PULONG CapturedLength,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ POOL_TYPE PoolType,
    _In_ PGENERIC_MAPPING GenericMapping,
    _In_ KPROCESSOR_MODE Mode
    );

typedef NTSTATUS (*OB_QUERYNAME_METHOD)(
    _In_ PVOID Object,
    _In_ BOOLEAN HasObjectName,
    _Out_writes_bytes_opt_(Length) POBJECT_NAME_INFORMATION ObjectNameInfo,
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength,
    _In_ KPROCESSOR_MODE Mode
    );

// end_ntosifs end_nthal

/*

    A security method and its caller must obey the following w.r.t.
    capturing and probing parameters:

    For a query operation, the caller must pass a kernel space address for
    CapturedLength.  The caller should be able to assume that it points to
    valid data that will not change.  In addition, the SecurityDescriptor
    parameter (which will receive the result of the query operation) must
    be probed for write up to the length given in CapturedLength.  The
    security method itself must always write to the SecurityDescriptor
    buffer in a try clause in case the caller de-allocates it.

    For a set operation, the SecurityDescriptor parameter must have
    been captured via SeCaptureSecurityDescriptor.  This parameter is
    not optional, and therefore may not be NULL.

*/



//
// Prototypes for Win32 WindowStation and Desktop object callout routines
//
typedef struct _WIN32_OPENMETHOD_PARAMETERS {
   OB_OPEN_REASON OpenReason;
   PEPROCESS Process;
   PVOID Object;
   ACCESS_MASK GrantedAccess;
   ULONG HandleCount;
} WIN32_OPENMETHOD_PARAMETERS, *PKWIN32_OPENMETHOD_PARAMETERS;

typedef struct _WIN32_OKAYTOCLOSEMETHOD_PARAMETERS {
   PEPROCESS Process;
   PVOID Object;
   HANDLE Handle;
   KPROCESSOR_MODE PreviousMode;
} WIN32_OKAYTOCLOSEMETHOD_PARAMETERS, *PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS;

typedef struct _WIN32_CLOSEMETHOD_PARAMETERS {
   PEPROCESS Process;
   PVOID Object;
   ULONG ProcessHandleCount;
   ULONG SystemHandleCount;
} WIN32_CLOSEMETHOD_PARAMETERS, *PKWIN32_CLOSEMETHOD_PARAMETERS;

typedef struct _WIN32_DELETEMETHOD_PARAMETERS {
   PVOID Object;
} WIN32_DELETEMETHOD_PARAMETERS, *PKWIN32_DELETEMETHOD_PARAMETERS;

typedef struct _WIN32_PARSEMETHOD_PARAMETERS {
   PVOID ParseObject;
   PVOID ObjectType;
   PACCESS_STATE AccessState;
   KPROCESSOR_MODE AccessMode;
   ULONG Attributes;
   PUNICODE_STRING CompleteName;
   PUNICODE_STRING RemainingName;
   PVOID Context;
   PSECURITY_QUALITY_OF_SERVICE SecurityQos;
   PVOID *Object;
} WIN32_PARSEMETHOD_PARAMETERS, *PKWIN32_PARSEMETHOD_PARAMETERS;

//
// Object Type Structure
//

// begin_ntosifs begin_nthal

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int
#endif

typedef struct _OBJECT_TYPE_INITIALIZER {
    USHORT Length;
    union {
        UCHAR ObjectTypeFlags;
        struct {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };

    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    OB_DUMP_METHOD DumpProcedure;
    OB_OPEN_METHOD OpenProcedure;
    OB_CLOSE_METHOD CloseProcedure;
    OB_DELETE_METHOD DeleteProcedure;
    OB_PARSE_METHOD ParseProcedure;
    OB_SECURITY_METHOD SecurityProcedure;
    OB_QUERYNAME_METHOD QueryNameProcedure;
    OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

// end_ntosifs end_nthal


typedef struct _OBJECT_TYPE {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;            // Copy from object header for convenience
    PVOID DefaultObject;
    UCHAR Index;
    __volatile ULONG TotalNumberOfObjects;
    __volatile ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE, *POBJECT_TYPE;

#define OB_TYPEINIT_FLAG_SUPPORTS_CALLBACKS     0x40

//
// Object Directory Structure
//

#define NUMBER_HASH_BUCKETS         37
#define OBJ_INVALID_SESSION_ID      0xFFFFFFFF

#define OBP_DIRECTORY_NAMESPACE     0x00000001
#define OBP_NAMESPACE_DELETED       0x00000002
#define OBP_SEARCH_SHADOW           0x00000004
#define OBP_INHERIT_SECURITY        0x00000008

typedef struct _OBJECT_DIRECTORY {

    struct _OBJECT_DIRECTORY_ENTRY *HashBuckets[ NUMBER_HASH_BUCKETS ];
    EX_PUSH_LOCK Lock;
    struct _DEVICE_MAP *DeviceMap;
    struct _OBJECT_DIRECTORY* ShadowDirectory;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;

} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _OBJECT_CREATE_INFORMATION *POBJECT_CREATE_INFORMATION;

typedef struct _OBJECT_HEADER {
    __volatile LONG_PTR PointerCount;
    union {
        __volatile LONG_PTR HandleCount;
        PVOID NextToFree;
    };

    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;

#define OB_OBJECT_REF_TRACE                 0x1
#define OB_OBJECT_TRACE_PERMANENT           0x2
    union {
        UCHAR TraceFlags;
        struct {
            UCHAR DbgRefTrace       : 1;
            UCHAR DbgTracePermanent : 1;
        };
    };

    UCHAR InfoMask;

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_KERNEL_ONLY_ACCESS      0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

    union {
        UCHAR Flags;
        struct {
            UCHAR NewObject : 1;
            UCHAR KernelObject : 1;
            UCHAR KernelOnlyAccess : 1;
            UCHAR ExclusiveObject : 1;
            UCHAR PermanentObject : 1;
            UCHAR DefaultSecurityQuota : 1;
            UCHAR SingleHandleEntry : 1;
            UCHAR DeletedInline : 1;
        };
    };

#if defined(_WIN64)

    ULONG Spare;

#endif

    union {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PSECURITY_DESCRIPTOR SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    LONG ReferenceCount;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

POBJECT_HEADER_NAME_INFO
ObQueryNameInfo (
    _In_ PVOID Object
    );

NTSTATUS
ObQueryNameStringMode(
    _In_ PVOID Object,
    _Out_writes_bytes_opt_(Length)POBJECT_NAME_INFORMATION ObjectNameInfo,
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength,
    _In_ KPROCESSOR_MODE Mode
    );

POBJECT_TYPE
ObGetObjectType (
    _In_ PVOID Object
    );
#define OBJECT_TO_OBJECT_HEADER( o ) \
    CONTAINING_RECORD( (o), OBJECT_HEADER, Body )

NTKERNELAPI
NTSTATUS
ObCreateObjectType(
    _In_ PUNICODE_STRING TypeName,
    _In_ POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Outptr_ POBJECT_TYPE *ObjectType
    );

NTKERNELAPI
NTSTATUS
ObCreateObjectTypeEx(
    _In_ PUNICODE_STRING TypeName,
    _In_ POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ LONG_PTR WaitObjectInfo,
    _Outptr_ POBJECT_TYPE *ObjectType
    );

#define OBJ_PROTECT_CLOSE       0x00000001L


NTKERNELAPI
NTSTATUS
ObReferenceFileObjectForWrite(
    _In_ HANDLE Handle,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PVOID *FileObject,
    _Out_ POBJECT_HANDLE_INFORMATION HandleInformation
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Inout_opt_ PACCESS_STATE AccessState,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Inout_opt_ PVOID ParseContext,
    _Out_ PHANDLE Handle
    );

// begin_ntosifs

NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
    _In_ PUNICODE_STRING ObjectName,
    _In_ ULONG Attributes,
    _In_opt_ PACCESS_STATE AccessState,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Inout_opt_ PVOID ParseContext,
    _Out_ PVOID *Object
    );

// end_ntosifs


NTKERNELAPI
BOOLEAN
ObFindHandleForObject(
    _In_ PEPROCESS Process,
    _In_opt_ PVOID Object,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_opt_ POBJECT_HANDLE_INFORMATION MatchCriteria,
    _Out_ PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObLogSecurityDescriptor (
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *OutputSecurityDescriptor,
    _In_ ULONG RefBias
    );

NTKERNELAPI
VOID
ObDereferenceSecurityDescriptor (
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Count
    );

NTKERNELAPI
VOID
ObReferenceSecurityDescriptor (
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Count
    );

NTKERNELAPI
BOOLEAN
ObCheckCreateObjectAccess(
    _In_ PVOID DirectoryObject,
    _In_ ACCESS_MASK CreateAccess,
    _In_ PACCESS_STATE AccessState,
    _In_ PUNICODE_STRING ComponentName,
    _In_ BOOLEAN TypeMutexLocked,
    _In_ KPROCESSOR_MODE PreviousMode,
    _Out_ PNTSTATUS AccessStatus
   );

NTKERNELAPI
BOOLEAN
ObCheckObjectAccess(
    _In_ PVOID Object,
    _Inout_ PACCESS_STATE AccessState,
    _In_ BOOLEAN TypeMutexLocked,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PNTSTATUS AccessStatus
    );


NTKERNELAPI
NTSTATUS
ObAssignSecurity(
    _In_ PACCESS_STATE AccessState,
    _In_opt_ PSECURITY_DESCRIPTOR ParentDescriptor,
    _In_ PVOID Object,
    _In_ POBJECT_TYPE ObjectType
    );


// begin_ntosifs

NTKERNELAPI
NTSTATUS
ObSetSecurityObjectByPointer (
    _In_ PVOID Object,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );

// end_ntosifs

NTKERNELAPI
NTSTATUS
ObSetHandleAttributes (
    _In_ HANDLE Handle,
    _In_ POBJECT_HANDLE_FLAG_INFORMATION HandleFlags,
    _In_ KPROCESSOR_MODE PreviousMode
    );

NTKERNELAPI
NTSTATUS
ObSetSecurityDescriptorInfo(
    _In_ PVOID Object,
    _In_ PSECURITY_INFORMATION SecurityInformation,
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Inout_ PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    _In_ POOL_TYPE PoolType,
    _In_ PGENERIC_MAPPING GenericMapping
    );
//
// Object Manager types
//

typedef struct _OBJECT_HANDLE_INFORMATION {
    ULONG HandleAttributes;
    ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;

// end_wdm
// begin_nthal

NTKERNELAPI
VOID
ObDeleteCapturedInsertInfo(
    _In_ PVOID Object
    );

// begin_ntosifs

NTKERNELAPI
NTSTATUS
ObCreateObject(
    _In_ KPROCESSOR_MODE ProbeMode,
    _In_ POBJECT_TYPE ObjectType,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ KPROCESSOR_MODE OwnershipMode,
    _Inout_opt_ PVOID ParseContext,
    _In_ ULONG ObjectBodySize,
    _In_ ULONG PagedPoolCharge,
    _In_ ULONG NonPagedPoolCharge,
    _Outptr_ PVOID *Object
    );

// end_ntosifs

// begin_ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObInsertObject(
    _In_ PVOID Object,
    _Inout_opt_ PACCESS_STATE PassedAccessState,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _In_ ULONG ObjectPointerBias,
    _Out_opt_ PVOID *NewObject,
    _Out_opt_ PHANDLE Handle
    );
#endif

// end_nthal end_ntifs

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
ObReferenceObjectByHandle(
    _In_ HANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PVOID *Object,
    _Out_opt_ POBJECT_HANDLE_INFORMATION HandleInformation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
ObReferenceObjectByHandleWithTag(
    _In_ HANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ ULONG Tag,
    _Out_ PVOID *Object,
    _Out_opt_ POBJECT_HANDLE_INFORMATION HandleInformation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)

NTKERNELAPI
BOOLEAN
FASTCALL
ObReferenceObjectSafe (
    _In_ PVOID Object
    );

NTKERNELAPI
BOOLEAN
FASTCALL
ObReferenceObjectSafeWithTag (
    _In_ PVOID Object,
    _In_ ULONG Tag
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
NTSTATUS
ObCloseHandle (
    _In_ HANDLE Handle,
    _In_ KPROCESSOR_MODE PreviousMode
    );
#endif


// end_wdm

CFORCEINLINE
NTSTATUS
_ObReferenceObjectByHandle(
    _In_ HANDLE Handle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PVOID *pObject,
    _Out_opt_ POBJECT_HANDLE_INFORMATION pHandleInformation
    )
{
    PVOID Object;
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle (Handle,
                                        DesiredAccess,
                                        ObjectType,
                                        AccessMode,
                                        &Object,
                                        pHandleInformation);

    *pObject = Object;
    return Status;
}

#define ObReferenceObjectByHandle _ObReferenceObjectByHandle

// begin_ntifs
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObOpenObjectByPointer(
    _In_ PVOID Object,
    _In_ ULONG HandleAttributes,
    _In_opt_ PACCESS_STATE PassedAccessState,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Out_ PHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
NTSTATUS
ObOpenObjectByPointerWithTag(
    _In_ PVOID Object,
    _In_ ULONG HandleAttributes,
    _In_opt_ PACCESS_STATE PassedAccessState,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ ULONG Tag,
    _Out_ PHANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ObMakeTemporaryObject(
    _In_ PVOID Object
    );
#endif

// end_ntifs
// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WIN7)

#define ObDereferenceObject(a)                                     \
        ObfDereferenceObject(a)

#define ObReferenceObject(Object) ObfReferenceObject(Object)

#define ObDereferenceObjectWithTag(a, t)                                \
        ObfDereferenceObjectWithTag(a, t)

#define ObReferenceObjectWithTag(Object, Tag) ObfReferenceObjectWithTag(Object, Tag)

#else

#define ObDereferenceObject(a)                                     \
        ObfDereferenceObject(a)

#define ObReferenceObject(Object) ObfReferenceObject(Object)

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG_PTR
FASTCALL
ObfReferenceObject(
    _In_ PVOID Object
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG_PTR
FASTCALL
ObfReferenceObjectWithTag(
    _In_ PVOID Object,
    _In_ ULONG Tag
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    _In_ PVOID Object,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointerWithTag(
    _In_ PVOID Object,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ ULONG Tag
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG_PTR
FASTCALL
ObfDereferenceObject(
    _In_ PVOID Object
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LONG_PTR
FASTCALL
ObfDereferenceObjectWithTag(
    _In_ PVOID Object,
    _In_ ULONG Tag
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
ObDereferenceObjectDeferDelete(
    _In_ PVOID Object
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
ObDereferenceObjectDeferDeleteWithTag(
    _In_ PVOID Object,
    _In_ ULONG Tag
    );
#endif

// end_wdm

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
ObWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
ObWaitForMultipleObjects (
    _In_range_(<=, MAXIMUM_WAIT_OBJECTS) ULONG Count,
    _In_reads_(Count) HANDLE CapturedHandles[],
    _In_ KPROCESSOR_MODE AccessMode,
    _In_ WAIT_TYPE WaitType,
    _In_ KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );

// begin_ntifs
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObQueryNameString(
    _In_ PVOID Object,
    _Out_writes_bytes_opt_(Length) POBJECT_NAME_INFORMATION ObjectNameInfo,
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
BOOLEAN
ObIsKernelHandle (
    _In_ HANDLE Handle
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
ObGetObjectSecurity(
    _In_ PVOID Object,
    _Out_ PSECURITY_DESCRIPTOR *SecurityDescriptor,
    _Out_ PBOOLEAN MemoryAllocated
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
ObReleaseObjectSecurity(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN MemoryAllocated
    );
#endif

// end_wdm
#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
ObIsDosDeviceLocallyMapped(
    _In_ ULONG DriveIndex,
    _Out_ PBOOLEAN LocallyMapped
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTSTATUS
ObDuplicateObject (
    _In_ PEPROCESS SourceProcess,
    _In_ HANDLE SourceHandle,
    _In_opt_ PEPROCESS TargetProcess,
    _Out_opt_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options,
    _In_ KPROCESSOR_MODE PreviousMode
    );
#endif

//
// Registration version for Vista SP1 and Windows Server 2007
//
#define OB_FLT_REGISTRATION_VERSION_0100  0x0100

//
// This value should be used by filters for registration
//
#define OB_FLT_REGISTRATION_VERSION OB_FLT_REGISTRATION_VERSION_0100

typedef ULONG OB_OPERATION;

#define OB_OPERATION_HANDLE_CREATE              0x00000001
#define OB_OPERATION_HANDLE_DUPLICATE           0x00000002

typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION {
    _Inout_ ACCESS_MASK         DesiredAccess;
    _In_ ACCESS_MASK            OriginalDesiredAccess;
} OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;

typedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {
    _Inout_ ACCESS_MASK         DesiredAccess;
    _In_ ACCESS_MASK            OriginalDesiredAccess;
    _In_ PVOID                  SourceProcess;
    _In_ PVOID                  TargetProcess;
} OB_PRE_DUPLICATE_HANDLE_INFORMATION, * POB_PRE_DUPLICATE_HANDLE_INFORMATION;

typedef union _OB_PRE_OPERATION_PARAMETERS {
    _Inout_ OB_PRE_CREATE_HANDLE_INFORMATION        CreateHandleInformation;
    _Inout_ OB_PRE_DUPLICATE_HANDLE_INFORMATION     DuplicateHandleInformation;
} OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;

typedef struct _OB_PRE_OPERATION_INFORMATION {
    _In_ OB_OPERATION           Operation;
    union {
        _In_ ULONG Flags;
        struct {
            _In_ ULONG KernelHandle:1;
            _In_ ULONG Reserved:31;
        };
    };
    _In_ PVOID                         Object;
    _In_ POBJECT_TYPE                  ObjectType;
    _Out_ PVOID                        CallContext;
    _In_ POB_PRE_OPERATION_PARAMETERS  Parameters;
} OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;

typedef struct _OB_POST_CREATE_HANDLE_INFORMATION {
    _In_ ACCESS_MASK            GrantedAccess;
} OB_POST_CREATE_HANDLE_INFORMATION, *POB_POST_CREATE_HANDLE_INFORMATION;

typedef struct _OB_POST_DUPLICATE_HANDLE_INFORMATION {
    _In_ ACCESS_MASK            GrantedAccess;
} OB_POST_DUPLICATE_HANDLE_INFORMATION, * POB_POST_DUPLICATE_HANDLE_INFORMATION;

typedef union _OB_POST_OPERATION_PARAMETERS {
    _In_ OB_POST_CREATE_HANDLE_INFORMATION       CreateHandleInformation;
    _In_ OB_POST_DUPLICATE_HANDLE_INFORMATION    DuplicateHandleInformation;
} OB_POST_OPERATION_PARAMETERS, *POB_POST_OPERATION_PARAMETERS;

typedef struct _OB_POST_OPERATION_INFORMATION {
    _In_ OB_OPERATION  Operation;
    union {
        _In_ ULONG Flags;
        struct {
            _In_ ULONG KernelHandle:1;
            _In_ ULONG Reserved:31;
        };
    };
    _In_ PVOID                          Object;
    _In_ POBJECT_TYPE                   ObjectType;
    _In_ PVOID                          CallContext;
    _In_ NTSTATUS                       ReturnStatus;
    _In_ POB_POST_OPERATION_PARAMETERS  Parameters;
} OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;

typedef enum _OB_PREOP_CALLBACK_STATUS {
    OB_PREOP_SUCCESS
} OB_PREOP_CALLBACK_STATUS, *POB_PREOP_CALLBACK_STATUS;

typedef OB_PREOP_CALLBACK_STATUS
(*POB_PRE_OPERATION_CALLBACK) (
    _In_ PVOID RegistrationContext,
    _Inout_ POB_PRE_OPERATION_INFORMATION OperationInformation
    );

typedef VOID
(*POB_POST_OPERATION_CALLBACK) (
    _In_ PVOID RegistrationContext,
    _In_ POB_POST_OPERATION_INFORMATION OperationInformation
    );

typedef struct _OB_OPERATION_REGISTRATION {
    _In_ POBJECT_TYPE                *ObjectType;
    _In_ OB_OPERATION                Operations;
    _In_ POB_PRE_OPERATION_CALLBACK  PreOperation;
    _In_ POB_POST_OPERATION_CALLBACK PostOperation;
} OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;

typedef struct _OB_CALLBACK_REGISTRATION {
    _In_ USHORT                     Version;
    _In_ USHORT                     OperationRegistrationCount;
    _In_ UNICODE_STRING             Altitude;
    _In_ PVOID                      RegistrationContext;
    _In_ OB_OPERATION_REGISTRATION  *OperationRegistration;
} OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
NTSTATUS
ObRegisterCallbacks (
    _In_ POB_CALLBACK_REGISTRATION CallbackRegistration,
    _Outptr_ PVOID *RegistrationHandle
    );

NTKERNELAPI
VOID
ObUnRegisterCallbacks (
    _In_ PVOID RegistrationHandle
    );

NTKERNELAPI
USHORT
ObGetFilterVersion ();
#endif

#ifndef _PCI_X_
#define _PCI_X_

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          _In_ BUS_DATA_TYPE        PCIConfiguration,
//          _In_ ULONG                PciBusNumber,
//          _In_ PCI_SLOT_NUMBER      VirtualSlotNumber,
//          _In_ PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          _In_ ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_ntminiport begin_ntndis
// begin_ntoshvp

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_HEADER {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_ntminiport begin_ntndis

    } u;

} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;

// end_ntoshvp

#ifdef __cplusplus

typedef struct _PCI_COMMON_CONFIG : PCI_COMMON_HEADER {
    UCHAR   DeviceSpecific[192];
} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;

#else

typedef struct _PCI_COMMON_CONFIG {
    PCI_COMMON_HEADER DUMMYSTRUCTNAME;
    UCHAR   DeviceSpecific[192];
} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;

#endif

#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))
#define PCI_EXTENDED_CONFIG_LENGTH          0x1000

// begin_ntoshvp

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

// end_ntoshvp

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

// begin_ntoshvp

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)
#define PCI_DISABLE_LEVEL_INTERRUPT         0x0400

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_INTERRUPT_PENDING        0x0008
#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

// end_ntoshvp

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

//
// PCI Capability IDs
//

// begin_ntoshvp

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_VPD               0x03
#define PCI_CAPABILITY_ID_SLOT_ID           0x04
#define PCI_CAPABILITY_ID_MSI               0x05
#define PCI_CAPABILITY_ID_CPCI_HOTSWAP      0x06
#define PCI_CAPABILITY_ID_PCIX              0x07
#define PCI_CAPABILITY_ID_HYPERTRANSPORT    0x08
#define PCI_CAPABILITY_ID_VENDOR_SPECIFIC   0x09
#define PCI_CAPABILITY_ID_DEBUG_PORT        0x0A
#define PCI_CAPABILITY_ID_CPCI_RES_CTRL     0x0B
#define PCI_CAPABILITY_ID_SHPC              0x0C
#define PCI_CAPABILITY_ID_P2P_SSID          0x0D
#define PCI_CAPABILITY_ID_AGP_TARGET        0x0E
#define PCI_CAPABILITY_ID_SECURE            0x0F
#define PCI_CAPABILITY_ID_PCI_EXPRESS       0x10
#define PCI_CAPABILITY_ID_MSIX              0x11
#define PCI_CAPABILITY_ID_SATA_CONFIG       0x12
#define PCI_CAPABILITY_ID_ADVANCED_FEATURES 0x13

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

// end_ntoshvp

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:1;
    USHORT      NoSoftReset:1;
    USHORT      Rsvd2:4;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

// end_wdm
// begin_ntddk

//
// AGP Capabilities
//
typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Agp3Mode:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   HostTransDisable:1;
        ULONG   Gart64:1;
        ULONG   ITA_Coherent:1;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   CalibrationCycle:3;
        ULONG   AsyncRequestSize:3;
        ULONG   Rsvd1:1;
        ULONG   Isoch:1;
        ULONG   Rsvd2:6;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:1;
        ULONG   Gart64:1;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   CalibrationCycle:3;
        ULONG   AsyncReqSize:3;
        ULONG   Rsvd3:8;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

//
// An AGPv3 Target must have an extended capability,
// but it's only present for a Master when the Isoch
// bit is set in its status register
//
typedef enum _EXTENDED_AGP_REGISTER {
    IsochStatus,
    AgpControl,
    ApertureSize,
    AperturePageSize,
    GartLow,
    GartHigh,
    IsochCommand
} EXTENDED_AGP_REGISTER, *PEXTENDED_AGP_REGISTER;

typedef struct _PCI_AGP_ISOCH_STATUS {
    ULONG ErrorCode: 2;
    ULONG Rsvd1: 1;
    ULONG Isoch_L: 3;
    ULONG Isoch_Y: 2;
    ULONG Isoch_N: 8;
    ULONG Rsvd2: 16;
} PCI_AGP_ISOCH_STATUS, *PPCI_AGP_ISOCH_STATUS;

typedef struct _PCI_AGP_CONTROL {
    ULONG Rsvd1: 7;
    ULONG GTLB_Enable: 1;
    ULONG AP_Enable: 1;
    ULONG CAL_Disable: 1;
    ULONG Rsvd2: 22;
} PCI_AGP_CONTROL, *PPCI_AGP_CONTROL;

typedef struct _PCI_AGP_APERTURE_PAGE_SIZE {
    USHORT PageSizeMask: 11;
    USHORT Rsvd1: 1;
    USHORT PageSizeSelect: 4;
} PCI_AGP_APERTURE_PAGE_SIZE, *PPCI_AGP_APERTURE_PAGE_SIZE;

typedef struct _PCI_AGP_ISOCH_COMMAND {
    USHORT Rsvd1: 6;
    USHORT Isoch_Y: 2;
    USHORT Isoch_N: 8;
} PCI_AGP_ISOCH_COMMAND, *PPCI_AGP_ISOCH_COMMAND;

typedef struct PCI_AGP_EXTENDED_CAPABILITY {

    PCI_AGP_ISOCH_STATUS IsochStatus;

//
// Target only ----------------<<-begin->>
//
    PCI_AGP_CONTROL AgpControl;
    USHORT ApertureSize;
    PCI_AGP_APERTURE_PAGE_SIZE AperturePageSize;
    ULONG GartLow;
    ULONG GartHigh;
//
// ------------------------------<<-end->>
//

    PCI_AGP_ISOCH_COMMAND IsochCommand;

} PCI_AGP_EXTENDED_CAPABILITY, *PPCI_AGP_EXTENDED_CAPABILITY;


#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

// end_ntddk
// begin_wdm

//
// PCI-X Capability
//

// begin_ntoshvp

typedef struct {

    PCI_CAPABILITIES_HEADER Header;

    union {
        struct {
            USHORT  DataParityErrorRecoveryEnable:1;
            USHORT  EnableRelaxedOrdering:1;
            USHORT  MaxMemoryReadByteCount:2;
            USHORT  MaxOutstandingSplitTransactions:3;
            USHORT  Reserved:9;
        } bits;
        USHORT  AsUSHORT;
    } Command;

    union {
        struct {
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Device64Bit:1;
            ULONG   Capable133MHz:1;
            ULONG   SplitCompletionDiscarded:1;
            ULONG   UnexpectedSplitCompletion:1;
            ULONG   DeviceComplexity:1;
            ULONG   DesignedMaxMemoryReadByteCount:2;
            ULONG   DesignedMaxOutstandingSplitTransactions:3;
            ULONG   DesignedMaxCumulativeReadSize:3;
            ULONG   ReceivedSplitCompletionErrorMessage:1;
            ULONG   CapablePCIX266:1;
            ULONG   CapablePCIX533:1;
        } bits;
        ULONG   AsULONG;
    } Status;
} PCI_X_CAPABILITY, *PPCI_X_CAPABILITY;

// end_wdm
// begin_ntddk

//
// PCI-X Bridge Capability
//

//
// Values for BusModeFrequency in the SecondaryStatus register
//
#define PCIX_MODE_CONVENTIONAL_PCI  0x0
#define PCIX_MODE1_66MHZ            0x1
#define PCIX_MODE1_100MHZ           0x2
#define PCIX_MODE1_133MHZ           0x3
#define PCIX_MODE2_266_66MHZ        0x9
#define PCIX_MODE2_266_100MHZ       0xA
#define PCIX_MODE2_266_133MHZ       0xB
#define PCIX_MODE2_533_66MHZ        0xD
#define PCIX_MODE2_533_100MHZ       0xE
#define PCIX_MODE2_533_133MHZ       0xF

//
// Values for the Version in the SecondaryStatus register
//
#define PCIX_VERSION_MODE1_ONLY     0x0
#define PCIX_VERSION_MODE2_ECC      0x1
#define PCIX_VERSION_DUAL_MODE_ECC  0x2

typedef struct _PCIX_BRIDGE_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    union {
        struct {
            USHORT Bus64Bit:1;
            USHORT Bus133MHzCapable:1;
            USHORT SplitCompletionDiscarded:1;
            USHORT UnexpectedSplitCompletion:1;
            USHORT SplitCompletionOverrun:1;
            USHORT SplitRequestDelayed:1;
            USHORT BusModeFrequency:4;  // PCIX_MODE_x
            USHORT Rsvd:2;
            USHORT Version:2;           // PCIX_VERSION_x
            USHORT Bus266MHzCapable:1;
            USHORT Bus533MHzCapable:1;
        } DUMMYSTRUCTNAME;
        USHORT AsUSHORT;
    } SecondaryStatus;

    union {
        struct {
            ULONG FunctionNumber:3;
            ULONG DeviceNumber:5;
            ULONG BusNumber:8;
            ULONG Device64Bit:1;
            ULONG Device133MHzCapable:1;
            ULONG SplitCompletionDiscarded:1;
            ULONG UnexpectedSplitCompletion:1;
            ULONG SplitCompletionOverrun:1;
            ULONG SplitRequestDelayed:1;
            ULONG Rsvd:7;
            ULONG DIMCapable:1;
            ULONG Device266MHzCapable:1;
            ULONG Device533MHzCapable:1;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } BridgeStatus;

    USHORT UpstreamSplitTransactionCapacity;
    USHORT UpstreamSplitTransactionLimit;

    USHORT DownstreamSplitTransactionCapacity;
    USHORT DownstreamSplitTransactionLimit;

    union {
        struct {
            ULONG SelectSecondaryRegisters:1;
            ULONG ErrorPresentInOtherBank:1;
            ULONG AdditionalCorrectableError:1;
            ULONG AdditionalUncorrectableError:1;
            ULONG ErrorPhase:3;
            ULONG ErrorCorrected:1;
            ULONG Syndrome:8;
            ULONG ErrorFirstCommand:4;
            ULONG ErrorSecondCommand:4;
            ULONG ErrorUpperAttributes:4;
            ULONG ControlUpdateEnable:1;
            ULONG Rsvd:1;
            ULONG DisableSingleBitCorrection:1;
            ULONG EccMode:1;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } EccControlStatus;

    ULONG EccFirstAddress;
    ULONG EccSecondAddress;
    ULONG EccAttribute;

} PCIX_BRIDGE_CAPABILITY, *PPCIX_BRIDGE_CAPABILITY;

// end_ntoshvp

//
// PCI to PCI Bridge Subsystem ID Capability
//
typedef struct _PCI_SUBSYSTEM_IDS_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;
    USHORT Reserved;
    USHORT SubVendorID;
    USHORT SubSystemID;

} PCI_SUBSYSTEM_IDS_CAPABILITY, *PPCI_SUBSYSTEM_IDS_CAPABILITY;

//
// PCI Advanced Features Capability
//

typedef struct _PCI_ADVANCED_FEATURES_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;
    UCHAR Length;

    union {
        struct {
            UCHAR FunctionLevelResetSupported:1;
            UCHAR TransactionsPendingSupported:1;
            UCHAR Rsvd:6;
        } DUMMYSTRUCTNAME;

        UCHAR AsUCHAR;
    } Capabilities;

    union {
        struct {
            UCHAR InitiateFunctionLevelReset:1;
            UCHAR Rsvd:7;
        } DUMMYSTRUCTNAME;

        UCHAR AsUCHAR;
    } Control;

    union {
        struct {
            UCHAR TransactionsPending:1;
            UCHAR Rsvd:7;
        } DUMMYSTRUCTNAME;

        UCHAR AsUCHAR;
    } Status;

} PCI_ADVANCED_FEATURES_CAPABILITY, *PPCI_ADVANCED_FEATURES_CAPABILITY;

//
// _OSC is used by OSPM to query the capabilities of a device and to
// communicate the features supported by the device driver to the platform.
// The _OSC interface for PCI host bridge devices that originate PCI, PCI-X or
// PCI Express hierarchies is identified by a UUID of {33db4d5b-1ff7-401c-9657-
// 7441c03dd766}. A revision ID of 1 indicates that the capabilities buffer is
// composed of 3 DWORDs.
// The first DWORD is common across all OSC implementations and includes status
// and error information.
// The second DWORD (Support Field) provides information regarding OS supported
// features.
// The third DWORD (Control Field) is used to submit request for control of
// associated features. If any bits in the control field are returned cleared,
// then the respective feature is unsupported by the platform and must not be
// enabled.
// According to the PCI Firmware Specification a machine with multiple host
// bridge devices should report the same capabilities for all host bridges
// and also negotiate control of the features in the same way.
//

#define OSC_FIRMWARE_FAILURE                            0x02
#define OSC_UNRECOGNIZED_UUID                           0x04
#define OSC_UNRECOGNIZED_REVISION                       0x08
#define OSC_CAPABILITIES_MASKED                         0x10

#define PCI_ROOT_BUS_OSC_METHOD_CAPABILITY_REVISION     0x01

//
// The following declarations pertain to the second and third DWORD in
// evaluation of _OSC for PCI host bridge devices.
//

typedef struct _PCI_ROOT_BUS_OSC_SUPPORT_FIELD {
    union {
        struct {
            ULONG ExtendedConfigOpRegions:1;
            ULONG ActiveStatePowerManagement:1;
            ULONG ClockPowerManagement:1;
            ULONG SegmentGroups:1;
            ULONG MessageSignaledInterrupts:1;
            ULONG OptimizedBufferFlushAndFill:1;
            ULONG AspmOptionality:1;
            ULONG Reserved:25;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } u;
} PCI_ROOT_BUS_OSC_SUPPORT_FIELD, *PPCI_ROOT_BUS_OSC_SUPPORT_FIELD;

typedef struct _PCI_ROOT_BUS_OSC_CONTROL_FIELD {
    union {
        struct {
            ULONG ExpressNativeHotPlug:1;
            ULONG ShpcNativeHotPlug:1;
            ULONG ExpressNativePME:1;
            ULONG ExpressAdvancedErrorReporting:1;
            ULONG ExpressCapabilityStructure:1;
            ULONG LatencyToleranceReporting:1;
            ULONG Reserved:26;
        } DUMMYSTRUCTNAME;
        ULONG AsULONG;
    } u;
} PCI_ROOT_BUS_OSC_CONTROL_FIELD, *PPCI_ROOT_BUS_OSC_CONTROL_FIELD;

//
// The following comes from the PCI Firmware Specification, version 3.1.  It
// defines bus capabilities as reported by an ACPI BIOS.
//

typedef struct _PCI_FIRMWARE_BUS_CAPS {
    USHORT Type;
    USHORT Length; // must be 16
    struct {
        UCHAR SixtyFourBitDevice:1;
        UCHAR PciXMode1EccCapable:1;
        UCHAR DeviceIdMessagingCapable:1;
        UCHAR ObffWakeSignalCapable:1;
        UCHAR Reserved1:4;
    } DUMMYSTRUCTNAME;
    UCHAR CurrentSpeedAndMode;
    UCHAR SupportedSpeedsAndModesLowByte;
    UCHAR SupportedSpeedsAndModesHighByte;
    UCHAR Voltage;
    UCHAR Reserved2[7];
} PCI_FIRMWARE_BUS_CAPS, *PPCI_FIRMWARE_BUS_CAPS;

typedef struct _PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER {
    USHORT Version;
    USHORT Status;
    ULONG  Length;
    PCI_FIRMWARE_BUS_CAPS Caps;
} PCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER, *PPCI_FIRMWARE_BUS_CAPS_RETURN_BUFFER;

//
// An enumerator for the PCI physical and electrical interface.
//

// begin_ntoshvp

typedef enum _PCI_HARDWARE_INTERFACE {

    PciConventional,
    PciXMode1,
    PciXMode2,
    PciExpress

} PCI_HARDWARE_INTERFACE, *PPCI_HARDWARE_INTERFACE;

// end_ntoshvp

typedef enum {

    BusWidth32Bits,
    BusWidth64Bits

} PCI_BUS_WIDTH;

typedef struct _PCI_ROOT_BUS_HARDWARE_CAPABILITY {

    //
    // Describes the secondary side of a PCI root bus.
    //

    PCI_HARDWARE_INTERFACE SecondaryInterface;

    //
    // These additional capabilities are available when each of the following
    // is true.
    // 1. The secondary side of a PCI root bus operates in conventional or
    //    PCI-X mode.
    // 2. The PCI root bus has a hardware ID or compatible ID of PNP0A03.
    // 3. A _DSM function 4 is defined for the root bus.
    //

    struct {

        //
        // This boolean indicates if the remaining fields describing the bus
        // capabilities are valid or not.
        //

        BOOLEAN BusCapabilitiesFound;


        //
        // Provides information on current and supported speeds/modes.
        //

        ULONG CurrentSpeedAndMode;
        ULONG SupportedSpeedsAndModes;

        //
        // Describes the root bus capability on forwarding of Device ID message
        // transactions.
        //

        BOOLEAN DeviceIDMessagingCapable;

        //
        // Provides the width for a PCI interface.
        //

        PCI_BUS_WIDTH SecondaryBusWidth;
    } DUMMYSTRUCTNAME;

    //
    // Fields describing features supported as well as control for them from
    // the bios.
    //

    PCI_ROOT_BUS_OSC_SUPPORT_FIELD OscFeatureSupport;
    PCI_ROOT_BUS_OSC_CONTROL_FIELD OscControlRequest;
    PCI_ROOT_BUS_OSC_CONTROL_FIELD OscControlGranted;

} PCI_ROOT_BUS_HARDWARE_CAPABILITY, *PPCI_ROOT_BUS_HARDWARE_CAPABILITY;

//
// PCI Express Capability
//

// begin_ntoshvp

typedef union _PCI_EXPRESS_CAPABILITIES_REGISTER {

    struct {

        USHORT CapabilityVersion:4;
        USHORT DeviceType:4;               // PCI_EXPRESS_DEVICE_TYPE
        USHORT SlotImplemented:1;
        USHORT InterruptMessageNumber:5;
        USHORT Rsvd:2;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_CAPABILITIES_REGISTER, *PPCI_EXPRESS_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER {

    struct {

        ULONG MaxPayloadSizeSupported:3;     // EXPRESS_MAX_PAYLOAD_SIZE
        ULONG PhantomFunctionsSupported:2;
        ULONG ExtendedTagSupported:1;
        ULONG L0sAcceptableLatency:3;        // EXPRESS_L0S_LATENCY
        ULONG L1AcceptableLatency:3;         // EXPRESS_L1_LATENCY
        ULONG Undefined:3;
        ULONG RoleBasedErrorReporting:1;
        ULONG Rsvd1:2;
        ULONG CapturedSlotPowerLimit:8;
        ULONG CapturedSlotPowerLimitScale:2;
        ULONG FunctionLevelResetCapability:1;
        ULONG Rsvd2:3;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER, *PPCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER;

//
// The low 3 bits of the PCI Express device control register dictate whether
// a device that implements AER routes error messages to the root complex.
// This mask is used when programming the AER bits in the device control
// register.
//

#define PCI_EXPRESS_AER_DEVICE_CONTROL_MASK 0x07;

typedef union _PCI_EXPRESS_DEVICE_CONTROL_REGISTER {

    struct {

        USHORT CorrectableErrorEnable:1;
        USHORT NonFatalErrorEnable:1;
        USHORT FatalErrorEnable:1;
        USHORT UnsupportedRequestErrorEnable:1;
        USHORT EnableRelaxedOrder:1;
        USHORT MaxPayloadSize:3;                 // EXPRESS_MAX_PAYLOAD_SIZE
        USHORT ExtendedTagEnable:1;
        USHORT PhantomFunctionsEnable:1;
        USHORT AuxPowerEnable:1;
        USHORT NoSnoopEnable:1;
        USHORT MaxReadRequestSize:3;             // EXPRESS_MAX_PAYLOAD_SIZE
        USHORT BridgeConfigRetryEnable:1;
    } DUMMYSTRUCTNAME;

    //
    // Hack to allow alias of BridgeConfigRetryEnable bit for FLR.
    //

    struct {
        USHORT :15;
        USHORT InitiateFunctionLevelReset:1;
    } DUMMYSTRUCTNAME2;

    USHORT AsUSHORT;

} PCI_EXPRESS_DEVICE_CONTROL_REGISTER, *PPCI_EXPRESS_DEVICE_CONTROL_REGISTER;

//
// The low 4 bits of the PCI Express device status register hold AER device
// status. This mask is used when programming the AER bits in the device status
// register.
//

#define PCI_EXPRESS_AER_DEVICE_STATUS_MASK 0x0F;

typedef union _PCI_EXPRESS_DEVICE_STATUS_REGISTER {

    struct {

        USHORT CorrectableErrorDetected:1;
        USHORT NonFatalErrorDetected:1;
        USHORT FatalErrorDetected:1;
        USHORT UnsupportedRequestDetected:1;
        USHORT AuxPowerDetected:1;
        USHORT TransactionsPending:1;
        USHORT Rsvd:10;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_DEVICE_STATUS_REGISTER, *PPCI_EXPRESS_DEVICE_STATUS_REGISTER;

typedef union _PCI_EXPRESS_LINK_CAPABILITIES_REGISTER {

    struct {

        ULONG MaximumLinkSpeed:4;
        ULONG MaximumLinkWidth:6;
        ULONG ActiveStatePMSupport:2;   // EXPRESS_ASPM_CONFIG
        ULONG L0sExitLatency:3;         // EXPRESS_L0S_LATENCY
        ULONG L1ExitLatency:3;          // EXPRESS_L1_LATENCY
        ULONG ClockPowerManagement:1;
        ULONG SurpriseDownErrorReportingCapable:1;
        ULONG DataLinkLayerActiveReportingCapable:1;
        ULONG LinkBandwidthNotificationCapability:1;
        ULONG AspmOptionalityCompliance:1;
        ULONG Rsvd:1;
        ULONG PortNumber:8;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_LINK_CAPABILITIES_REGISTER, *PPCI_EXPRESS_LINK_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_LINK_CONTROL_REGISTER {

    struct {

        USHORT ActiveStatePMControl:2;    // EXPRESS_ASPM_CONFIG
        USHORT Rsvd1:1;
        USHORT ReadCompletionBoundary:1;  // EXPRESS_RCB
        USHORT LinkDisable:1;
        USHORT RetrainLink:1;
        USHORT CommonClockConfig:1;
        USHORT ExtendedSynch:1;
        USHORT EnableClockPowerManagement:1;
        USHORT Rsvd2:7;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_LINK_CONTROL_REGISTER, *PPCI_EXPRESS_LINK_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_LINK_STATUS_REGISTER {

    struct {

        USHORT LinkSpeed:4;
        USHORT LinkWidth:6;
        USHORT Undefined:1;
        USHORT LinkTraining:1;
        USHORT SlotClockConfig:1;
        USHORT DataLinkLayerActive:1;
        USHORT Rsvd:2;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_LINK_STATUS_REGISTER, *PPCI_EXPRESS_LINK_STATUS_REGISTER;

typedef union _PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER {

    struct {

        ULONG AttentionButtonPresent:1;
        ULONG PowerControllerPresent:1;
        ULONG MRLSensorPresent:1;
        ULONG AttentionIndicatorPresent:1;
        ULONG PowerIndicatorPresent:1;
        ULONG HotPlugSurprise:1;
        ULONG HotPlugCapable:1;
        ULONG SlotPowerLimit:8;
        ULONG SlotPowerLimitScale:2;
        ULONG ElectromechanicalLockPresent:1;
        ULONG NoCommandCompletedSupport:1;
        ULONG PhysicalSlotNumber:13;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER, *PPCI_EXPRESS_SLOT_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_SLOT_CONTROL_REGISTER {

    struct {

        USHORT AttentionButtonEnable:1;
        USHORT PowerFaultDetectEnable:1;
        USHORT MRLSensorEnable:1;
        USHORT PresenceDetectEnable:1;
        USHORT CommandCompletedEnable:1;
        USHORT HotPlugInterruptEnable:1;
        USHORT AttentionIndicatorControl:2;  // EXPRESS_INDICATOR_STATE
        USHORT PowerIndicatorControl:2;      // EXPRESS_INDICATOR_STATE
        USHORT PowerControllerControl:1;     // EXPRESS_POWER_STATE
        USHORT ElectromechanicalLockControl:1;
        USHORT DataLinkStateChangeEnable:1;
        USHORT Rsvd:3;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_SLOT_CONTROL_REGISTER, *PPCI_EXPRESS_SLOT_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_SLOT_STATUS_REGISTER {

    struct {

        USHORT AttentionButtonPressed:1;
        USHORT PowerFaultDetected:1;
        USHORT MRLSensorChanged:1;
        USHORT PresenceDetectChanged:1;
        USHORT CommandCompleted:1;
        USHORT MRLSensorState:1;        // EXPRESS_MRL_STATE
        USHORT PresenceDetectState:1;   // EXPRESS_CARD_PRESENCE
        USHORT ElectromechanicalLockEngaged:1;
        USHORT DataLinkStateChanged:1;
        USHORT Rsvd:7;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_SLOT_STATUS_REGISTER, *PPCI_EXPRESS_SLOT_STATUS_REGISTER;

typedef union _PCI_EXPRESS_ROOT_CONTROL_REGISTER {

    struct {

        USHORT CorrectableSerrEnable:1;
        USHORT NonFatalSerrEnable:1;
        USHORT FatalSerrEnable:1;
        USHORT PMEInterruptEnable:1;
        USHORT CRSSoftwareVisibilityEnable:1;
        USHORT Rsvd:11;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_ROOT_CONTROL_REGISTER, *PPCI_EXPRESS_ROOT_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER {

    struct {

        USHORT CRSSoftwareVisibility:1;
        USHORT Rsvd:15;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER, *PPCI_EXPRESS_ROOT_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_ROOT_STATUS_REGISTER {

    struct {

        ULONG PMERequestorId:16;  // PCI_EXPRESS_REQUESTOR_ID
        ULONG PMEStatus:1;
        ULONG PMEPending:1;
        ULONG Rsvd:14;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_ROOT_STATUS_REGISTER, *PPCI_EXPRESS_ROOT_STATUS_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER {

    struct {

        ULONG CompletionTimeoutRangesSupported:4;
        ULONG CompletionTimeoutDisableSupported:1;
        ULONG AriForwardingSupported:1;
        ULONG AtomicOpRoutingSupported:1;
        ULONG AtomicOpCompleterSupported32Bit:1;
        ULONG AtomicOpCompleterSupported64Bit:1;
        ULONG CASCompleterSupported128Bit:1;
        ULONG NoROEnabledPRPRPassing:1;
        ULONG LTRMechanismSupported:1;
        ULONG TPHCompleterSupported:2;
        ULONG Rsvd:4;
        ULONG OBFFSupported:2;
        ULONG ExtendedFmtFieldSuported:1;
        ULONG EndEndTLPPrefixSupported:1;
        ULONG MaxEndEndTLPPrefixes:2;
        ULONG Rsvd2:8;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER, *PPCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER {

    struct {

        USHORT CompletionTimeoutValue:4;
        USHORT CompletionTimeoutDisable:1;
        USHORT AriForwardingEnable:1;
        USHORT AtomicOpRequesterEnable:1;
        USHORT AtomicOpEgresBlocking:1;
        USHORT IDORequestEnable:1;
        USHORT IDOCompletionEnable:1;
        USHORT LTRMechanismEnable:1;
        USHORT Rsvd:2;
        USHORT OBFFEnable:2;
        USHORT EndEndTLPPrefixBlocking:1;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER, *PPCI_EXPRESS_DEVICE_CONTROL_2_REGISTER;

typedef union _PCI_EXPRESS_DEVICE_STATUS_2_REGISTER {

    struct {

        USHORT Rsvd:16;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_DEVICE_STATUS_2_REGISTER, *PPCI_EXPRESS_DEVICE_STATUS_2_REGISTER;

//
// PCI Express Capability
//

typedef struct _PCI_EXPRESS_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;
    PCI_EXPRESS_CAPABILITIES_REGISTER ExpressCapabilities;

    PCI_EXPRESS_DEVICE_CAPABILITIES_REGISTER DeviceCapabilities;

    PCI_EXPRESS_DEVICE_CONTROL_REGISTER DeviceControl;
    PCI_EXPRESS_DEVICE_STATUS_REGISTER DeviceStatus;

    PCI_EXPRESS_LINK_CAPABILITIES_REGISTER LinkCapabilities;

    PCI_EXPRESS_LINK_CONTROL_REGISTER LinkControl;
    PCI_EXPRESS_LINK_STATUS_REGISTER LinkStatus;

    PCI_EXPRESS_SLOT_CAPABILITIES_REGISTER SlotCapabilities;

    PCI_EXPRESS_SLOT_CONTROL_REGISTER SlotControl;
    PCI_EXPRESS_SLOT_STATUS_REGISTER SlotStatus;

    PCI_EXPRESS_ROOT_CONTROL_REGISTER RootControl;
    PCI_EXPRESS_ROOT_CAPABILITIES_REGISTER RootCapabilities;

    PCI_EXPRESS_ROOT_STATUS_REGISTER RootStatus;

    PCI_EXPRESS_DEVICE_CAPABILITIES_2_REGISTER DeviceCapabilities2;
    PCI_EXPRESS_DEVICE_CONTROL_2_REGISTER DeviceControl2;
    PCI_EXPRESS_DEVICE_STATUS_2_REGISTER DeviceStatus2;

} PCI_EXPRESS_CAPABILITY, *PPCI_EXPRESS_CAPABILITY;

// end_ntoshvp

typedef enum {

    MRLClosed = 0,
    MRLOpen

} PCI_EXPRESS_MRL_STATE;

typedef enum {

    SlotEmpty = 0,
    CardPresent

} PCI_EXPRESS_CARD_PRESENCE;

typedef enum {

    IndicatorOn = 1,
    IndicatorBlink,
    IndicatorOff

} PCI_EXPRESS_INDICATOR_STATE;

typedef enum {

    PowerOn = 0,
    PowerOff

} PCI_EXPRESS_POWER_STATE;

typedef enum {

    NoAspmSupport = 0,
    L0sEntrySupport = 1,
    L1EntrySupport = 2,
    L0sAndL1EntrySupport = 3

} PCI_EXPRESS_ASPM_SUPPORT;

typedef enum {

    L0sAndL1EntryDisabled,
    L0sEntryEnabled,
    L1EntryEnabled,
    L0sAndL1EntryEnabled

} PCI_EXPRESS_ASPM_CONTROL;

typedef enum {

    L0s_Below64ns = 0,
    L0s_64ns_128ns,
    L0s_128ns_256ns,
    L0s_256ns_512ns,
    L0s_512ns_1us,
    L0s_1us_2us,
    L0s_2us_4us,
    L0s_Above4us

} PCI_EXPRESS_L0s_EXIT_LATENCY;

typedef enum {

    L1_Below1us = 0,
    L1_1us_2us,
    L1_2us_4us,
    L1_4us_8us,
    L1_8us_16us,
    L1_16us_32us,
    L1_32us_64us,
    L1_Above64us

} PCI_EXPRESS_L1_EXIT_LATENCY;

// begin_ntoshvp

typedef enum {

    PciExpressEndpoint = 0,
    PciExpressLegacyEndpoint,
    PciExpressRootPort = 4,
    PciExpressUpstreamSwitchPort,
    PciExpressDownstreamSwitchPort,
    PciExpressToPciXBridge,
    PciXToExpressBridge,
    PciExpressRootComplexIntegratedEndpoint,
    PciExpressRootComplexEventCollector

} PCI_EXPRESS_DEVICE_TYPE;

// end_ntoshvp

typedef enum {

    MaxPayload128Bytes = 0,
    MaxPayload256Bytes,
    MaxPayload512Bytes,
    MaxPayload1024Bytes,
    MaxPayload2048Bytes,
    MaxPayload4096Bytes

} PCI_EXPRESS_MAX_PAYLOAD_SIZE;

typedef union _PCI_EXPRESS_PME_REQUESTOR_ID {

    struct {

        USHORT FunctionNumber:3;
        USHORT DeviceNumber:5;
        USHORT BusNumber:8;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_PME_REQUESTOR_ID, *PPCI_EXPRESS_PME_REQUESTOR_ID;

// end_ntddk
// begin_wdm

//
// PCI Express Extended Capabilities.
//

#define PCI_EXPRESS_ADVANCED_ERROR_REPORTING_CAP_ID                     0x0001
#define PCI_EXPRESS_VIRTUAL_CHANNEL_CAP_ID                              0x0002
#define PCI_EXPRESS_DEVICE_SERIAL_NUMBER_CAP_ID                         0x0003
#define PCI_EXPRESS_POWER_BUDGETING_CAP_ID                              0x0004
#define PCI_EXPRESS_RC_LINK_DECLARATION_CAP_ID                          0x0005
#define PCI_EXPRESS_RC_INTERNAL_LINK_CONTROL_CAP_ID                     0x0006
#define PCI_EXPRESS_RC_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAP_ID      0x0007
#define PCI_EXPRESS_MFVC_CAP_ID                                         0x0008
#define PCI_EXPRESS_VC_AND_MFVC_CAP_ID                                  0x0009
#define PCI_EXPRESS_RCRB_HEADER_CAP_ID                                  0x000A
#define PCI_EXPRESS_VENDOR_SPECIFIC_CAP_ID                              0x000B
#define PCI_EXPRESS_CONFIGURATION_ACCESS_CORRELATION_CAP_ID             0x000C
#define PCI_EXPRESS_ACCESS_CONTROL_SERVICES_CAP_ID                      0x000D
#define PCI_EXPRESS_ARI_CAP_ID                                          0x000E
#define PCI_EXPRESS_ATS_CAP_ID                                          0x000F
#define PCI_EXPRESS_SINGLE_ROOT_IO_VIRTUALIZATION_CAP_ID                0x0010
#define PCI_EXPRESS_MULTI_ROOT_IO_VIRTUALIZATION_CAP_ID                 0x0011
#define PCI_EXPRESS_MULTICAST_CAP_ID                                    0x0012
#define PCI_EXPRESS_PAGE_REQUEST_CAP_ID                                 0x0013
#define PCI_EXPRESS_RESERVED_FOR_AMD_CAP_ID                             0x0014
#define PCI_EXPRESS_RESIZABLE_BAR_CAP_ID                                0x0015
#define PCI_EXPRESS_DPA_CAP_ID                                          0x0016
#define PCI_EXPRESS_TPH_REQUESTER_CAP_ID                                0x0017
#define PCI_EXPRESS_LTR_CAP_ID                                          0x0018
#define PCI_EXPRESS_SECONDARY_PCI_EXPRESS_CAP_ID                        0x0019
#define PCI_EXPRESS_PMUX_CAP_ID                                         0x001A
#define PCI_EXPRESS_PASID_CAP_ID                                        0x001B
#define PCI_EXPRESS_LN_REQUESTER_CAP_ID                                 0x001C
#define PCI_EXPRESS_DPC_CAP_ID                                          0x001D
#define PCI_EXPRESS_L1_PM_SS_CAP_ID                                     0x001E
#define PCI_EXPRESS_PTM_CAP_ID                                          0x001F
#define PCI_EXPRESS_MPCIE_CAP_ID                                        0x0020
#define PCI_EXPRESS_FRS_QUEUEING_CAP_ID                                 0x0021
#define PCI_EXPRESS_READINESS_TIME_REPORTING_CAP_ID                     0x0022


//
// All Enhanced capabilities have the following header.
//

typedef struct _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {

    USHORT CapabilityID;
    USHORT Version:4;
    USHORT Next:12;

} PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER, *PPCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;

//
// Vendor Specific Capability
//

typedef struct _PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    USHORT VsecId;
    USHORT VsecRev:4;
    USHORT VsecLength:12;

} PCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY, *PPCI_EXPRESS_VENDOR_SPECIFIC_CAPABILITY;

//
// Serial Number Capability.
//

typedef struct _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    ULONG LowSerialNumber;
    ULONG HighSerialNumber;

} PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY, *PPCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;

//
// ARI Capability structures
//

typedef struct _PCI_EXPRESS_ARI_CAPABILITY_REGISTER {

    USHORT MfvcFunctionGroupsCapability:1;
    USHORT AcsFunctionGroupsCapability:1;
    USHORT Reserved:6;
    USHORT NextFunctionNumber:8;

} PCI_EXPRESS_ARI_CAPABILITY_REGISTER, *PPCI_EXPRESS_ARI_CAPABILITY_REGISTER;

typedef struct _PCI_EXPRESS_ARI_CONTROL_REGISTER {

    USHORT MfvcFunctionGroupsEnable:1;
    USHORT AcsFunctionGroupsEnable:1;
    USHORT Reserved1:2;
    USHORT FunctionGroup:3;
    USHORT Reserved2:9;

} PCI_EXPRESS_ARI_CONTROL_REGISTER, *PPCI_EXPRESS_ARI_CONTROL_REGISTER;

typedef struct _PCI_EXPRESS_ARI_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_ARI_CAPABILITY_REGISTER Capability;
    PCI_EXPRESS_ARI_CONTROL_REGISTER Control;

} PCI_EXPRESS_ARI_CAPABILITY, *PPCI_EXPRESS_ARI_CAPABILITY;

//
// Virtual Channel (VC) Capability structures
//

typedef union _VIRTUAL_CHANNEL_CAPABILITIES1 {
    struct {
        ULONG ExtendedVCCount:2;
        ULONG RsvdP1:1;
        ULONG LowPriorityExtendedVCCount:2;
        ULONG RsvdP2:1;
        ULONG ReferenceClock:2;
        ULONG PortArbitrationTableEntrySize:2;
        ULONG RsvdP3:20;
    };
    ULONG AsULONG;
} VIRTUAL_CHANNEL_CAPABILITIES1, *PVIRTUAL_CHANNEL_CAPABILITIES1;

typedef union _VIRTUAL_CHANNEL_CAPABILITIES2 {
    struct {
        ULONG VCArbitrationCapability:8;
        ULONG RsvdP:16;
        ULONG VCArbitrationTableOffset:8;
    };
    ULONG AsULONG;
} VIRTUAL_CHANNEL_CAPABILITIES2, *PVIRTUAL_CHANNEL_CAPABILITIES2;

typedef union _VIRTUAL_CHANNEL_CONTROL {
    struct {
        USHORT  LoadVCArbitrationTable:1;
        USHORT  VCArbitrationSelect:3;
        USHORT  RsvdP:12;
    };
    USHORT AsUSHORT;
} VIRTUAL_CHANNEL_CONTROL, *PVIRTUAL_CHANNEL_CONTROL;

typedef union _VIRTUAL_CHANNEL_STATUS {
    struct {
        USHORT  VCArbitrationTableStatus:1;
        USHORT  RsvdZ:15;
    };
    USHORT AsUSHORT;
} VIRTUAL_CHANNEL_STATUS, *PVIRTUAL_CHANNEL_STATUS;

typedef union _VIRTUAL_RESOURCE_CAPABILITY {
    struct {
        ULONG   PortArbitrationCapability:8;
        ULONG   RsvdP1:6;
        ULONG   Undefined:1;
        ULONG   RejectSnoopTransactions:1;
        ULONG   MaximumTimeSlots:7;
        ULONG   RsvdP2:1;
        ULONG   PortArbitrationTableOffset:8;
    };
    ULONG AsULONG;
} VIRTUAL_RESOURCE_CAPABILITY, *PVIRTUAL_RESOURCE_CAPABILITY;

typedef union _VIRTUAL_RESOURCE_CONTROL {
    struct {
        ULONG   TcVcMap:8;
        ULONG   RsvdP1:8;
        ULONG   LoadPortArbitrationTable:1;
        ULONG   PortArbitrationSelect:3;
        ULONG   RsvdP2:4;
        ULONG   VcID:3;
        ULONG   RsvdP3:4;
        ULONG   VcEnable:1;
    };
    ULONG AsULONG;
} VIRTUAL_RESOURCE_CONTROL, *PVIRTUAL_RESOURCE_CONTROL;

typedef union _VIRTUAL_RESOURCE_STATUS {
    struct {
        USHORT  PortArbitrationTableStatus:1;
        USHORT  VcNegotiationPending:1;
        USHORT  RsvdZ:14;
    };
    USHORT AsUSHORT;
} VIRTUAL_RESOURCE_STATUS, *PVIRTUAL_RESOURCE_STATUS;

typedef struct _VIRTUAL_RESOURCE {
    VIRTUAL_RESOURCE_CAPABILITY     Capability;
    VIRTUAL_RESOURCE_CONTROL        Control;
    USHORT                          RsvdP;
    VIRTUAL_RESOURCE_STATUS         Status;
} VIRTUAL_RESOURCE, *PVIRTUAL_RESOURCE;

typedef struct _PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    VIRTUAL_CHANNEL_CAPABILITIES1   Capabilities1;
    VIRTUAL_CHANNEL_CAPABILITIES2   Capabilities2;
    VIRTUAL_CHANNEL_CONTROL         Control;
    VIRTUAL_CHANNEL_STATUS          Status;
    VIRTUAL_RESOURCE                Resource[8];

} PCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY, *PPCI_EXPRESS_VIRTUAL_CHANNEL_CAPABILITY;

//
// ATS Capability structures
//

typedef struct _PCI_EXPRESS_ATS_CAPABILITY_REGISTER {

    USHORT InvalidateQueueDepth:5;
    USHORT PageAlignedRequest:1;
    USHORT GlobalInvalidateSupported:1;
    USHORT Reserved:9;

} PCI_EXPRESS_ATS_CAPABILITY_REGISTER, *PPCI_EXPRESS_ATS_CAPABILITY_REGISTER;

typedef struct _PCI_EXPRESS_ATS_CONTROL_REGISTER {

    USHORT SmallestTransactionUnit:5;
    USHORT Reserved:10;
    USHORT Enable:1;

} PCI_EXPRESS_ATS_CONTROL_REGISTER, *PPCI_EXPRESS_ATS_CONTROL_REGISTER;

typedef struct _PCI_EXPRESS_ATS_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_ATS_CAPABILITY_REGISTER Capability;
    PCI_EXPRESS_ATS_CONTROL_REGISTER Control;

} PCI_EXPRESS_ATS_CAPABILITY, *PPCI_EXPRESS_ATS_CAPABILITY;

//
// PASID Extended Capability Structure
//

typedef union _PCI_EXPRESS_PASID_CAPABILITY_REGISTER {
    struct {
        USHORT Rsvd:1;
        USHORT ExecutePermissionSupported:1;
        USHORT PrivilegedModeSupported:1;
        USHORT Rsvd2:5;
        USHORT MaxPASIDWidth:5;
        USHORT Rsvd3:3;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;
} PCI_EXPRESS_PASID_CAPABILITY_REGISTER, *PPCI_EXPRESS_PASID_CAPABILITY_REGISTER;

typedef union _PCI_EXPRESS_PASID_CONTROL_REGISTER {
    struct {
        USHORT PASIDEnable:1;
        USHORT ExecutePermissionEnable:1;
        USHORT PrivilegedModeEnable:1;
        USHORT Rsvd:13;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;
} PCI_EXPRESS_PASID_CONTROL_REGISTER, *PPCI_EXPRESS_PASID_CONTROL_REGISTER;

typedef struct _PCI_EXPRESS_PASID_CAPABILITY {
    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
    PCI_EXPRESS_PASID_CAPABILITY_REGISTER Capability;
    PCI_EXPRESS_PASID_CONTROL_REGISTER Control;
} PCI_EXPRESS_PASID_CAPABILITY, *PPCI_EXPRESS_PASID_CAPABILITY;

//
// PRI Extended Capability Structure
//

typedef union _PCI_EXPRESS_PRI_STATUS_REGISTER {
    struct {
        USHORT ResponseFailure:1;
        USHORT UnexpectedPageRequestGroupIndex:1;
        USHORT Rsvd:6;
        USHORT Stopped:1;
        USHORT Rsvd2:6;
        USHORT PrgResponsePasidRequired:1;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;
} PCI_EXPRESS_PRI_STATUS_REGISTER, *PPCI_EXPRESS_PRI_STATUS_REGISTER;

typedef union _PCI_EXPRESS_PRI_CONTROL_REGISTER {
    struct {
        USHORT Enable:1;
        USHORT Reset:1;
        USHORT Rsvd:14;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;
} PCI_EXPRESS_PRI_CONTROL_REGISTER, *PPCI_EXPRESS_PRI_CONTROL_REGISTER;

typedef struct _PCI_EXPRESS_PRI_CAPABILITY {
    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
    PCI_EXPRESS_PRI_CONTROL_REGISTER Control;
    PCI_EXPRESS_PRI_STATUS_REGISTER Status;
    ULONG PRCapacity;
    ULONG PRAllocation;
} PCI_EXPRESS_PRI_CAPABILITY, *PPCI_EXPRESS_PRI_CAPABILITY;

//
// PCI Express Advanced Error Reporting structures.
//

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS {

    struct {
        ULONG Undefined:1;
        ULONG Reserved1:3;
        ULONG DataLinkProtocolError:1;
        ULONG SurpriseDownError:1;
        ULONG Reserved2:6;
        ULONG PoisonedTLP:1;
        ULONG FlowControlProtocolError:1;
        ULONG CompletionTimeout:1;
        ULONG CompleterAbort:1;
        ULONG UnexpectedCompletion:1;
        ULONG ReceiverOverflow:1;
        ULONG MalformedTLP:1;
        ULONG ECRCError:1;
        ULONG UnsupportedRequestError:1;
        ULONG AcsViolation:1;
        ULONG UncorrectableInternalError:1;
        ULONG MCBlockedTlp:1;
        ULONG AtomicOpEgressBlocked:1;
        ULONG TlpPrefixBlocked:1;
        ULONG Reserved3:6;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK {

    struct {
        ULONG Undefined:1;
        ULONG Reserved1:3;
        ULONG DataLinkProtocolError:1;
        ULONG SurpriseDownError:1;
        ULONG Reserved2:6;
        ULONG PoisonedTLP:1;
        ULONG FlowControlProtocolError:1;
        ULONG CompletionTimeout:1;
        ULONG CompleterAbort:1;
        ULONG UnexpectedCompletion:1;
        ULONG ReceiverOverflow:1;
        ULONG MalformedTLP:1;
        ULONG ECRCError:1;
        ULONG UnsupportedRequestError:1;
        ULONG AcsViolation:1;
        ULONG UncorrectableInternalError:1;
        ULONG MCBlockedTlp:1;
        ULONG AtomicOpEgressBlocked:1;
        ULONG TlpPrefixBlocked:1;
        ULONG Reserved3:6;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY {

    struct {
        ULONG Undefined:1;
        ULONG Reserved1:3;
        ULONG DataLinkProtocolError:1;
        ULONG SurpriseDownError:1;
        ULONG Reserved2:6;
        ULONG PoisonedTLP:1;
        ULONG FlowControlProtocolError:1;
        ULONG CompletionTimeout:1;
        ULONG CompleterAbort:1;
        ULONG UnexpectedCompletion:1;
        ULONG ReceiverOverflow:1;
        ULONG MalformedTLP:1;
        ULONG ECRCError:1;
        ULONG UnsupportedRequestError:1;
        ULONG AcsViolation:1;
        ULONG UncorrectableInternalError:1;
        ULONG MCBlockedTlp:1;
        ULONG AtomicOpEgressBlocked:1;
        ULONG TlpPrefixBlocked:1;
        ULONG Reserved3:6;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;

typedef union _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS {

    struct {
        ULONG ReceiverError:1;
        ULONG Reserved1:5;
        ULONG BadTLP:1;
        ULONG BadDLLP:1;
        ULONG ReplayNumRollover:1;
        ULONG Reserved2:3;
        ULONG ReplayTimerTimeout:1;
        ULONG AdvisoryNonFatalError:1;
        ULONG CorrectedInternalError:1;
        ULONG HeaderLogOverflow:1;
        ULONG Reserved3:16;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_CORRECTABLE_ERROR_STATUS, *PPCI_CORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_CORRECTABLE_ERROR_MASK {

    struct {
        ULONG ReceiverError:1;
        ULONG Reserved1:5;
        ULONG BadTLP:1;
        ULONG BadDLLP:1;
        ULONG ReplayNumRollover:1;
        ULONG Reserved2:3;
        ULONG ReplayTimerTimeout:1;
        ULONG AdvisoryNonFatalError:1;
        ULONG CorrectedInternalError:1;
        ULONG HeaderLogOverflow:1;
        ULONG Reserved3:16;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_CORRECTABLE_ERROR_MASK, *PPCI_CORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_AER_CAPABILITIES {

    struct {
        ULONG FirstErrorPointer:5;
        ULONG ECRCGenerationCapable:1;
        ULONG ECRCGenerationEnable:1;
        ULONG ECRCCheckCapable:1;
        ULONG ECRCCheckEnable:1;
        ULONG MultipleHeaderRecordingCapable:1;
        ULONG MultipleHeaderRecordingEnable:1;
        ULONG TlpPrefixLogPresent:1;
        ULONG Reserved:20;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_AER_CAPABILITIES, *PPCI_EXPRESS_AER_CAPABILITIES;

typedef union _PCI_EXPRESS_ROOT_ERROR_COMMAND {

    struct {
        ULONG CorrectableErrorReportingEnable:1;
        ULONG NonFatalErrorReportingEnable:1;
        ULONG FatalErrorReportingEnable:1;
        ULONG Reserved:29;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_ROOT_ERROR_COMMAND, *PPCI_EXPRESS_ROOT_ERROR_COMMAND;

typedef union _PCI_EXPRESS_ROOT_ERROR_STATUS {

    struct {
        ULONG CorrectableErrorReceived:1;
        ULONG MultipleCorrectableErrorsReceived:1;
        ULONG UncorrectableErrorReceived:1;
        ULONG MultipleUncorrectableErrorsReceived:1;
        ULONG FirstUncorrectableFatal:1;
        ULONG NonFatalErrorMessagesReceived:1;
        ULONG FatalErrorMessagesReceived:1;
        ULONG Reserved:20;
        ULONG AdvancedErrorInterruptMessageNumber:5;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_ROOT_ERROR_STATUS, *PPCI_EXPRESS_ROOT_ERROR_STATUS;

typedef union _PCI_EXPRESS_ERROR_SOURCE_ID {

    struct {
        USHORT CorrectableSourceIdFun:3;
        USHORT CorrectableSourceIdDev:5;
        USHORT CorrectableSourceIdBus:8;
        USHORT UncorrectableSourceIdFun:3;
        USHORT UncorrectableSourceIdDev:5;
        USHORT UncorrectableSourceIdBus:8;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_ERROR_SOURCE_ID, *PPCI_EXPRESS_ERROR_SOURCE_ID;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS {

    struct {
        ULONG TargetAbortOnSplitCompletion:1;
        ULONG MasterAbortOnSplitCompletion:1;
        ULONG ReceivedTargetAbort:1;
        ULONG ReceivedMasterAbort:1;
        ULONG RsvdZ:1;
        ULONG UnexpectedSplitCompletionError:1;
        ULONG UncorrectableSplitCompletion:1;
        ULONG UncorrectableDataError:1;
        ULONG UncorrectableAttributeError:1;
        ULONG UncorrectableAddressError:1;
        ULONG DelayedTransactionDiscardTimerExpired:1;
        ULONG PERRAsserted:1;
        ULONG SERRAsserted:1;
        ULONG InternalBridgeError:1;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS,
  *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK {

    struct {
        ULONG TargetAbortOnSplitCompletion:1;
        ULONG MasterAbortOnSplitCompletion:1;
        ULONG ReceivedTargetAbort:1;
        ULONG ReceivedMasterAbort:1;
        ULONG RsvdZ:1;
        ULONG UnexpectedSplitCompletionError:1;
        ULONG UncorrectableSplitCompletion:1;
        ULONG UncorrectableDataError:1;
        ULONG UncorrectableAttributeError:1;
        ULONG UncorrectableAddressError:1;
        ULONG DelayedTransactionDiscardTimerExpired:1;
        ULONG PERRAsserted:1;
        ULONG SERRAsserted:1;
        ULONG InternalBridgeError:1;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK,
  *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY {

    struct {
        ULONG TargetAbortOnSplitCompletion:1;
        ULONG MasterAbortOnSplitCompletion:1;
        ULONG ReceivedTargetAbort:1;
        ULONG ReceivedMasterAbort:1;
        ULONG RsvdZ:1;
        ULONG UnexpectedSplitCompletionError:1;
        ULONG UncorrectableSplitCompletion:1;
        ULONG UncorrectableDataError:1;
        ULONG UncorrectableAttributeError:1;
        ULONG UncorrectableAddressError:1;
        ULONG DelayedTransactionDiscardTimerExpired:1;
        ULONG PERRAsserted:1;
        ULONG SERRAsserted:1;
        ULONG InternalBridgeError:1;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
  *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;

typedef union _PCI_EXPRESS_SEC_AER_CAPABILITIES {

    struct {
        ULONG SecondaryUncorrectableFirstErrorPtr:5;
        ULONG Reserved:27;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_AER_CAPABILITIES, *PPCI_EXPRESS_SEC_AER_CAPABILITIES;

#define ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING  0x00000001
#define ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING     0x00000002
#define ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING        0x00000004

#define ROOT_CMD_ERROR_REPORTING_ENABLE_MASK \
    (ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING | \
     ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING | \
     ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING)

//
// Advanced Error Reporting Capability structure.
//

typedef struct _PCI_EXPRESS_AER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
    PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
    PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
    PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
    ULONG HeaderLog[4];
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS SecUncorrectableErrorStatus;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK SecUncorrectableErrorMask;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY SecUncorrectableErrorSeverity;
    PCI_EXPRESS_SEC_AER_CAPABILITIES SecCapabilitiesAndControl;
    ULONG SecHeaderLog[4];

} PCI_EXPRESS_AER_CAPABILITY, *PPCI_EXPRESS_AER_CAPABILITY;

//
// Advanced Error Reporting Capability structure for root port.
//

typedef struct _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
    PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
    PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
    PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
    ULONG HeaderLog[4];
    PCI_EXPRESS_ROOT_ERROR_COMMAND RootErrorCommand;
    PCI_EXPRESS_ROOT_ERROR_STATUS RootErrorStatus;
    PCI_EXPRESS_ERROR_SOURCE_ID ErrorSourceId;

} PCI_EXPRESS_ROOTPORT_AER_CAPABILITY, *PPCI_EXPRESS_ROOTPORT_AER_CAPABILITY;

//
// Advanced Error Reporting Capability structure for root port.
//

typedef struct _PCI_EXPRESS_BRIDGE_AER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
    PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
    PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
    PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
    ULONG HeaderLog[4];
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS SecUncorrectableErrorStatus;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK SecUncorrectableErrorMask;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY SecUncorrectableErrorSeverity;
    PCI_EXPRESS_SEC_AER_CAPABILITIES SecCapabilitiesAndControl;
    ULONG SecHeaderLog[4];

} PCI_EXPRESS_BRIDGE_AER_CAPABILITY, *PPCI_EXPRESS_BRIDGE_AER_CAPABILITY;

//
// Access Control Services Capability structure.
//
typedef union _PCI_EXPRESS_ACS_CAPABILITY_REGISTER {

    struct {
        USHORT SourceValidation:1;
        USHORT TranslationBlocking:1;
        USHORT RequestRedirect:1;
        USHORT CompletionRedirect:1;
        USHORT UpstreamForwarding:1;
        USHORT EgressControl:1;
        USHORT DirectTranslation:1;
        USHORT Reserved:1;
        USHORT EgressControlVectorSize:8;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_ACS_CAPABILITY_REGISTER, *PPCI_EXPRESS_ACS_CAPABILITY_REGISTER;

typedef union _PCI_EXPRESS_ACS_CONTROL {

    struct {
        USHORT SourceValidation:1;
        USHORT TranslationBlocking:1;
        USHORT RequestRedirect:1;
        USHORT CompletionRedirect:1;
        USHORT UpstreamForwarding:1;
        USHORT EgressControl:1;
        USHORT DirectTranslation:1;
        USHORT Reserved:9;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_ACS_CONTROL, *PPCI_EXPRESS_ACS_CONTROL;

typedef struct _PCI_EXPRESS_ACS_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER  Header;

    PCI_EXPRESS_ACS_CAPABILITY_REGISTER      Capability;
    PCI_EXPRESS_ACS_CONTROL                 Control;

    ULONG                                   EgressControl[1];
} PCI_EXPRESS_ACS_CAPABILITY, *PPCI_EXPRESS_ACS_CAPABILITY ;

//
// Single-Root I/O Virtualization Capability structure for endpoints
//

typedef union _PCI_EXPRESS_SRIOV_CAPS {

    struct {
        ULONG VFMigrationCapable:1;
        ULONG Reserved1:20;
        ULONG VFMigrationInterruptNumber:11;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SRIOV_CAPS, *PPCI_EXPRESS_SRIOV_CAPS;

typedef union _PCI_EXPRESS_SRIOV_CONTROL {

    struct {
        USHORT VFEnable:1;
        USHORT VFMigrationEnable:1;
        USHORT VFMigrationInterruptEnable:1;
        USHORT VFMemorySpaceEnable:1;
        USHORT ARICapableHierarchy:1;
        USHORT Reserved1:11;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_SRIOV_CONTROL, *PPCI_EXPRESS_SRIOV_CONTROL;

typedef union _PCI_EXPRESS_SRIOV_STATUS {

    struct {
        USHORT VFMigrationStatus:1;
        USHORT Reserved1:15;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_SRIOV_STATUS, *PPCI_EXPRESS_SRIOV_STATUS;

typedef union _PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY {

    struct {
        ULONG VFMigrationStateBIR:3;
        ULONG VFMigrationStateOffset:29;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY, *PPCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY;

typedef struct _PCI_EXPRESS_SRIOV_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER  Header;

    PCI_EXPRESS_SRIOV_CAPS                  SRIOVCapabilities;
    PCI_EXPRESS_SRIOV_CONTROL               SRIOVControl;
    PCI_EXPRESS_SRIOV_STATUS                SRIOVStatus;
    USHORT                                  InitialVFs;
    USHORT                                  TotalVFs;
    USHORT                                  NumVFs;
    UCHAR                                   FunctionDependencyLink;
    UCHAR                                   RsvdP1;
    USHORT                                  FirstVFOffset;
    USHORT                                  VFStride;
    USHORT                                  RsvdP2;
    USHORT                                  VFDeviceId;
    ULONG                                   SupportedPageSizes;
    ULONG                                   SystemPageSize;
    ULONG                                   BaseAddresses[PCI_TYPE0_ADDRESSES];
    PCI_EXPRESS_SRIOV_MIGRATION_STATE_ARRAY VFMigrationStateArrayOffset;

} PCI_EXPRESS_SRIOV_CAPABILITY, *PPCI_EXPRESS_SRIOV_CAPABILITY;

//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_AHCI_CTLR          0x06
#define PCI_SUBCLASS_MSC_NVM_CTLR           0x08
#define PCI_SUBCLASS_MSC_OTHER              0x80

// SubClass 08 - PCI_SUBCLASS_MSC_NVM_CTLR

#define PCI_PROGRAMMING_INTERFACE_MSC_NVM_EXPRESS   0x02


// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_SDIO_CTRL          0x05
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05
#define PCI_SUBCLASS_SB_THUNDERBOLT         0x0A

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80

// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_wdm end_ntminiport

// begin_ntddk

//
// Portable portion of HAL & HAL bus extender definitions for BUSHANDLER
// BusData for installed PCI buses.
//

typedef VOID
(*PciPin2Line) (
    _In_ struct _BUS_HANDLER  *BusHandler,
    _In_ struct _BUS_HANDLER  *RootHandler,
    _In_ PCI_SLOT_NUMBER      SlotNumber,
    _In_ PPCI_COMMON_CONFIG   PciData
    );

typedef VOID
(*PciLine2Pin) (
    _In_ struct _BUS_HANDLER  *BusHandler,
    _In_ struct _BUS_HANDLER  *RootHandler,
    _In_ PCI_SLOT_NUMBER      SlotNumber,
    _In_ PPCI_COMMON_CONFIG   PciNewData,
    _In_ PPCI_COMMON_CONFIG   PciOldData
    );

typedef VOID
(*PciReadWriteConfig) (
    _In_ struct _BUS_HANDLER *BusHandler,
    _In_ PCI_SLOT_NUMBER Slot,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );

#define PCI_DATA_TAG            ' ICP'
#define PCI_DATA_VERSION        1

typedef struct _PCIBUSDATA {
    ULONG                   Tag;
    ULONG                   Version;
    PciReadWriteConfig      ReadConfig;
    PciReadWriteConfig      WriteConfig;
    PciPin2Line             Pin2Line;
    PciLine2Pin             Line2Pin;
    PCI_SLOT_NUMBER         ParentSlot;
    PVOID                   Reserved[4];
} PCIBUSDATA, *PPCIBUSDATA;

//
// Latency Tolerance Reporting (LTR) Capability
//

typedef union _PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER {

    struct {

        ULONG MaxSnoopLatencyValue:10;
        ULONG MaxSnoopLatencyScale:3;
        ULONG Rsvd:2;
        ULONG MaxSnoopRequirement:1;

        ULONG MaxNoSnoopLatencyValue:10;
        ULONG MaxNoSnoopLatencyScale:3;
        ULONG Rsvd2:2;
        ULONG MaxNoSnoopRequirement:1;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER, *PPCI_EXPRESS_LTR_MAX_LATENCY_REGISTER;

typedef struct _PCI_EXPRESS_LTR_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_LTR_MAX_LATENCY_REGISTER Latency;

} PCI_EXPRESS_LTR_CAPABILITY, *PPCI_EXPRESS_LTR_CAPABILITY;

//
// Transaction Processing Hint (TPH) Capability
//

#define PCI_EXPRESS_TPH_ST_LOCATION_NONE 0
#define PCI_EXPRESS_TPH_ST_LOCATION_TPH_CAPABILITY 1
#define PCI_EXPRESS_TPH_ST_LOCATION_MSIX_TABLE 2
#define PCI_EXPRESS_TPH_ST_LOCATION_RESERVED 3

typedef union _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER {

    struct {

        ULONG NoStModeSupported:1;
        ULONG InteruptVectorModeSupported:1;
        ULONG DeviceSpecificModeSupported:1;
        ULONG Rsvd:5;
        ULONG ExtendedTPHRequesterSupported:1;
        ULONG StTableLocation:2;
        ULONG Rsvd2:5;
        ULONG StTableSize:11;
        ULONG Rsvd3:5;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER, *PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER;

typedef union _PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER {

    struct {

        ULONG StModeSelect:3;
        ULONG Rsvd:5;
        ULONG TphRequesterEnable:2;
        ULONG Rsvd2:22;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER, *PPCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER;

typedef union _PCI_EXPRESS_TPH_ST_TABLE_ENTRY {

    struct {

        USHORT LowerEntry:8;
        USHORT UpperEntry:8;
    } DUMMYSTRUCTNAME;

    USHORT AsUSHORT;

} PCI_EXPRESS_TPH_ST_TABLE_ENTRY, *PPCI_EXPRESS_TPH_ST_TABLE_ENTRY;

typedef struct _PCI_EXPRESS_TPH_REQUESTER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_TPH_REQUESTER_CAPABILITY_REGISTER RequesterCapability;
    PCI_EXPRESS_TPH_REQUESTER_CONTROL_REGISTER RequesterControl;

} PCI_EXPRESS_TPH_REQUESTER_CAPABILITY, *PPCI_EXPRESS_TPH_REQUESTER_CAPABILITY;

//
// L1 PM Substates Capability
//

typedef union _PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER {

    struct {
        ULONG PciPmL12Supported:1;
        ULONG PciPmL11Supported:1;
        ULONG AspmL12Supported:1;
        ULONG AspmL11Supported:1;
        ULONG L1PmSsSupported:1;
        ULONG Rsvd:3;
        ULONG PortCommonModeRestoreTime:8;
        ULONG PortTPowerOnScale:2;
        ULONG Rsvd2:1;
        ULONG PortTPowerOnValue:5;
        ULONG Rsvd3:8;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER, *PPCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER;

typedef union _PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER {

    struct {
        ULONG PciPmL12Enabled:1;
        ULONG PciPmL11Enabled:1;
        ULONG AspmL12Enabled:1;
        ULONG AspmL11Enabled:1;
        ULONG Rsvd:4;
        ULONG CommonModeRestoreTime:8;
        ULONG LtrL12ThresholdValue:10;
        ULONG Rsvd2:3;
        ULONG LtrL12ThresholdScale:3;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER, *PPCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER;

typedef union _PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER {

    struct {

        ULONG TPowerOnScale:2;
        ULONG Rsvd:1;
        ULONG TPowerOnValue:5;
        ULONG Rsvd2:24;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER, *PPCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER;

typedef struct _PCI_EXPRESS_L1_PM_SS_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_L1_PM_SS_CAPABILITIES_REGISTER L1PmSsCapabilities;
    PCI_EXPRESS_L1_PM_SS_CONTROL_1_REGISTER L1PmSsControl1;
    PCI_EXPRESS_L1_PM_SS_CONTROL_2_REGISTER L1PmSsControl2;

} PCI_EXPRESS_L1_PM_SS_CAPABILITY, *PPCI_EXPRESS_L1_PM_SS_CAPABILITY;

typedef union _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER {
    struct {
        ULONG Rsvd:4;
        ULONG SizesSupported:20;
        ULONG Rsvd2:8;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER, *PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER;

typedef union _PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER {
    struct {

        ULONG BarIndex:3;
        ULONG Rsvd:2;
        ULONG NumberOfResizableBars:3;
        ULONG BarSize:5;
        ULONG Rsvd2:19;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER, *PPCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER;

typedef struct _PCI_EXPRESS_RESIZABLE_BAR_ENTRY {
    PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY_REGISTER Capability;
    PCI_EXPRESS_RESIZABLE_BAR_CONTROL_REGISTER Control;
} PCI_EXPRESS_RESIZABLE_BAR_ENTRY, *PPCI_EXPRESS_RESIZABLE_BAR_ENTRY;

typedef struct _PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    PCI_EXPRESS_RESIZABLE_BAR_ENTRY Entry[6];

} PCI_EXPRESS_RESIZABLE_BAR_CAPABILITY, *PPCI_EXPRESS_RESIZABLE_BAR_CAPABILITY;

// end_ntddk
// begin_wdm

#endif // _PCI_X_


#pragma warning(push)
#pragma warning(disable:4214) // nonstandard extensions

//
// PCI_REGISTRY_INFO - this structure is passed into the HAL from
// the firmware.  It signifies how many PCI bus(es) are present and
// what style of access the PCI bus(es) support.
//

typedef struct _PCI_REGISTRY_INFO {
    UCHAR       MajorRevision;
    UCHAR       MinorRevision;
    UCHAR       NoBuses;
    UCHAR       HardwareMechanism;
} PCI_REGISTRY_INFO, *PPCI_REGISTRY_INFO;

//
// PCI definitions for IOBase & IOLimit
// PCIBridgeIO2Base(a,b)  - convert IOBase  & IOBaseUpper16 to ULONG IOBase
// PCIBridgeIO2Limit(a,b) - convert IOLimit & IOLimitUpper6 to ULONG IOLimit
//

#define PciBridgeIO2Base(a,b)   \
        ( ((a >> 4) << 12) + (((a & 0xf) == 1) ? (b << 16) : 0) )

#define PciBridgeIO2Limit(a,b)  (PciBridgeIO2Base(a,b) | 0xfff)

#define PciBridgeMemory2Base(a)  (ULONG) ((a & 0xfff0) << 16)
#define PciBridgeMemory2Limit(a) (PciBridgeMemory2Base(a) | 0xfffff)

//
// Prefetchable windows work very similarly to IO windows except they go up to
// 64-bits instead of 32.
//

#define PciBridgePrefetch2Base(a, b) \
       ( ((a & 0xfff0) << 16) + (((a & 0x1) == 1) ? ((ULONG64)b << 32) : 0) )

#define PciBridgePrefetch2Limit(a, b) (PciBridgePrefetch2Base(a,b) | 0xfffff)

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1/2.BridgeControl
//

#define PCI_ENABLE_BRIDGE_PARITY_ERROR        0x0001
#define PCI_ENABLE_BRIDGE_SERR                0x0002
#define PCI_ENABLE_BRIDGE_ISA                 0x0004
#define PCI_ENABLE_BRIDGE_VGA                 0x0008
#define PCI_ENABLE_BRIDGE_MASTER_ABORT_SERR   0x0020
#define PCI_ASSERT_BRIDGE_RESET               0x0040
#define PCI_ENABLE_BRIDGE_VGA_16BIT           0x0010

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1.BridgeControl
//

#define PCI_ENABLE_BRIDGE_FAST_BACK_TO_BACK   0x0080

//
// Bit encodes for PCI_COMMON_CONFIG.u.type2.BridgeControl
//

#define PCI_ENABLE_CARDBUS_IRQ_ROUTING        0x0080
#define PCI_ENABLE_CARDBUS_MEM0_PREFETCH      0x0100
#define PCI_ENABLE_CARDBUS_MEM1_PREFETCH      0x0200
#define PCI_ENABLE_CARDBUS_WRITE_POSTING      0x0400

//
// Private Capability definitions
//

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
          USHORT MSIEnable:1;
          USHORT MultipleMessageCapable:3;
          USHORT MultipleMessageEnable:3;
          USHORT CapableOf64Bits:1;
          USHORT PerVectorMaskCapable:1;
          USHORT Reserved:7;
      } MessageControl;

      union {

          struct _PCI_MSI_MESSAGE_ADDRESS {
              ULONG Reserved:2;              // always zero, DWORD aligned address
              ULONG Address:30;
          } Register;

          ULONG Raw;

      } MessageAddressLower;

      //
      // This is only valid if CapableOf64Bits is 1.
      //

      union {

          struct {
              USHORT MessageData;
              USHORT Reserved;
              ULONG MaskBits;
              ULONG PendingBits;
          } Option32Bit;

          struct {
              ULONG MessageAddressUpper;
              USHORT MessageData;
              USHORT Reserved;
              ULONG MaskBits;
              ULONG PendingBits;
          } Option64Bit;
      };

} PCI_MSI_CAPABILITY, *PPCI_MSI_CAPABILITY;

//
// MSI-X (Message Signaled Interrupts extended) Capability
//

#define MSIX_TABLE_OFFSET_MASK              0xfffffff8

#define MSIX_PBA_TABLE_ENTRY_SIZE               8
#define MSIX_PENDING_BITS_IN_PBA_TABLE_ENTRY   64

typedef struct {

    union {

        struct {
            ULONG BaseIndexRegister:3;
            ULONG Reserved:29;
        };

        ULONG TableOffset;
    };

} MSIX_TABLE_POINTER, *PMSIX_TABLE_POINTER;

typedef struct {

    PHYSICAL_ADDRESS MessageAddress;
    ULONG MessageData;

    struct {
        ULONG Mask:1;
        ULONG Reserved:15;
        ULONG StLower:8;
        ULONG StUpper:8;
    } VectorControl;

} PCI_MSIX_TABLE_ENTRY, *PPCI_MSIX_TABLE_ENTRY;

typedef struct {

      PCI_CAPABILITIES_HEADER Header;

      struct {
          USHORT TableSize:11;
          USHORT Reserved:3;
          USHORT FunctionMask:1;
          USHORT MSIXEnable:1;
      } MessageControl;

      MSIX_TABLE_POINTER  MessageTable;
      MSIX_TABLE_POINTER  PBATable;   // Pending Bit Array

} PCI_MSIX_CAPABILITY, *PPCI_MSIX_CAPABILITY;

//
// Hypertransport Capabilities - there are multiple subtypes of
// this capability.  Only the interrupt and MSI mapping capability
// subtypes are exposed in this header.
//

typedef enum {
    HTSlavePrimary0 = 0,
    HTSlavePrimary1 = 1,
    HTSlavePrimary2 = 2,
    HTSlavePrimary3 = 3,
    HTHostSecondary0 = 4,
    HTHostSecondary1 = 5,
    HTHostSecondary2 = 6,
    HTHostSecondary3 = 7,
    HTInterruptDiscoveryConfig = 0x10,
    HTAddressMapping = 0x14,
    HTInterruptMsiMapping = 0x15
} PCI_HT_CapabilitiesType, *PPCI_HT_CapabilitiesType;

typedef struct {

    PCI_CAPABILITIES_HEADER Header;

    union {
        struct {
            USHORT Reserved:11;
            USHORT CapabilityType:5; // use PCI_HT_CapabilitiesType
        } Generic;

        struct {
            USHORT Index:8;
            USHORT Reserved:3;
            USHORT CapabilityType:5; // use PCI_HT_CapabilitiesType
        } Interrupt;

        struct {
            USHORT Enable:1;
            USHORT Fixed:1;
            USHORT Reserved:9;
            USHORT CapabilityType:5;
        } MsiMapping;

    } Command;

    union {

        ULONG InterruptDataPort;

        struct {
            ULONG Reserved:20;
            ULONG AddressLow:12;
        } MsiMapping;

    } Offset04;

    union {

        struct {
            ULONG AddressUpper;
        } MsiMapping;

    } Offset08;

} PCI_HT_CAPABILITY, *PPCI_HT_CAPABILITY;

#define PCI_HT_CAPABILITY_COMMON_SIZE FIELD_OFFSET(PCI_HT_CAPABILITY, Offset04)
#define PCI_HT_MSI_MAPPING_CAPABILITY_SIZE (PCI_HT_CAPABILITY_COMMON_SIZE + 2 * sizeof(ULONG))

//
// HT interrupt structures.  These are returned from reads to the interrupt
// data port in the HT capability.
//

typedef struct {
    USHORT Reserved1;
    UCHAR LastInterrupt;
    UCHAR Reserved2;
} PCI_HT_INTERRUPT_INDEX_1, *PPCI_HT_INTERRUPT_INDEX_1;

typedef struct {

    union {
        struct {
            ULONG Mask:1;             // bit 0
            ULONG Polarity:1;         // bit 1
            ULONG MessageType:3;      // bits [4:2]
            ULONG RequestEOI:1;       // bit 5
            ULONG DestinationMode:1;  // bit 6
            ULONG MessageType3:1;     // bit 7
            ULONG Destination:8;      // bits [15:8]
            ULONG Vector:8;           // bits [23:16]
            ULONG ExtendedAddress:8;  // bits [31:24] -- always set to 0xF8
        } bits;

        ULONG AsULONG;

    } LowPart;

    union {
        struct {
            ULONG ExtendedDestination:24;
            ULONG Reserved:6;
            ULONG PassPW:1;
            ULONG WaitingForEOI:1;
        } bits;

        ULONG AsULONG;

    } HighPart;

} PCI_HT_INTERRUPT_INDEX_N, *PPCI_HT_INTERRUPT_INDEX_N;

//
//  Definitions needed for Access to Hardware Type 1
//

#define PCI_TYPE1_ADDR_PORT     0xCF8
#define PCI_TYPE1_DATA_PORT     0xCFC

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


//
//  Definitions needed for Access to Hardware Type 2
//

#define PCI_TYPE2_CSE_PORT              ((PUCHAR)(LONG_PTR) 0xCF8)
#define PCI_TYPE2_FORWARD_PORT          ((PUCHAR)(LONG_PTR) 0xCFA)
#define PCI_TYPE2_ADDRESS_BASE          0xC


typedef struct _PCI_TYPE2_CSE_BITS {
    union {
        struct {
            UCHAR   Enable:1;
            UCHAR   FunctionNumber:3;
            UCHAR   Key:4;
        } bits;
        UCHAR   AsUCHAR;
    } u;
} PCI_TYPE2_CSE_BITS, PPCI_TYPE2_CSE_BITS;


typedef struct _PCI_TYPE2_ADDRESS_BITS {
    union {
        struct {
            USHORT  RegisterNumber:8;
            USHORT  Agent:4;
            USHORT  AddressBase:4;
        } bits;
        USHORT  AsUSHORT;
    } u;
} PCI_TYPE2_ADDRESS_BITS, *PPCI_TYPE2_ADDRESS_BITS;


//
// Definitions for the config cycle format on the PCI bus.
//

typedef struct _PCI_TYPE0_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   Reserved2:21;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE0_CFG_CYCLE_BITS, *PPCI_TYPE0_CFG_CYCLE_BITS;

typedef struct _PCI_TYPE1_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:8;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_CYCLE_BITS, *PPCI_TYPE1_CFG_CYCLE_BITS;

#pragma warning(pop)


#if (NTDDI_VERSION >= NTDDI_WIN8)

NTSTATUS
NTKERNELAPI
HvlQueryActiveHypervisorProcessorCount(
    _Out_ PULONG LpCount
    );

NTSTATUS
NTKERNELAPI
HvlQueryHypervisorProcessorNodeNumber(
    _In_ ULONG LpIndex,
    _Out_ PUSHORT NodeNumber
    );

NTSTATUS
HvlQueryNumaDistance (
    __in USHORT CpuNumaNode,
    __in USHORT MemoryNumaNode,
    __out PULONG64 Distance
    );

#endif


#ifndef _PCIINTRF_X_
#define _PCIINTRF_X_

//
// PCI Bus interface
//

typedef
_Function_class_(PCI_READ_WRITE_CONFIG)
_IRQL_requires_max_(HIGH_LEVEL)
ULONG 
PCI_READ_WRITE_CONFIG (
    _In_ PVOID Context,
    _In_ ULONG BusOffset,
    _In_ ULONG Slot,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );

typedef PCI_READ_WRITE_CONFIG *PPCI_READ_WRITE_CONFIG;

typedef
_Function_class_(PCI_PIN_TO_LINE)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID 
PCI_PIN_TO_LINE (
    _In_ PVOID Context,
    _In_ PPCI_COMMON_CONFIG PciData
    );

typedef PCI_PIN_TO_LINE *PPCI_PIN_TO_LINE;

typedef
_Function_class_(PCI_LINE_TO_PIN)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PCI_LINE_TO_PIN (
    _In_ PVOID Context,
    _In_ PPCI_COMMON_CONFIG PciNewData,
    _In_ PPCI_COMMON_CONFIG PciOldData
    );

typedef PCI_LINE_TO_PIN *PPCI_LINE_TO_PIN;

typedef
_Function_class_(PCI_ROOT_BUS_CAPABILITY)
_IRQL_requires_(PASSIVE_LEVEL)
VOID
PCI_ROOT_BUS_CAPABILITY (
    _In_ PVOID Context,
    _Out_ PPCI_ROOT_BUS_HARDWARE_CAPABILITY HardwareCapability
    );

typedef PCI_ROOT_BUS_CAPABILITY *PPCI_ROOT_BUS_CAPABILITY;

typedef
_Function_class_(PCI_EXPRESS_WAKE_CONTROL)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
PCI_EXPRESS_WAKE_CONTROL (
    _In_ PVOID Context,
    _In_ BOOLEAN EnableWake
    );

typedef PCI_EXPRESS_WAKE_CONTROL *PPCI_EXPRESS_WAKE_CONTROL;

typedef
_Function_class_(PCI_PREPARE_MULTISTAGE_RESUME)
_IRQL_requires_max_(HIGH_LEVEL)
VOID
PCI_PREPARE_MULTISTAGE_RESUME (
    _In_ PVOID Context
    );

typedef PCI_PREPARE_MULTISTAGE_RESUME *PPCI_PREPARE_MULTISTAGE_RESUME;


typedef struct _PCI_BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard PCI bus interfaces
    //
    PPCI_READ_WRITE_CONFIG ReadConfig;
    PPCI_READ_WRITE_CONFIG WriteConfig;
    PPCI_PIN_TO_LINE PinToLine;
    PPCI_LINE_TO_PIN LineToPin;
    PPCI_ROOT_BUS_CAPABILITY RootBusCapability;
    PPCI_EXPRESS_WAKE_CONTROL ExpressWakeControl;
    PPCI_PREPARE_MULTISTAGE_RESUME PrepareMultistageResume;

} PCI_BUS_INTERFACE_STANDARD, *PPCI_BUS_INTERFACE_STANDARD;

#define PCI_BUS_INTERFACE_STANDARD_VERSION 2
#define PCI_BUS_INTERFACE_STANDARD_VERSION_1_LENGTH \
    FIELD_OFFSET(PCI_BUS_INTERFACE_STANDARD, PrepareMultistageResume)

// end_ntddk
// begin_wdm

//
// Device Presence interface
//
#define PCI_DEVICE_PRESENT_INTERFACE_VERSION 1

//
// Flags for PCI_DEVICE_PRESENCE_PARAMETERS
//
#define PCI_USE_SUBSYSTEM_IDS   0x00000001
#define PCI_USE_REVISION        0x00000002
// The following flags are only valid for IsDevicePresentEx
#define PCI_USE_VENDEV_IDS      0x00000004
#define PCI_USE_CLASS_SUBCLASS  0x00000008
#define PCI_USE_PROGIF          0x00000010
#define PCI_USE_LOCAL_BUS       0x00000020
#define PCI_USE_LOCAL_DEVICE    0x00000040

//
// Search parameters structure for IsDevicePresentEx
//
typedef struct _PCI_DEVICE_PRESENCE_PARAMETERS {

    ULONG Size;
    ULONG Flags;

    USHORT VendorID;
    USHORT DeviceID;
    UCHAR RevisionID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    UCHAR BaseClass;
    UCHAR SubClass;
    UCHAR ProgIf;

} PCI_DEVICE_PRESENCE_PARAMETERS, *PPCI_DEVICE_PRESENCE_PARAMETERS;

_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
typedef
BOOLEAN
PCI_IS_DEVICE_PRESENT (
    _In_ USHORT VendorID,
    _In_ USHORT DeviceID,
    _In_ UCHAR RevisionID,
    _In_ USHORT SubVendorID,
    _In_ USHORT SubSystemID,
    _In_ ULONG Flags
);

typedef PCI_IS_DEVICE_PRESENT *PPCI_IS_DEVICE_PRESENT;

_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
typedef
BOOLEAN
PCI_IS_DEVICE_PRESENT_EX (
    _In_ PVOID Context,
    _In_ PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

typedef PCI_IS_DEVICE_PRESENT_EX *PPCI_IS_DEVICE_PRESENT_EX;

typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // pci device info
    //
    PPCI_IS_DEVICE_PRESENT IsDevicePresent;

    PPCI_IS_DEVICE_PRESENT_EX IsDevicePresentEx;

} PCI_DEVICE_PRESENT_INTERFACE, *PPCI_DEVICE_PRESENT_INTERFACE;

//
// Pci Express Link Quiesce Interface
//

#define PCI_EXPRESS_LINK_QUIESCENT_INTERFACE_VERSION      1

_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
typedef
NTSTATUS
PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE (
    _Inout_ PVOID Context
    );

typedef PCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE *PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE;

_IRQL_requires_max_(PASSIVE_LEVEL)
_Must_inspect_result_
typedef
NTSTATUS
PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE (
    _Inout_ PVOID Context
    );

typedef PCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE *PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE;

typedef struct _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE {

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE PciExpressEnterLinkQuiescentMode;
    PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE PciExpressExitLinkQuiescentMode;

} PCI_EXPRESS_LINK_QUIESCENT_INTERFACE, *PPCI_EXPRESS_LINK_QUIESCENT_INTERFACE;

//
// Pci Express Root Port Access Interface
//

#define PCI_EXPRESS_ROOT_PORT_INTERFACE_VERSION        1

typedef
ULONG
(*PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE) (
    _In_ PVOID Context,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );

typedef
ULONG
(*PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE) (
    _In_ PVOID Context,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Offset,
    _In_ ULONG Length
    );

typedef struct _PCI_EXPRESS_ROOT_PORT_INTERFACE {

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE ReadConfigSpace;
    PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE WriteConfigSpace;

} PCI_EXPRESS_ROOT_PORT_INTERFACE, *PPCI_EXPRESS_ROOT_PORT_INTERFACE;

//
// MSI-X interrupt table configuration interface
//

#define PCI_MSIX_TABLE_CONFIG_INTERFACE_VERSION 1

_Must_inspect_result_
typedef
NTSTATUS
PCI_MSIX_SET_ENTRY (
    _In_ PVOID Context,
    _In_ ULONG TableEntry,
    _In_ ULONG MessageNumber
    );

typedef PCI_MSIX_SET_ENTRY *PPCI_MSIX_SET_ENTRY;

_Must_inspect_result_
typedef
NTSTATUS
PCI_MSIX_MASKUNMASK_ENTRY (
    _In_ PVOID Context,
    _In_ ULONG TableEntry
    );

typedef PCI_MSIX_MASKUNMASK_ENTRY *PPCI_MSIX_MASKUNMASK_ENTRY;

_Must_inspect_result_
typedef
NTSTATUS
PCI_MSIX_GET_ENTRY (
    _In_ PVOID Context,
    _In_ ULONG TableEntry,
    _Out_ PULONG MessageNumber,
    _Out_ PBOOLEAN Masked
    );

typedef PCI_MSIX_GET_ENTRY *PPCI_MSIX_GET_ENTRY;

_Must_inspect_result_
typedef
NTSTATUS
PCI_MSIX_GET_TABLE_SIZE (
    _In_ PVOID Context,
    _Out_ PULONG TableSize
    );

typedef PCI_MSIX_GET_TABLE_SIZE *PPCI_MSIX_GET_TABLE_SIZE;

typedef struct _PCI_MSIX_TABLE_CONFIG_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PPCI_MSIX_SET_ENTRY SetTableEntry;
    PPCI_MSIX_MASKUNMASK_ENTRY MaskTableEntry;
    PPCI_MSIX_MASKUNMASK_ENTRY UnmaskTableEntry;
    PPCI_MSIX_GET_ENTRY GetTableEntry;
    PPCI_MSIX_GET_TABLE_SIZE GetTableSize;
} PCI_MSIX_TABLE_CONFIG_INTERFACE, *PPCI_MSIX_TABLE_CONFIG_INTERFACE;

#define PCI_MSIX_TABLE_CONFIG_MINIMUM_SIZE \
        RTL_SIZEOF_THROUGH_FIELD(PCI_MSIX_TABLE_CONFIG_INTERFACE, UnmaskTableEntry)

// end_wdm
// begin_ntddk

#endif


//
//  Query the Filter Manager's name cache for the name, but don't try
//  to query the file system if the name is not in the cache.
//

#define FSRTL_FILE_NAME_QUERY_CACHE_ONLY  0x0200

//
//  Only query the file system for the name, bypassing the Filter Manager's
//  name cache completely. Any name retrieved will not be cached.
//

#define FSRTL_FILE_NAME_QUERY_FILESYSTEM_ONLY 0x0300

//
//  Query the Filter Manager's name cache, but if the name is not
//  found try to query the file system if it is safe to do so.
//

#define FSRTL_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP 0x0400

#if (NTDDI_VERSION >= NTDDI_WIN8)
NTSTATUS
FsRtlGetFileNameInformation (
    _In_ PFILE_OBJECT File,
    _In_ ULONG NameOptions,
    _Out_ PUNICODE_STRING FileName,
    _Out_ PVOID *FileNameInformation
    );

VOID
FsRtlReleaseFileNameInformation (
    _In_ PVOID FileNameInformation
    );
#endif //(NTDDI_VERSION >= NTDDI_WIN8)

//
//
//  The following constants are used to block top level Irp processing when
//  (in either the fast io or cc case) file system resources have been
//  acquired above the file system, or we are in an Fsp thread.
//

#define FSRTL_FSP_TOP_LEVEL_IRP                 ((LONG_PTR)0x01)
#define FSRTL_CACHE_TOP_LEVEL_IRP               ((LONG_PTR)0x02)
#define FSRTL_MOD_WRITE_TOP_LEVEL_IRP           ((LONG_PTR)0x03)
#define FSRTL_FAST_IO_TOP_LEVEL_IRP             ((LONG_PTR)0x04)
#define FSRTL_NETWORK1_TOP_LEVEL_IRP            ((LONG_PTR)0x05)
#define FSRTL_NETWORK2_TOP_LEVEL_IRP            ((LONG_PTR)0x06)
#define FSRTL_ASYNC_CACHED_READ_TOP_LEVEL_IRP   ((LONG_PTR)0x07)
#define FSRTL_MAX_TOP_LEVEL_IRP_FLAG            ((LONG_PTR)0xFFFF)

//
//  Normal uncompressed Copy and Mdl Apis
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
_Function_class_(FAST_IO_READ)
NTKERNELAPI
BOOLEAN
FsRtlCopyRead (
    _In_ PFILE_OBJECT FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
_Function_class_(FAST_IO_WRITE)
NTKERNELAPI
BOOLEAN
FsRtlCopyWrite (
    _In_ PFILE_OBJECT FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _In_reads_bytes_(Length) PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject
    );
#endif

// end_ntifs

_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlMdlRead (
    _In_ PFILE_OBJECT FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ ULONG LockKey,
    _Outptr_ PMDL *MdlChain,
    _Out_ PIO_STATUS_BLOCK IoStatus
    );

_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlMdlReadComplete (
    _In_ PFILE_OBJECT FileObject,
    _In_ PMDL MdlChain
    );

//
// Determine if there is a complete device failure on an error.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
NTKERNELAPI
BOOLEAN
FsRtlIsTotalDeviceFailure(
    _In_ NTSTATUS Status
    );

#define FsRtlIsChecksumError(STS) ((BOOLEAN)!FsRtlIsTotalDeviceFailure(STS))
#endif

#define LEGAL_ANSI_CHARACTER_ARRAY        (*FsRtlLegalAnsiCharacterArray) 
#define NLS_OEM_LEAD_BYTE_INFO            (*NlsOemLeadByteInfo) 

extern UCHAR const* const LEGAL_ANSI_CHARACTER_ARRAY;
extern PUSHORT NLS_OEM_LEAD_BYTE_INFO;  // Lead byte info. for ACP

//
//  These following bit values are set in the FsRtlLegalDbcsCharacterArray
//

#define FSRTL_FAT_LEGAL         0x01
#define FSRTL_HPFS_LEGAL        0x02
#define FSRTL_NTFS_LEGAL        0x04
#define FSRTL_WILD_CHARACTER    0x08
#define FSRTL_OLE_LEGAL         0x10
#define FSRTL_NTFS_STREAM_LEGAL (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)

//
//  The following macro is used to determine if an Ansi character is wild.
//

#define FsRtlIsAnsiCharacterWild(C) (                               \
    FsRtlTestAnsiCharacter((C), FALSE, FALSE, FSRTL_WILD_CHARACTER) \
)

//
//  The following macro is used to determine if an Ansi character is Fat legal.
//

#define FsRtlIsAnsiCharacterLegalFat(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_FAT_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Hpfs legal.
//

#define FsRtlIsAnsiCharacterLegalHpfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_HPFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Ntfs legal.
//

#define FsRtlIsAnsiCharacterLegalNtfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is
//  legal in an Ntfs stream name
//

#define FsRtlIsAnsiCharacterLegalNtfsStream(C,WILD_OK) (                    \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_STREAM_LEGAL)   \
)

//
//  The following macro is used to determine if an Ansi character is legal,
//  according to the caller's specification.
//

#define FsRtlIsAnsiCharacterLegal(C,FLAGS) (          \
    FsRtlTestAnsiCharacter((C), TRUE, FALSE, (FLAGS)) \
)

//
//  The following macro is used to test attributes of an Ansi character,
//  according to the caller's specified flags.
//

#define FsRtlTestAnsiCharacter(C, DEFAULT_RET, WILD_OK, FLAGS) (            \
        ((SCHAR)(C) < 0) ? DEFAULT_RET :                                    \
                           FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)],         \
                                   (FLAGS) |                                \
                                   ((WILD_OK) ? FSRTL_WILD_CHARACTER : 0) ) \
)


//
//  The following two macros use global data defined in ntos\rtl\nlsdata.c
//
//  BOOLEAN
//  FsRtlIsLeadDbcsCharacter (
//      _In_ UCHAR DbcsCharacter
//      );
//
//  /*++
//
//  Routine Description:
//
//      This routine takes the first bytes of a Dbcs character and
//      returns whether it is a lead byte in the system code page.
//
//  Arguments:
//
//      DbcsCharacter - Supplies the input character being examined
//
//  Return Value:
//
//      BOOLEAN - TRUE if the input character is a dbcs lead and
//              FALSE otherwise
//
//  --*/
//
//

#define FsRtlIsLeadDbcsCharacter(DBCS_CHAR) (                      \
    (BOOLEAN)((UCHAR)(DBCS_CHAR) < 0x80 ? FALSE :                  \
              (NLS_MB_CODE_PAGE_TAG &&                             \
               (NLS_OEM_LEAD_BYTE_INFO[(UCHAR)(DBCS_CHAR)] != 0))) \
)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FsRtlDissectDbcs (
    _In_ ANSI_STRING Path,
    _Out_ PANSI_STRING FirstName,
    _Out_ PANSI_STRING RemainingName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlDoesDbcsContainWildCards (
    _In_ PANSI_STRING Name
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlIsDbcsInExpression (
    _In_ PANSI_STRING Expression,
    _In_ PANSI_STRING Name
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlIsFatDbcsLegal (
    _In_ ANSI_STRING DbcsName,
    _In_ BOOLEAN WildCardsPermissible,
    _In_ BOOLEAN PathNamePermissible,
    _In_ BOOLEAN LeadingBackslashPermissible
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlIsNameInExpression (
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable
    );
#endif

//
//  Returns TRUE if the given fileObject represents a system paging file,
//  returns FALSE otherwise.
//

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTKERNELAPI
LOGICAL
FsRtlIsSystemPagingFile (
    _In_ PFILE_OBJECT FileObject
    );
#endif

//////////////////////////////////////////////////////////////////////////
//
//              Extra Create Parameter Support routines
//
//  These routines are used when processing a create IRP to allow passing
//  extra information up and down the file system stack.  This is used by
//  file system filters, Client Side Encryption, Transactions etc.
//
//////////////////////////////////////////////////////////////////////////

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _ECP_LIST ECP_LIST;
typedef struct _ECP_LIST *PECP_LIST;
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct _ECP_HEADER ECP_HEADER;
typedef struct _ECP_HEADER *PECP_HEADER;
#endif

//
//  Prototype for the ECP cleanup routine callback
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef VOID
(*PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK) (
    _Inout_ PVOID EcpContext,
    _In_ LPCGUID EcpType
    );
#endif



//
//  Basic ECP functions
//

//
//  Flags used by FsRtlAllocateExtraCreateParameterList
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef ULONG FSRTL_ALLOCATE_ECPLIST_FLAGS;

    //
    //  Charge this memory against the quota of the current process
    //

    #define FSRTL_ALLOCATE_ECPLIST_FLAG_CHARGE_QUOTA    0x00000001
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlAllocateExtraCreateParameterList (
    _In_ FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,
    _Outptr_ PECP_LIST *EcpList
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FsRtlFreeExtraCreateParameterList (
    _In_ PECP_LIST EcpList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
NTSTATUS
FsRtlInitializeExtraCreateParameterList (
    _Inout_ PECP_LIST EcpList
    );
#endif

//
//  Flags used by FsRtlAllocateExtraCreateParameter
//            and FsRtlAllocateExtraCreateParameterFromLookasideList
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef ULONG FSRTL_ALLOCATE_ECP_FLAGS;

    //
    //  If set charage quota against the current process for this
    //  allocation.  This flag is ignored if using a lookaside list
    //

    #define FSRTL_ALLOCATE_ECP_FLAG_CHARGE_QUOTA    0x00000001

    //
    //  If set allocate the ECP from non-paged pool
    //  Else use paged pool
    //

    #define FSRTL_ALLOCATE_ECP_FLAG_NONPAGED_POOL   0x00000002
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlAllocateExtraCreateParameter (
    _In_ LPCGUID EcpType,
    _In_ ULONG SizeOfContext,
    _In_ FSRTL_ALLOCATE_ECP_FLAGS Flags,
    _In_opt_ PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,
    _In_ ULONG PoolTag,
    _Outptr_result_bytebuffer_(SizeOfContext) PVOID *EcpContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FsRtlFreeExtraCreateParameter (
    _In_ PVOID EcpContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
NTKERNELAPI
VOID
FsRtlInitializeExtraCreateParameter(
    _Out_ PECP_HEADER Ecp,
    _In_ ULONG EcpFlags,
    _In_opt_ PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,
    _In_ ULONG TotalSize,
    _In_ LPCGUID EcpType,
    _In_opt_ PVOID ListAllocatedFrom
    );
#endif

//
//  Flags used by FsRtlInitExtraCreateParameterLookasideList
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef ULONG FSRTL_ECP_LOOKASIDE_FLAGS;

    //
    //  If set this is a NON-PAGED lookaside list
    //  ELSE this is a PAGED lookaside list
    //

    #define FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL 0x00000002
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_When_(Flags|FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(!(Flags|FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL), _IRQL_requires_max_(APC_LEVEL))
NTKERNELAPI
VOID
FsRtlInitExtraCreateParameterLookasideList (
    _Inout_ PVOID Lookaside,
    _In_ FSRTL_ECP_LOOKASIDE_FLAGS Flags,
    _In_ SIZE_T Size,
    _In_ ULONG Tag
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_When_(Flags|FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL, _IRQL_requires_max_(DISPATCH_LEVEL))
_When_(!(Flags|FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL), _IRQL_requires_max_(APC_LEVEL))
VOID
FsRtlDeleteExtraCreateParameterLookasideList (
    _Inout_ PVOID Lookaside,
    _In_ FSRTL_ECP_LOOKASIDE_FLAGS Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlAllocateExtraCreateParameterFromLookasideList (
    _In_ LPCGUID EcpType,
     ULONG SizeOfContext,
    _In_ FSRTL_ALLOCATE_ECP_FLAGS Flags,
    _In_opt_ PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,
    _Inout_ PVOID LookasideList,
    _Outptr_ PVOID *EcpContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlInsertExtraCreateParameter (
    _Inout_ PECP_LIST EcpList,
    _Inout_ PVOID EcpContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlFindExtraCreateParameter (
    _In_ PECP_LIST EcpList,
    _In_ LPCGUID EcpType,
    _Outptr_opt_ PVOID *EcpContext,
    _Out_opt_ ULONG *EcpContextSize
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlRemoveExtraCreateParameter (
    _Inout_ PECP_LIST EcpList,
    _In_ LPCGUID EcpType,
    _Outptr_ PVOID *EcpContext,
    _Out_opt_ ULONG *EcpContextSize
    );
#endif

//
//  Functions to get and set Extra Create Parameters into/out of a create IRP
//


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlGetEcpListFromIrp (
    _In_ PIRP Irp,
    _Outptr_result_maybenull_ PECP_LIST *EcpList
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlSetEcpListIntoIrp (
    _Inout_ PIRP Irp,
    _In_ PECP_LIST EcpList
    );
#endif


//
//   Additional functions used for full functionality
//


#if (NTDDI_VERSION >= NTDDI_VISTA)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlGetNextExtraCreateParameter (
    _In_ PECP_LIST EcpList,
    _In_opt_ PVOID CurrentEcpContext,
    _Out_opt_ LPGUID NextEcpType,
    _Outptr_opt_ PVOID *NextEcpContext,
    _Out_opt_ ULONG *NextEcpContextSize
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
VOID
FsRtlAcknowledgeEcp (
    _In_ PVOID EcpContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(APC_LEVEL)
VOID
FsRtlPrepareToReuseEcp (
    _In_ PVOID EcpContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlIsEcpAcknowledged (
    _In_ PVOID EcpContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
BOOLEAN
FsRtlIsEcpFromUserMode (
    _In_ PVOID EcpContext
    );
#endif


#if (NTDDI_VERSION > NTDDI_VISTA)

//
//  Routine to query maximum depth of virtual disk layering support.
//

NTKERNELAPI
ULONG
FsRtlQueryMaximumVirtualDiskNestingLevel (
    VOID
    );

//
//  Routine to query virtual disk info for a given disk or volume object
//

NTKERNELAPI
NTSTATUS
FsRtlGetVirtualDiskNestingLevel (
    _In_ PDEVICE_OBJECT DeviceObject,
    _Out_ PULONG NestingLevel,
    _Out_opt_ PULONG NestingFlags
    );

//
//  Current possible values for NestingFlags.
//

#define FSRTL_VIRTDISK_FULLY_ALLOCATED         0x00000001
#define FSRTL_VIRTDISK_NO_DRIVE_LETTER         0x00000002
// end_ntifs
#define FSRTL_VIRTDISK_NO_DRIVE_LETTER_ALWAYS  0x00000004
// begin_ntifs

#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)

//
//  Routine to synchronously issue a device IO control operation and wait for
//  it to complete
//

NTSTATUS
FsRtlIssueDeviceIoControl (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ ULONG IoCtl,
    _In_ UCHAR Flags,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG_PTR IosbInformation
    );

//
//  Routine used by file systems to retrieve the logical and phpysical sector
//  size information for the give storage stack device object.
//

NTSTATUS
FsRtlGetSectorSizeInformation (
    _In_ PDEVICE_OBJECT DeviceObject,
    _Out_ PFILE_FS_SECTOR_SIZE_INFORMATION SectorSizeInfo
    );

#endif

//
//  Routine to get supported features for a volume that a device object is attatched to
//

#if (NTDDI_VERSION >= NTDDI_WIN8)
_Must_inspect_result_
_IRQL_requires_max_(APC_LEVEL)
NTKERNELAPI
NTSTATUS
FsRtlGetSupportedFeatures (
    _In_ PDEVICE_OBJECT DeviceObject,
    _Out_ PULONG SupportedFeatures
    );

//
//  Routines to support the following operations using a file object
//

NTSTATUS
FsRtlKernelFsControlFile(
    _In_ PFILE_OBJECT FileObject,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_to_(OutputBufferLength, *RetOutputBufferSize) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_ PULONG RetOutputBufferSize
    );

NTSTATUS
FsRtlQueryKernelEaFile(
    _In_ PFILE_OBJECT FileObject,
    _Out_writes_bytes_to_(Length,*LengthReturned) PVOID ReturnedEaData,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan,
    _Out_opt_ PULONG LengthReturned
    );

NTSTATUS
FsRtlSetKernelEaFile(
    _In_ PFILE_OBJECT FileObject,
    _In_reads_bytes_(Length) PVOID EaBuffer,
    _In_ ULONG Length
    );

#endif

#if (NTDDI_VERSION >= NTDDI_THRESHOLD)
//
//  Routines to support the following operations using a file object
//

NTSTATUS
FsRtlQueryInformationFile(
    _In_ PFILE_OBJECT FileObject,
    _Out_writes_bytes_to_(Length,*RetFileInformationSize) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _Out_ PULONG RetFileInformationSize
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
//
//  Routine for Querying the VDL of a file
//

NTSTATUS
FsRtlQueryCachedVdl(
    _In_ PFILE_OBJECT FileObject,
    _Out_ PLONGLONG Vdl
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
//
//  Routine to update disk IO counters for filesystems
//

VOID
FsRtlUpdateDiskCounters (
    _In_ ULONG64 BytesRead,
    _In_ ULONG64 BytesWritten
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN8)
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FsRtlDismountComplete (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ NTSTATUS DismountStatus
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINBLUE)
_IRQL_requires_max_ (APC_LEVEL)
NTSTATUS
FsRtlSetDriverBacking(
    _In_ PDRIVER_OBJECT DriverObj,
    _In_ ULONG Flags                        //see below flag defintions
    );

//
//  If set back this driver using the PageFile
//

#define FSRTL_DRIVER_BACKING_FLAG_USE_PAGE_FILE        0x00000001

#endif

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

BOOLEAN
NTKERNELAPI
FsRtlIsMobileOS();

#endif

NTKERNELAPI
NTSTATUS
LpcRequestPort(
    _In_ PVOID PortAddress,
    _In_ PPORT_MESSAGE RequestMessage
    );

NTKERNELAPI
NTSTATUS
LpcRequestWaitReplyPort(
    _In_ PVOID PortAddress,
    _In_ PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage
    );

NTKERNELAPI
NTSTATUS
LpcRequestWaitReplyPortEx (
    _In_ PVOID PortAddress,
    _In_ PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage
    );

NTKERNELAPI
NTSTATUS
LpcReplyWaitReplyPort (
    _In_ PVOID PortAddress,
    _In_ KPROCESSOR_MODE WaitMode,
    _Inout_ PPORT_MESSAGE ReplyMessage
    );

NTKERNELAPI
NTSTATUS
LpcDisconnectPort (
    _In_ PVOID Port
    );

NTKERNELAPI
NTSTATUS
LpcSendWaitReceivePort(
    _In_ PVOID PortObject,
    _In_ PPORT_MESSAGE SendMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage,
    _Inout_opt_ PSIZE_T BufferLength,
    _In_ KPROCESSOR_MODE WaitMode,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
    );


//------------------------------------------------------ WHEA_ERROR_SOURCE_TYPE

#define WHEA_PHYSICAL_ADDRESS LARGE_INTEGER

//
// This enumeration defines the various types of error sources that a platform
// can expose to the operating system.
//

typedef enum _WHEA_ERROR_SOURCE_TYPE {
    WheaErrSrcTypeMCE        = 0x00,    // Machine Check Exception
    WheaErrSrcTypeCMC        = 0x01,    // Corrected Machine Check
    WheaErrSrcTypeCPE        = 0x02,    // Corrected Platform Error
    WheaErrSrcTypeNMI        = 0x03,    // Non-Maskable Interrupt
    WheaErrSrcTypePCIe       = 0x04,    // PCI Express Error
    WheaErrSrcTypeGeneric    = 0x05,    // Other types of error sources
    WheaErrSrcTypeINIT       = 0x06,    // IA64 INIT Error Source
    WheaErrSrcTypeBOOT       = 0x07,    // BOOT Error Source
    WheaErrSrcTypeSCIGeneric = 0x08,    // SCI-based generic error source
    WheaErrSrcTypeIPFMCA     = 0x09,    // Itanium Machine Check Abort
    WheaErrSrcTypeIPFCMC     = 0x0a,    // Itanium Machine check
    WheaErrSrcTypeIPFCPE     = 0x0b,    // Itanium Corrected Platform Error
    WheaErrSrcTypeMax
} WHEA_ERROR_SOURCE_TYPE, *PWHEA_ERROR_SOURCE_TYPE;

//
// Error sources have a runtime state associated with them. The following are
// the valid states for an error source.
//

typedef enum _WHEA_ERROR_SOURCE_STATE {
    WheaErrSrcStateStopped = 0x01,
    WheaErrSrcStateStarted = 0x02
} WHEA_ERROR_SOURCE_STATE, *PWHEA_ERROR_SOURCE_STATE;

#define WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10          10

#define WHEA_MAX_MC_BANKS                                32

#define WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST             0x00000001
#define WHEA_ERROR_SOURCE_FLAG_GLOBAL                    0x00000002
#define WHEA_ERROR_SOURCE_FLAG_PREALLOCATE_PER_PROCESSOR 0x00000004
#define WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE             0x80000000

#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE         0
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC         1
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI         2
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA         3
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC         4
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE         5
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT    6
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT    7
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE      8
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC        9

#define WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA            0
#define WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA         1
#define WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA           2

#define WHEA_NOTIFICATION_TYPE_POLLED                    0
#define WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT         1
#define WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT            2
#define WHEA_NOTIFICATION_TYPE_SCI                       3
#define WHEA_NOTIFICATION_TYPE_NMI                       4

#include <pshpack1.h>

//------------------------------------------------ WHEA_ERROR_SOURCE_DESCRIPTOR

typedef union _WHEA_NOTIFICATION_FLAGS {
    struct {
        USHORT PollIntervalRW:1;
        USHORT SwitchToPollingThresholdRW:1;
        USHORT SwitchToPollingWindowRW:1;
        USHORT ErrorThresholdRW:1;
        USHORT ErrorThresholdWindowRW:1;
        USHORT Reserved:11;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} WHEA_NOTIFICATION_FLAGS, *PWHEA_NOTIFICATION_FLAGS;

typedef union _XPF_MC_BANK_FLAGS {
    struct {
        UCHAR ClearOnInitializationRW:1;
        UCHAR ControlDataRW:1;
        UCHAR Reserved:6;
    } DUMMYSTRUCTNAME;
    UCHAR AsUCHAR;
} XPF_MC_BANK_FLAGS, *PXPF_MC_BANK_FLAGS;

typedef union _XPF_MCE_FLAGS {
    struct {
        ULONG MCG_CapabilityRW:1;
        ULONG MCG_GlobalControlRW:1;
        ULONG Reserved:30;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} XPF_MCE_FLAGS, *PXPF_MCE_FLAGS;

typedef union _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT RootErrorCommandRW:1;
        USHORT Reserved:11;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_ROOTPORT_DESCRIPTOR_FLAGS, *PAER_ROOTPORT_DESCRIPTOR_FLAGS;

typedef union _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT Reserved:12;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_ENDPOINT_DESCRIPTOR_FLAGS, *PAER_ENDPOINT_DESCRIPTOR_FLAGS;

typedef union _AER_BRIDGE_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT SecondaryUncorrectableErrorMaskRW:1;
        USHORT SecondaryUncorrectableErrorSevRW:1;
        USHORT SecondaryCapsAndControlRW:1;
        USHORT Reserved:9;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_BRIDGE_DESCRIPTOR_FLAGS, *PAER_BRIDGE_DESCRIPTOR_FLAGS;

//
// The following structure is used to describe how a given error source reports
// errors to the OS.
//

typedef struct _WHEA_NOTIFICATION_DESCRIPTOR {
    UCHAR Type;
    UCHAR Length;
    WHEA_NOTIFICATION_FLAGS Flags;

    union {
        struct {
            ULONG PollInterval;
        } Polled;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Interrupt;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } LocalInterrupt;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Sci;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Nmi;
    } u;
} WHEA_NOTIFICATION_DESCRIPTOR, *PWHEA_NOTIFICATION_DESCRIPTOR;

//
// The following structure describes an XPF machine check bank. It identifies
// the bank with a BankNumber and it contains information that is used to
// configure the bank. MCE and CMC error sources make use of this descriptor
// to describe and configure each bank.
//

typedef struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
    UCHAR BankNumber;
    BOOLEAN ClearOnInitialization;
    UCHAR StatusDataFormat;
    XPF_MC_BANK_FLAGS Flags;
    ULONG ControlMsr;
    ULONG StatusMsr;
    ULONG AddressMsr;
    ULONG MiscMsr;
    ULONGLONG ControlData;
} WHEA_XPF_MC_BANK_DESCRIPTOR, *PWHEA_XPF_MC_BANK_DESCRIPTOR;

//
// The following structure describes an XPF platform's machine check exception
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's MCE error source.
//

typedef struct _WHEA_XPF_MCE_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR NumberOfBanks;
    XPF_MCE_FLAGS Flags;
    ULONGLONG MCG_Capability;
    ULONGLONG MCG_GlobalControl;
    WHEA_XPF_MC_BANK_DESCRIPTOR Banks[WHEA_MAX_MC_BANKS];
} WHEA_XPF_MCE_DESCRIPTOR, *PWHEA_XPF_MCE_DESCRIPTOR;

//
// The following structure describes an XPF platform's corrected machine check
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's CMC error source.
//

typedef struct _WHEA_XPF_CMC_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR NumberOfBanks;
    ULONG Reserved;
    WHEA_NOTIFICATION_DESCRIPTOR Notify;
    WHEA_XPF_MC_BANK_DESCRIPTOR Banks[WHEA_MAX_MC_BANKS];
} WHEA_XPF_CMC_DESCRIPTOR, *PWHEA_XPF_CMC_DESCRIPTOR;

typedef struct _WHEA_PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG DeviceNumber:5;
            ULONG FunctionNumber:3;
            ULONG Reserved:24;
        } bits;
        ULONG AsULONG;
    } u;
} WHEA_PCI_SLOT_NUMBER, *PWHEA_PCI_SLOT_NUMBER;

//
// The following structure describes an XPF platform's non-maskable interrupt
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's NMI error source.
//

typedef struct _WHEA_XPF_NMI_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
} WHEA_XPF_NMI_DESCRIPTOR, *PWHEA_XPF_NMI_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER root port
// error source. The information represented in this structure tells the OS how
// to configure the root port's AER settings.
//

typedef struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_ROOTPORT_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
    ULONG RootErrorCommand;
} WHEA_AER_ROOTPORT_DESCRIPTOR, *PWHEA_AER_ROOTPORT_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER endpoint
// error source. The information represented in this structure tells the OS how
// to configure the device's AER settings.
//

typedef struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_ENDPOINT_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
} WHEA_AER_ENDPOINT_DESCRIPTOR, *PWHEA_AER_ENDPOINT_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER bridge
// error source. The information represented in this structure tells the OS how
// to configure the bridge's AER settings.
//

typedef struct _WHEA_AER_BRIDGE_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_BRIDGE_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
    ULONG SecondaryUncorrectableErrorMask;
    ULONG SecondaryUncorrectableErrorSev;
    ULONG SecondaryCapsAndControl;
} WHEA_AER_BRIDGE_DESCRIPTOR, *PWHEA_AER_BRIDGE_DESCRIPTOR;

//
// The following structure describes a generic error source to the OS. Using
// the information in this structure the OS is able to configure a handler for
// the generic error source.
//

typedef struct _WHEA_GENERIC_ERROR_DESCRIPTOR {

    //
    // Type is WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC.
    //

    USHORT Type;

    //
    // This field is reserved.
    //

    UCHAR Reserved;

    //
    // Indicates whether the generic error source is to be enabled.
    //

    UCHAR Enabled;

    //
    // Length of the error status block.
    //

    ULONG ErrStatusBlockLength;

    //
    // If this generic error source relates back to another error source, keep
    // it's identifier here.
    //

    ULONG RelatedErrorSourceId;

    //
    // The following 5 fields have the same layout as a GEN_ADDR structure. They
    // describe the address at which the OS reads error status information
    // from the error source.
    //

    UCHAR ErrStatusAddressSpaceID;
    UCHAR ErrStatusAddressBitWidth;
    UCHAR ErrStatusAddressBitOffset;
    UCHAR ErrStatusAddressAccessSize;
    WHEA_PHYSICAL_ADDRESS ErrStatusAddress;

    //
    // Notify describes how the generic error source notifies the OS that error
    // information is available.
    //

    WHEA_NOTIFICATION_DESCRIPTOR Notify;

} WHEA_GENERIC_ERROR_DESCRIPTOR, *PWHEA_GENERIC_ERROR_DESCRIPTOR;

typedef struct _WHEA_IPF_MCA_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_MCA_DESCRIPTOR, *PWHEA_IPF_MCA_DESCRIPTOR;

typedef struct _WHEA_IPF_CMC_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_CMC_DESCRIPTOR, *PWHEA_IPF_CMC_DESCRIPTOR;

typedef struct _WHEA_IPF_CPE_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_CPE_DESCRIPTOR, *PWHEA_IPF_CPE_DESCRIPTOR;

typedef struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
    ULONG Length;                                              // +00 (0)
    ULONG Version;                                             // +04 (4)
    WHEA_ERROR_SOURCE_TYPE Type;                               // +08 (8)
    WHEA_ERROR_SOURCE_STATE State;                             // +0C (12)
    ULONG MaxRawDataLength;                                    // +10 (16)
    ULONG NumRecordsToPreallocate;                             // +14 (20)
    ULONG MaxSectionsPerRecord;                                // +18 (24)
    ULONG ErrorSourceId;                                       // +1C (28)
    ULONG PlatformErrorSourceId;                               // +20 (32)
    ULONG Flags;                                               // +24 (36)

    union {                                                    // +28 (40)
        WHEA_XPF_MCE_DESCRIPTOR XpfMceDescriptor;
        WHEA_XPF_CMC_DESCRIPTOR XpfCmcDescriptor;
        WHEA_XPF_NMI_DESCRIPTOR XpfNmiDescriptor;
        WHEA_IPF_MCA_DESCRIPTOR IpfMcaDescriptor;
        WHEA_IPF_CMC_DESCRIPTOR IpfCmcDescriptor;
        WHEA_IPF_CPE_DESCRIPTOR IpfCpeDescriptor;
        WHEA_AER_ROOTPORT_DESCRIPTOR AerRootportDescriptor;
        WHEA_AER_ENDPOINT_DESCRIPTOR AerEndpointDescriptor;
        WHEA_AER_BRIDGE_DESCRIPTOR AerBridgeDescriptor;
        WHEA_GENERIC_ERROR_DESCRIPTOR GenErrDescriptor;
    } Info;

} WHEA_ERROR_SOURCE_DESCRIPTOR, *PWHEA_ERROR_SOURCE_DESCRIPTOR;

//
// WHEA PFA Policy Type
//

#define    WHEA_DISABLE_OFFLINE        0
#define    WHEA_MEM_PERSISTOFFLINE     1
#define    WHEA_MEM_PFA_DISABLE        2
#define    WHEA_MEM_PFA_PAGECOUNT      3
#define    WHEA_MEM_PFA_THRESHOLD      4
#define    WHEA_MEM_PFA_TIMEOUT        5
#define    WHEA_DISABLE_DUMMY_WRITE    6

#include <poppack.h>


//
// The general format of the common platform error record is illustrated below.
// A record consists of a header; followed by one or more section descriptors;
// and for each descriptor, an associated section which may contain either error
// or informational data.
//
// The record may include extra buffer space to allow for the dynamic addition
// of error sections descriptors and bodies, as well as for dynamically
// increasing the size of existing sections.
//
// +---------------------------------------------+
// | Record Header                               |
// |   SectionCount == N                         |
// +---------------------------------------------+
// | Section Descriptor 1                        |
// |   Offset, size                              | ---+
// +---------------------------------------------+    |
// | Section Descriptor 2                        |    |
// |   Offset, size                              | ---+---+
// +---------------------------------------------+    |   |
// |                                             |    |   |
// | ....                                        |    |   |
// |                                             |    |   |
// +---------------------------------------------+    |   |
// | Section Descriptor N                        | ---+---+---+
// |   Offset, size                              |    |   |   |
// +---------------------------------------------+    |   |   |
// |                     Buffer space for adding |    |   |   |
// |                   more section descriptors. |    |   |   |
// +---------------------------------------------|    |   |   |
// | Section 1                                   | <--+   |   |
// |                                             |        |   |
// +---------------------------------------------+        |   |
// | Section 2                                   | <------+   |
// |                                             |            |
// +---------------------------------------------+            |
// |                                             |            |
// |                                             |            |
// | ....                                        |            |
// |                                             |            |
// |                                             |            |
// +---------------------------------------------+            |
// | Section N                                   | <----------+
// |                                             |
// +---------------------------------------------+
// |                                             |
// |                                             |
// |                                             |
// |                     Buffer space for adding |
// |                        more section bodies. |
// |                                             |
// |                                             |
// |                                             |
// +---------------------------------------------+
//

// -------------------------------------------- Specification validation macros

//
// The following macro implements a compile-time check for the offset and length
// of the specified structure member. This can be used to validate the defined
// structures against the specification.
//

#define CPER_FIELD_CHECK(type, field, offset, length) \
    C_ASSERT(((FIELD_OFFSET(type, field) == (offset)) && \
              (RTL_FIELD_SIZE(type, field) == (length))))

#include <pshpack1.h>

//---------------------------------- Downlevel GUID variable name compatibility

#if WHEA_DOWNLEVEL_TYPE_NAMES

#define PROCESSOR_GENERIC_SECTION_GUID          PROCESSOR_GENERIC_ERROR_SECTION_GUID
#define X86_PROCESSOR_SPECIFIC_SECTION_GUID     XPF_PROCESSOR_ERROR_SECTION_GUID
#define IPF_PROCESSOR_SPECIFIC_SECTION_GUID     IPF_PROCESSOR_ERROR_SECTION_GUID
#define PLATFORM_MEMORY_SECTION_GUID            MEMORY_ERROR_SECTION_GUID
#define PCIEXPRESS_SECTION_GUID                 PCIEXPRESS_ERROR_SECTION_GUID
#define PCIX_BUS_SECTION_GUID                   PCIXBUS_ERROR_SECTION_GUID
#define PCIX_COMPONENT_SECTION_GUID             PCIXDEVICE_ERROR_SECTION_GUID
#define IPF_SAL_RECORD_REFERENCE_SECTION_GUID   FIRMWARE_ERROR_RECORD_REFERENCE_GUID

#endif

//------------------------------------------ Common Platform Error Record types

//
// These types are used in several of the common platform error record
// structures.
//

typedef union _WHEA_REVISION {
    struct {
        UCHAR MinorRevision;
        UCHAR MajorRevision;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} WHEA_REVISION, *PWHEA_REVISION;

typedef enum _WHEA_ERROR_SEVERITY {
    WheaErrSevRecoverable   = 0,
    WheaErrSevFatal         = 1,
    WheaErrSevCorrected     = 2,
    WheaErrSevInformational = 3
} WHEA_ERROR_SEVERITY, *PWHEA_ERROR_SEVERITY;

typedef union _WHEA_TIMESTAMP {
    struct {
        ULONGLONG Seconds:8;
        ULONGLONG Minutes:8;
        ULONGLONG Hours:8;
        ULONGLONG Precise:1;
        ULONGLONG Reserved:7;
        ULONGLONG Day:8;
        ULONGLONG Month:8;
        ULONGLONG Year:8;
        ULONGLONG Century:8;
    } DUMMYSTRUCTNAME;
    LARGE_INTEGER AsLARGE_INTEGER;
} WHEA_TIMESTAMP, *PWHEA_TIMESTAMP;

typedef union _WHEA_PERSISTENCE_INFO {
    struct {
        ULONGLONG Signature:16;
        ULONGLONG Length:24;
        ULONGLONG Identifier:16;
        ULONGLONG Attributes:2;
        ULONGLONG DoNotLog:1;
        ULONGLONG Reserved:5;
    } DUMMYSTRUCTNAME;
    ULONGLONG AsULONGLONG;
} WHEA_PERSISTENCE_INFO, *PWHEA_PERSISTENCE_INFO;

#define ERRTYP_INTERNAL                 0x01 // 1
#define ERRTYP_BUS                      0x10 // 16
#define ERRTYP_MEM                      0x04 // 4
#define ERRTYP_TLB                      0x05 // 5
#define ERRTYP_CACHE                    0x06 // 6
#define ERRTYP_FUNCTION                 0x07 // 7
#define ERRTYP_SELFTEST                 0x08 // 8
#define ERRTYP_FLOW                     0x09 // 9
#define ERRTYP_MAP                      0x11 // 17
#define ERRTYP_IMPROPER                 0x12 // 18
#define ERRTYP_UNIMPL                   0x13 // 19
#define ERRTYP_LOSSOFLOCKSTEP           0x14 // 20
#define ERRTYP_RESPONSE                 0x15 // 21
#define ERRTYP_PARITY                   0x16 // 22
#define ERRTYP_PROTOCOL                 0x17 // 23
#define ERRTYP_PATHERROR                0x18 // 24
#define ERRTYP_TIMEOUT                  0x19 // 25
#define ERRTYP_POISONED                 0x1A // 26

typedef union _WHEA_ERROR_STATUS {
    ULONGLONG ErrorStatus;
    struct {
        ULONGLONG Reserved1:8;
        ULONGLONG ErrorType:8;
        ULONGLONG Address:1;
        ULONGLONG Control:1;
        ULONGLONG Data:1;
        ULONGLONG Responder:1;
        ULONGLONG Requester:1;
        ULONGLONG FirstError:1;
        ULONGLONG Overflow:1;
        ULONGLONG Reserved2:41;
    } DUMMYSTRUCTNAME;
} WHEA_ERROR_STATUS, *PWHEA_ERROR_STATUS;

//---------------------------------------------------- WHEA_ERROR_RECORD_HEADER

typedef union _WHEA_ERROR_RECORD_HEADER_VALIDBITS {
    struct {
        ULONG PlatformId:1;
        ULONG Timestamp:1;
        ULONG PartitionId:1;
        ULONG Reserved:29;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_RECORD_HEADER_VALIDBITS, *PWHEA_ERROR_RECORD_HEADER_VALIDBITS;

#define WHEA_ERROR_RECORD_VALID_PLATFORMID           0x00000001
#define WHEA_ERROR_RECORD_VALID_TIMESTAMP            0x00000002
#define WHEA_ERROR_RECORD_VALID_PARTITIONID          0x00000004

typedef union _WHEA_ERROR_RECORD_HEADER_FLAGS {
    struct {
        ULONG Recovered:1;
        ULONG PreviousError:1;
        ULONG Simulated:1;
        ULONG Reserved:29;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_RECORD_HEADER_FLAGS, *PWHEA_ERROR_RECORD_HEADER_FLAGS;

#define WHEA_ERROR_RECORD_FLAGS_RECOVERED            0x00000001
#define WHEA_ERROR_RECORD_FLAGS_PREVIOUSERROR        0x00000002
#define WHEA_ERROR_RECORD_FLAGS_SIMULATED            0x00000004

typedef struct _WHEA_ERROR_RECORD_HEADER {
    ULONG Signature;
    WHEA_REVISION Revision;
    ULONG SignatureEnd;
    USHORT SectionCount;
    WHEA_ERROR_SEVERITY Severity;
    WHEA_ERROR_RECORD_HEADER_VALIDBITS ValidBits;
    _Field_range_(>=, (sizeof(WHEA_ERROR_RECORD_HEADER)
                       + (SectionCount
                          * sizeof(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR))))
        ULONG Length;
    WHEA_TIMESTAMP Timestamp;
    GUID PlatformId;
    GUID PartitionId;
    GUID CreatorId;
    GUID NotifyType;
    ULONGLONG RecordId;
    WHEA_ERROR_RECORD_HEADER_FLAGS Flags;
    WHEA_PERSISTENCE_INFO PersistenceInfo;
    UCHAR Reserved[12];
} WHEA_ERROR_RECORD_HEADER, *PWHEA_ERROR_RECORD_HEADER;

//
// Distinguished values used in the common platform error record header
// signature.
//

#define WHEA_ERROR_RECORD_SIGNATURE         'REPC'
#define WHEA_ERROR_RECORD_REVISION          0x0210
#define WHEA_ERROR_RECORD_SIGNATURE_END     0xFFFFFFFF

//
// Validate the error record header structure against the definitions in the
// UEFI specification.
//

CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, Signature,         0,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, Revision,          4,  2);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, SignatureEnd,      6,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, SectionCount,     10,  2);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, Severity,         12,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, ValidBits,        16,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, Length,           20,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, Timestamp,        24,  8);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, PlatformId,       32, 16);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, PartitionId,      48, 16);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, CreatorId,        64, 16);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, NotifyType,       80, 16);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, RecordId,         96,  8);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, Flags,           104,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, PersistenceInfo, 108,  8);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_HEADER, Reserved,        116, 12);

//---------------------------------------- WHEA_ERROR_RECORD_SECTION_DESCRIPTOR

typedef union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS {
    struct {
        ULONG Primary:1;
        ULONG ContainmentWarning:1;
        ULONG Reset:1;
        ULONG ThresholdExceeded:1;
        ULONG ResourceNotAvailable:1;
        ULONG LatentError:1;
        ULONG Reserved:26;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS,
    *PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS;

#define WHEA_SECTION_DESCRIPTOR_FLAGS_PRIMARY            0x00000001
#define WHEA_SECTION_DESCRIPTOR_FLAGS_CONTAINMENTWRN     0x00000002
#define WHEA_SECTION_DESCRIPTOR_FLAGS_RESET              0x00000004
#define WHEA_SECTION_DESCRIPTOR_FLAGS_THRESHOLDEXCEEDED  0x00000008
#define WHEA_SECTION_DESCRIPTOR_FLAGS_RESOURCENA         0x00000010
#define WHEA_SECTION_DESCRIPTOR_FLAGS_LATENTERROR        0x00000020

typedef union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS {
    struct {
        UCHAR FRUId:1;
        UCHAR FRUText:1;
        UCHAR Reserved:6;
    } DUMMYSTRUCTNAME;
    UCHAR AsUCHAR;
} WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS,
    *PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS;

typedef struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR {
    ULONG SectionOffset;
    ULONG SectionLength;
    WHEA_REVISION Revision;
    WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS ValidBits;
    UCHAR Reserved;
    WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS Flags;
    GUID SectionType;
    GUID FRUId;
    WHEA_ERROR_SEVERITY SectionSeverity;
    CCHAR FRUText[20];
} WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, *PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR;

#define WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_REVISION   0x0201

#if WHEA_DOWNLEVEL_TYPE_NAMES

#define WHEA_SECTION_DESCRIPTOR_REVISION \
    WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_REVISION

#endif

//
// Validate the error record section descriptor structure against the
// definitions in the UEFI specification.
//

CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, SectionOffset,    0,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, SectionLength,    4,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, Revision,         8,  2);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, ValidBits,       10,  1);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, Reserved,        11,  1);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, Flags,           12,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, SectionType,     16, 16);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, FRUId,           32, 16);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, SectionSeverity, 48,  4);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR, FRUText,         52, 20);

//----------------------------------------------------------- WHEA_ERROR_RECORD

typedef _Struct_size_bytes_(Header.Length) struct _WHEA_ERROR_RECORD {
    WHEA_ERROR_RECORD_HEADER Header;
    _Field_size_(Header.SectionCount)
        WHEA_ERROR_RECORD_SECTION_DESCRIPTOR SectionDescriptor[ANYSIZE_ARRAY];
} WHEA_ERROR_RECORD, *PWHEA_ERROR_RECORD;

//
// Validate the error record structure against the definitions in the UEFI
// specification.
//

CPER_FIELD_CHECK(WHEA_ERROR_RECORD, Header,              0,  128);
CPER_FIELD_CHECK(WHEA_ERROR_RECORD, SectionDescriptor, 128,   72);

//---------------------------------------- WHEA_PROCESSOR_GENERIC_ERROR_SECTION

#define GENPROC_PROCTYPE_XPF                 0
#define GENPROC_PROCTYPE_IPF                 1

#define GENPROC_PROCISA_X86                  0
#define GENPROC_PROCISA_IPF                  1
#define GENPROC_PROCISA_X64                  2

#define GENPROC_PROCERRTYPE_UNKNOWN          0
#define GENPROC_PROCERRTYPE_CACHE            1
#define GENPROC_PROCERRTYPE_TLB              2
#define GENPROC_PROCERRTYPE_BUS              4
#define GENPROC_PROCERRTYPE_MAE              8

#define GENPROC_OP_GENERIC                   0
#define GENPROC_OP_DATAREAD                  1
#define GENPROC_OP_DATAWRITE                 2
#define GENPROC_OP_INSTRUCTIONEXE            3

#define GENPROC_FLAGS_RESTARTABLE            0x01
#define GENPROC_FLAGS_PRECISEIP              0x02
#define GENPROC_FLAGS_OVERFLOW               0x04
#define GENPROC_FLAGS_CORRECTED              0x08

typedef union _WHEA_PROCESSOR_FAMILY_INFO {
    struct {
        ULONG Stepping:4;
        ULONG Model:4;
        ULONG Family:4;
        ULONG ProcessorType:2;
        ULONG Reserved1:2;
        ULONG ExtendedModel:4;
        ULONG ExtendedFamily:8;
        ULONG Reserved2:4;
        ULONG Reserved3;
    } DUMMYSTRUCTNAME;
    ULONGLONG AsULONGLONG;
} WHEA_PROCESSOR_FAMILY_INFO, *PWHEA_PROCESSOR_FAMILY_INFO;

typedef union _WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS {
    struct {
        ULONGLONG ProcessorType:1;
        ULONGLONG InstructionSet:1;
        ULONGLONG ErrorType:1;
        ULONGLONG Operation:1;
        ULONGLONG Flags:1;
        ULONGLONG Level:1;
        ULONGLONG CPUVersion:1;
        ULONGLONG CPUBrandString:1;
        ULONGLONG ProcessorId:1;
        ULONGLONG TargetAddress:1;
        ULONGLONG RequesterId:1;
        ULONGLONG ResponderId:1;
        ULONGLONG InstructionPointer:1;
        ULONGLONG Reserved:51;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS,
  *PWHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS;

typedef struct _WHEA_PROCESSOR_GENERIC_ERROR_SECTION {
    WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS ValidBits;
    UCHAR ProcessorType;
    UCHAR InstructionSet;
    UCHAR ErrorType;
    UCHAR Operation;
    UCHAR Flags;
    UCHAR Level;
    USHORT Reserved;
    ULONGLONG CPUVersion;
    UCHAR CPUBrandString[128];
    ULONGLONG ProcessorId;
    ULONGLONG TargetAddress;
    ULONGLONG RequesterId;
    ULONGLONG ResponderId;
    ULONGLONG InstructionPointer;
} WHEA_PROCESSOR_GENERIC_ERROR_SECTION, *PWHEA_PROCESSOR_GENERIC_ERROR_SECTION;

//
// Define alternate type name for downlevel source compatibility.
//

#if WHEA_DOWNLEVEL_TYPE_NAMES

typedef WHEA_PROCESSOR_GENERIC_ERROR_SECTION_VALIDBITS
    WHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS,
    *PWHEA_GENERIC_PROCESSOR_ERROR_VALIDBITS;

typedef WHEA_PROCESSOR_GENERIC_ERROR_SECTION
    WHEA_GENERIC_PROCESSOR_ERROR, *PWHEA_GENERIC_PROCESSOR_ERROR;

#endif

//
// Validate the processor generic error section structure against the
// definitions in the UEFI  specification.
//

CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, ValidBits,            0,   8);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, ProcessorType,        8,   1);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, InstructionSet,       9,   1);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, ErrorType,           10,   1);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, Operation,           11,   1);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, Flags,               12,   1);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, Level,               13,   1);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, Reserved,            14,   2);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, CPUVersion,          16,   8);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, CPUBrandString,      24, 128);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, ProcessorId,        152,   8);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, TargetAddress,      160,   8);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, RequesterId,        168,   8);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, ResponderId,        176,   8);
CPER_FIELD_CHECK(WHEA_PROCESSOR_GENERIC_ERROR_SECTION, InstructionPointer, 184,   8);

//-------------------------------------------- WHEA_XPF_PROCESSOR_ERROR_SECTION

//
// x86/x64 cache check structure.
//

#define XPF_CACHE_CHECK_TRANSACTIONTYPE_INSTRUCTION     0
#define XPF_CACHE_CHECK_TRANSACTIONTYPE_DATAACCESS      1
#define XPF_CACHE_CHECK_TRANSACTIONTYPE_GENERIC         2

#define XPF_CACHE_CHECK_OPERATION_GENERIC               0
#define XPF_CACHE_CHECK_OPERATION_GENREAD               1
#define XPF_CACHE_CHECK_OPERATION_GENWRITE              2
#define XPF_CACHE_CHECK_OPERATION_DATAREAD              3
#define XPF_CACHE_CHECK_OPERATION_DATAWRITE             4
#define XPF_CACHE_CHECK_OPERATION_INSTRUCTIONFETCH      5
#define XPF_CACHE_CHECK_OPERATION_PREFETCH              6
#define XPF_CACHE_CHECK_OPERATION_EVICTION              7
#define XPF_CACHE_CHECK_OPERATION_SNOOP                 8

typedef union _WHEA_XPF_CACHE_CHECK {
    struct {
        ULONGLONG TransactionTypeValid:1;
        ULONGLONG OperationValid:1;
        ULONGLONG LevelValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ReservedValid:8;

        ULONGLONG TransactionType:2;
        ULONGLONG Operation:4;
        ULONGLONG Level:3;
        ULONGLONG ProcessorContextCorrupt:1;
        ULONGLONG Uncorrected:1;
        ULONGLONG PreciseIP:1;
        ULONGLONG RestartableIP:1;
        ULONGLONG Overflow:1;

        ULONGLONG Reserved:34;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfCacheCheck;
} WHEA_XPF_CACHE_CHECK, *PWHEA_XPF_CACHE_CHECK;

//
// x86/x64 TLB check structure.
//

#define XPF_TLB_CHECK_TRANSACTIONTYPE_INSTRUCTION     0
#define XPF_TLB_CHECK_TRANSACTIONTYPE_DATAACCESS      1
#define XPF_TLB_CHECK_TRANSACTIONTYPE_GENERIC         2

#define XPF_TLB_CHECK_OPERATION_GENERIC               0
#define XPF_TLB_CHECK_OPERATION_GENREAD               1
#define XPF_TLB_CHECK_OPERATION_GENWRITE              2
#define XPF_TLB_CHECK_OPERATION_DATAREAD              3
#define XPF_TLB_CHECK_OPERATION_DATAWRITE             4
#define XPF_TLB_CHECK_OPERATION_INSTRUCTIONFETCH      5
#define XPF_TLB_CHECK_OPERATION_PREFETCH              6

typedef union _WHEA_XPF_TLB_CHECK {
    struct {
        ULONGLONG TransactionTypeValid:1;
        ULONGLONG OperationValid:1;
        ULONGLONG LevelValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ReservedValid:8;

        ULONGLONG TransactionType:2;
        ULONGLONG Operation:4;
        ULONGLONG Level:3;
        ULONGLONG ProcessorContextCorrupt:1;
        ULONGLONG Uncorrected:1;
        ULONGLONG PreciseIP:1;
        ULONGLONG RestartableIP:1;
        ULONGLONG Overflow:1;
        ULONGLONG Reserved:34;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfTLBCheck;
} WHEA_XPF_TLB_CHECK, *PWHEA_XPF_TLB_CHECK;

//
// x86/x64 bus check structure.
//

#define XPF_BUS_CHECK_TRANSACTIONTYPE_INSTRUCTION     0
#define XPF_BUS_CHECK_TRANSACTIONTYPE_DATAACCESS      1
#define XPF_BUS_CHECK_TRANSACTIONTYPE_GENERIC         2

#define XPF_BUS_CHECK_OPERATION_GENERIC               0
#define XPF_BUS_CHECK_OPERATION_GENREAD               1
#define XPF_BUS_CHECK_OPERATION_GENWRITE              2
#define XPF_BUS_CHECK_OPERATION_DATAREAD              3
#define XPF_BUS_CHECK_OPERATION_DATAWRITE             4
#define XPF_BUS_CHECK_OPERATION_INSTRUCTIONFETCH      5
#define XPF_BUS_CHECK_OPERATION_PREFETCH              6

#define XPF_BUS_CHECK_PARTICIPATION_PROCORIGINATED    0
#define XPF_BUS_CHECK_PARTICIPATION_PROCRESPONDED     1
#define XPF_BUS_CHECK_PARTICIPATION_PROCOBSERVED      2
#define XPF_BUS_CHECK_PARTICIPATION_GENERIC           3

#define XPF_BUS_CHECK_ADDRESS_MEMORY                  0
#define XPF_BUS_CHECK_ADDRESS_RESERVED                1
#define XPF_BUS_CHECK_ADDRESS_IO                      2
#define XPF_BUS_CHECK_ADDRESS_OTHER                   3

typedef union _WHEA_XPF_BUS_CHECK {
    struct {
        ULONGLONG TransactionTypeValid:1;
        ULONGLONG OperationValid:1;
        ULONGLONG LevelValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ParticipationValid:1;
        ULONGLONG TimeoutValid:1;
        ULONGLONG AddressSpaceValid:1;
        ULONGLONG ReservedValid:5;

        ULONGLONG TransactionType:2;
        ULONGLONG Operation:4;
        ULONGLONG Level:3;
        ULONGLONG ProcessorContextCorrupt:1;
        ULONGLONG Uncorrected:1;
        ULONGLONG PreciseIP:1;
        ULONGLONG RestartableIP:1;
        ULONGLONG Overflow:1;
        ULONGLONG Participation:2;
        ULONGLONG Timeout:1;
        ULONGLONG AddressSpace:2;
        ULONGLONG Reserved:29;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfBusCheck;
} WHEA_XPF_BUS_CHECK, *PWHEA_XPF_BUS_CHECK;

//
// x86/x64 micro-architecture specific check structure.
//

#define XPF_MS_CHECK_ERRORTYPE_NOERROR               0
#define XPF_MS_CHECK_ERRORTYPE_UNCLASSIFIED          1
#define XPF_MS_CHECK_ERRORTYPE_MCROMPARITY           2
#define XPF_MS_CHECK_ERRORTYPE_EXTERNAL              3
#define XPF_MS_CHECK_ERRORTYPE_FRC                   4
#define XPF_MS_CHECK_ERRORTYPE_INTERNALUNCLASSIFIED  5

typedef union _WHEA_XPF_MS_CHECK {
    struct {
        ULONGLONG ErrorTypeValid:1;
        ULONGLONG ProcessorContextCorruptValid:1;
        ULONGLONG UncorrectedValid:1;
        ULONGLONG PreciseIPValid:1;
        ULONGLONG RestartableIPValid:1;
        ULONGLONG OverflowValid:1;
        ULONGLONG ReservedValue:10;

        ULONGLONG ErrorType:3;
        ULONGLONG ProcessorContextCorrupt:1;
        ULONGLONG Uncorrected:1;
        ULONGLONG PreciseIP:1;
        ULONGLONG RestartableIP:1;
        ULONGLONG Overflow:1;
        ULONGLONG Reserved:40;
    } DUMMYSTRUCTNAME;
    ULONGLONG XpfMsCheck;
} WHEA_XPF_MS_CHECK, *PWHEA_XPF_MS_CHECK;

//
// x86/x64 Processor Error Information Structure.
//

typedef union _WHEA_XPF_PROCINFO_VALIDBITS {
    struct {
        ULONGLONG CheckInfo:1;
        ULONGLONG TargetId:1;
        ULONGLONG RequesterId:1;
        ULONGLONG ResponderId:1;
        ULONGLONG InstructionPointer:1;
        ULONGLONG Reserved:59;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_XPF_PROCINFO_VALIDBITS, *PWHEA_XPF_PROCINFO_VALIDBITS;

typedef struct _WHEA_XPF_PROCINFO {
    GUID CheckInfoId;
    WHEA_XPF_PROCINFO_VALIDBITS ValidBits;
    union {
        WHEA_XPF_CACHE_CHECK CacheCheck;
        WHEA_XPF_TLB_CHECK TlbCheck;
        WHEA_XPF_BUS_CHECK BusCheck;
        WHEA_XPF_MS_CHECK MsCheck;
        ULONGLONG AsULONGLONG;
    } CheckInfo;
    ULONGLONG TargetId;
    ULONGLONG RequesterId;
    ULONGLONG ResponderId;
    ULONGLONG InstructionPointer;
} WHEA_XPF_PROCINFO, *PWHEA_XPF_PROCINFO;

//
// x86/x64 Processor Context Information Structure.
//

typedef struct _WHEA_X86_REGISTER_STATE {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
    ULONG Esp;
    USHORT Cs;
    USHORT Ds;
    USHORT Ss;
    USHORT Es;
    USHORT Fs;
    USHORT Gs;
    ULONG Eflags;
    ULONG Eip;
    ULONG Cr0;
    ULONG Cr1;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONGLONG Gdtr;
    ULONGLONG Idtr;
    USHORT Ldtr;
    USHORT Tr;
} WHEA_X86_REGISTER_STATE, *PWHEA_X86_REGISTER_STATE;

typedef struct DECLSPEC_ALIGN(16) _WHEA128A {
    ULONGLONG Low;
    LONGLONG High;
} WHEA128A, *PWHEA128A;

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4324) // structure padded due to __declspec(align())
#endif
#endif

typedef struct _WHEA_X64_REGISTER_STATE {
    ULONGLONG Rax;
    ULONGLONG Rbx;
    ULONGLONG Rcx;
    ULONGLONG Rdx;
    ULONGLONG Rsi;
    ULONGLONG Rdi;
    ULONGLONG Rbp;
    ULONGLONG Rsp;
    ULONGLONG R8;
    ULONGLONG R9;
    ULONGLONG R10;
    ULONGLONG R11;
    ULONGLONG R12;
    ULONGLONG R13;
    ULONGLONG R14;
    ULONGLONG R15;
    USHORT Cs;
    USHORT Ds;
    USHORT Ss;
    USHORT Es;
    USHORT Fs;
    USHORT Gs;
    ULONG Reserved;
    ULONGLONG Rflags;
    ULONGLONG Eip;
    ULONGLONG Cr0;
    ULONGLONG Cr1;
    ULONGLONG Cr2;
    ULONGLONG Cr3;
    ULONGLONG Cr4;
    ULONGLONG Cr8;
    WHEA128A Gdtr;
    WHEA128A Idtr;
    USHORT Ldtr;
    USHORT Tr;
} WHEA_X64_REGISTER_STATE, *PWHEA_X64_REGISTER_STATE;

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(pop)
#endif
#endif

#define XPF_CONTEXT_INFO_UNCLASSIFIEDDATA       0
#define XPF_CONTEXT_INFO_MSRREGISTERS           1
#define XPF_CONTEXT_INFO_32BITCONTEXT           2
#define XPF_CONTEXT_INFO_64BITCONTEXT           3
#define XPF_CONTEXT_INFO_FXSAVE                 4
#define XPF_CONTEXT_INFO_32BITDEBUGREGS         5
#define XPF_CONTEXT_INFO_64BITDEBUGREGS         6
#define XPF_CONTEXT_INFO_MMREGISTERS            7

typedef struct _WHEA_XPF_CONTEXT_INFO {
    USHORT RegisterContextType;
    USHORT RegisterDataSize;
    ULONG MSRAddress;
    ULONGLONG MmRegisterAddress;

    //
    // UCHAR RegisterData[ANYSIZE_ARRAY];
    //

} WHEA_XPF_CONTEXT_INFO, *PWHEA_XPF_CONTEXT_INFO;

//
// x86/x64 Processor Error Section
//

typedef union _WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS {
    struct {
        ULONGLONG LocalAPICId:1;
        ULONGLONG CpuId:1;
        ULONGLONG ProcInfoCount:6;
        ULONGLONG ContextInfoCount:6;
        ULONGLONG Reserved:50;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS,
  *PWHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS;

typedef struct _WHEA_XPF_PROCESSOR_ERROR_SECTION {
    WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS ValidBits;
    ULONGLONG LocalAPICId;
    UCHAR CpuId[48];

    //
    // WHEA_XPF_PROCINFO ProcInfo[ANYSIZE_ARRAY];
    // WHEA_XPF_CONTEXT_INFO ContextInfo[ANYSIZE_ARRAY];
    //

    UCHAR VariableInfo[ANYSIZE_ARRAY];
} WHEA_XPF_PROCESSOR_ERROR_SECTION, *PWHEA_XPF_PROCESSOR_ERROR_SECTION;

//
// Define alternate type names for downlevel source compatibility.
//

#if WHEA_DOWNLEVEL_TYPE_NAMES

typedef struct WHEA_XPF_PROCESSOR_ERROR_SECTION_VALIDBITS
    WHEA_XPF_PROCESSOR_ERROR_VALIDBITS, *PWHEA_XPF_PROCESSOR_ERROR_VALIDBITS;

typedef struct WHEA_XPF_PROCESSOR_ERROR_SECTION
    WHEA_XPF_PROCESSOR_ERROR, *PWHEA_XPF_PROCESSOR_ERROR;

#endif

//
// Validate the x86/x64 processor error section structures against the
// definitions in the UEFI  specification.
//

CPER_FIELD_CHECK(WHEA_XPF_PROCINFO, CheckInfoId,         0, 16);
CPER_FIELD_CHECK(WHEA_XPF_PROCINFO, ValidBits,          16,  8);
CPER_FIELD_CHECK(WHEA_XPF_PROCINFO, CheckInfo,          24,  8);
CPER_FIELD_CHECK(WHEA_XPF_PROCINFO, TargetId,           32,  8);
CPER_FIELD_CHECK(WHEA_XPF_PROCINFO, RequesterId,        40,  8);
CPER_FIELD_CHECK(WHEA_XPF_PROCINFO, ResponderId,        48,  8);
CPER_FIELD_CHECK(WHEA_XPF_PROCINFO, InstructionPointer, 56,  8);

CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Eax,       0,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Ebx,       4,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Ecx,       8,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Edx,      12,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Esi,      16,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Edi,      20,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Ebp,      24,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Esp,      28,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Cs,       32,   2);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Ds,       34,   2);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Ss,       36,   2);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Es,       38,   2);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Fs,       40,   2);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Gs,       42,   2);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Eflags,   44,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Eip,      48,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Cr0,      52,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Cr1,      56,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Cr2,      60,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Cr3,      64,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Cr4,      68,   4);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Gdtr,     72,   8);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Idtr,     80,   8);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Ldtr,     88,   2);
CPER_FIELD_CHECK(WHEA_X86_REGISTER_STATE, Tr,       90,   2);

CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rax,       0,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rbx,       8,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rcx,      16,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rdx,      24,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rsi,      32,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rdi,      40,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rbp,      48,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rsp,      56,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R8,       64,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R9,       72,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R10,      80,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R11,      88,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R12,      96,   8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R13,      104,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R14,      112,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, R15,      120,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Cs,       128,  2);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Ds,       130,  2);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Ss,       132,  2);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Es,       134,  2);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Fs,       136,  2);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Gs,       138,  2);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Reserved, 140,  4);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Rflags,   144,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Eip,      152,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Cr0,      160,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Cr1,      168,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Cr2,      176,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Cr3,      184,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Cr4,      192,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Cr8,      200,  8);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Gdtr,     208, 16);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Idtr,     224, 16);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Ldtr,     240,  2);
CPER_FIELD_CHECK(WHEA_X64_REGISTER_STATE, Tr,       242,  2);

CPER_FIELD_CHECK(WHEA_XPF_CONTEXT_INFO, RegisterContextType,  0, 2);
CPER_FIELD_CHECK(WHEA_XPF_CONTEXT_INFO, RegisterDataSize,     2, 2);
CPER_FIELD_CHECK(WHEA_XPF_CONTEXT_INFO, MSRAddress,           4, 4);
CPER_FIELD_CHECK(WHEA_XPF_CONTEXT_INFO, MmRegisterAddress,    8, 8);

CPER_FIELD_CHECK(WHEA_XPF_PROCESSOR_ERROR_SECTION, ValidBits,     0,  8);
CPER_FIELD_CHECK(WHEA_XPF_PROCESSOR_ERROR_SECTION, LocalAPICId,   8,  8);
CPER_FIELD_CHECK(WHEA_XPF_PROCESSOR_ERROR_SECTION, CpuId,        16, 48);
CPER_FIELD_CHECK(WHEA_XPF_PROCESSOR_ERROR_SECTION, VariableInfo, 64, ANYSIZE_ARRAY);

//--------------------------------------------------- WHEA_MEMORY_ERROR_SECTION

typedef union _WHEA_MEMORY_ERROR_SECTION_VALIDBITS {
    struct {
        ULONGLONG ErrorStatus:1;
        ULONGLONG PhysicalAddress:1;
        ULONGLONG PhysicalAddressMask:1;
        ULONGLONG Node:1;
        ULONGLONG Card:1;
        ULONGLONG Module:1;
        ULONGLONG Bank:1;
        ULONGLONG Device:1;
        ULONGLONG Row:1;
        ULONGLONG Column:1;
        ULONGLONG BitPosition:1;
        ULONGLONG RequesterId:1;
        ULONGLONG ResponderId:1;
        ULONGLONG TargetId:1;
        ULONGLONG ErrorType:1;
        ULONGLONG Reserved:49;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_MEMORY_ERROR_SECTION_VALIDBITS,
  *PWHEA_MEMORY_ERROR_SECTION_VALIDBITS;

#define WHEA_MEMERRTYPE_UNKNOWN                 0x00
#define WHEA_MEMERRTYPE_NOERROR                 0x01
#define WHEA_MEMERRTYPE_SINGLEBITECC            0x02
#define WHEA_MEMERRTYPE_MULTIBITECC             0x03
#define WHEA_MEMERRTYPE_SINGLESYMCHIPKILL       0x04
#define WHEA_MEMERRTYPE_MULTISYMCHIPKILL        0x05
#define WHEA_MEMERRTYPE_MASTERABORT             0x06
#define WHEA_MEMERRTYPE_TARGETABORT             0x07
#define WHEA_MEMERRTYPE_PARITYERROR             0x08
#define WHEA_MEMERRTYPE_WATCHDOGTIMEOUT         0x09
#define WHEA_MEMERRTYPE_INVALIDADDRESS          0x0A
#define WHEA_MEMERRTYPE_MIRRORBROKEN            0x0B
#define WHEA_MEMERRTYPE_MEMORYSPARING           0x0C

typedef struct _WHEA_MEMORY_ERROR_SECTION {
    WHEA_MEMORY_ERROR_SECTION_VALIDBITS ValidBits;
    WHEA_ERROR_STATUS ErrorStatus;
    ULONGLONG PhysicalAddress;
    ULONGLONG PhysicalAddressMask;
    USHORT Node;
    USHORT Card;
    USHORT Module;
    USHORT Bank;
    USHORT Device;
    USHORT Row;
    USHORT Column;
    USHORT BitPosition;
    ULONGLONG RequesterId;
    ULONGLONG ResponderId;
    ULONGLONG TargetId;
    UCHAR ErrorType;
} WHEA_MEMORY_ERROR_SECTION, *PWHEA_MEMORY_ERROR_SECTION;

//
// Define alternate names allowing for downlevel source compatibility.
//

#if WHEA_DOWNLEVEL_TYPE_NAMES

typedef WHEA_MEMORY_ERROR_SECTION_VALIDBITS
    WHEA_MEMORY_ERROR_VALIDBITS, *PWHEA_MEMORY_ERROR_VALIDBITS;

typedef WHEA_MEMORY_ERROR_SECTION
    WHEA_MEMORY_ERROR, *PWHEA_MEMORY_ERROR;

#endif

//
// Validate the memory error section structures against the definitions in the
// UEFI  specification.
//

CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, ValidBits,            0, 8);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, ErrorStatus,          8, 8);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, PhysicalAddress,     16, 8);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, PhysicalAddressMask, 24, 8);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, Node,                32, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, Card,                34, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, Module,              36, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, Bank,                38, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, Device,              40, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, Row,                 42, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, Column,              44, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, BitPosition,         46, 2);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, RequesterId,         48, 8);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, ResponderId,         56, 8);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, TargetId,            64, 8);
CPER_FIELD_CHECK(WHEA_MEMORY_ERROR_SECTION, ErrorType,           72, 1);

//----------------------------------------------- WHEA_PCIEXPRESS_ERROR_SECTION

typedef union _WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS {
    struct {
        ULONGLONG PortType:1;
        ULONGLONG Version:1;
        ULONGLONG CommandStatus:1;
        ULONGLONG DeviceId:1;
        ULONGLONG DeviceSerialNumber:1;
        ULONGLONG BridgeControlStatus:1;
        ULONGLONG ExpressCapability:1;
        ULONGLONG AerInfo:1;
        ULONGLONG Reserved:56;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS,
  *PWHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS;

typedef struct _WHEA_PCIEXPRESS_DEVICE_ID {
    USHORT VendorID;
    USHORT DeviceID;
    ULONG ClassCode:24;
    ULONG FunctionNumber:8;
    ULONG DeviceNumber:8;
    ULONG Segment:16;
    ULONG PrimaryBusNumber:8;
    ULONG SecondaryBusNumber:8;
    ULONG Reserved1:3;
    ULONG SlotNumber:13;
    ULONG Reserved2:8;
} WHEA_PCIEXPRESS_DEVICE_ID, *PWHEA_PCIEXPRESS_DEVICE_ID;

typedef union _WHEA_PCIEXPRESS_VERSION {
    struct {
        UCHAR MinorVersion;
        UCHAR MajorVersion;
        USHORT Reserved;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_PCIEXPRESS_VERSION, *PWHEA_PCIEXPRESS_VERSION;

typedef union _WHEA_PCIEXPRESS_COMMAND_STATUS {
    struct {
        USHORT Command;
        USHORT Status;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_PCIEXPRESS_COMMAND_STATUS, *PWHEA_PCIEXPRESS_COMMAND_STATUS;

typedef union _WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS {
    struct {
        USHORT BridgeSecondaryStatus;
        USHORT BridgeControl;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS,
    *PWHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS;

typedef enum _WHEA_PCIEXPRESS_DEVICE_TYPE {
    WheaPciExpressEndpoint = 0,
    WheaPciExpressLegacyEndpoint,
    WheaPciExpressRootPort = 4,
    WheaPciExpressUpstreamSwitchPort,
    WheaPciExpressDownstreamSwitchPort,
    WheaPciExpressToPciXBridge,
    WheaPciXToExpressBridge,
    WheaPciExpressRootComplexIntegratedEndpoint,
    WheaPciExpressRootComplexEventCollector
} WHEA_PCIEXPRESS_DEVICE_TYPE;

typedef struct _WHEA_PCIEXPRESS_ERROR_SECTION {
    WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS ValidBits;
    WHEA_PCIEXPRESS_DEVICE_TYPE PortType;
    WHEA_PCIEXPRESS_VERSION Version;
    WHEA_PCIEXPRESS_COMMAND_STATUS CommandStatus;
    ULONG Reserved;
    WHEA_PCIEXPRESS_DEVICE_ID DeviceId;
    ULONGLONG DeviceSerialNumber;
    WHEA_PCIEXPRESS_BRIDGE_CONTROL_STATUS BridgeControlStatus;
    UCHAR ExpressCapability[60];
    UCHAR AerInfo[96];
} WHEA_PCIEXPRESS_ERROR_SECTION, *PWHEA_PCIEXPRESS_ERROR_SECTION;

#if WHEA_DOWNLEVEL_TYPE_NAMES

typedef WHEA_PCIEXPRESS_ERROR_SECTION_VALIDBITS
    WHEA_PCIEXPRESS_ERROR_VALIDBITS,
    *PWHEA_PCIEXPRESS_ERROR_VALIDBITS;

typedef WHEA_PCIEXPRESS_ERROR_SECTION
    WHEA_PCIEXPRESS_ERROR, *PWHEA_PCIEXPRESS_ERROR;

#endif

//
// Validate the PCI Express error section structures against the definitions
// in the UEFI  specification.
//

CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, ValidBits,             0,  8);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, PortType,              8,  4);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, Version,              12,  4);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, CommandStatus,        16,  4);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, Reserved,             20,  4);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, DeviceId,             24, 16);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, DeviceSerialNumber,   40,  8);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, BridgeControlStatus,  48,  4);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, ExpressCapability,    52, 60);
CPER_FIELD_CHECK(WHEA_PCIEXPRESS_ERROR_SECTION, AerInfo,             112, 96);

//-------------------------------------------------- WHEA_PCIXBUS_ERROR_SECTION

#define PCIXBUS_ERRTYPE_UNKNOWN             0x0000
#define PCIXBUS_ERRTYPE_DATAPARITY          0x0001
#define PCIXBUS_ERRTYPE_SYSTEM              0x0002
#define PCIXBUS_ERRTYPE_MASTERABORT         0x0003
#define PCIXBUS_ERRTYPE_BUSTIMEOUT          0x0004
#define PCIXBUS_ERRTYPE_MASTERDATAPARITY    0x0005
#define PCIXBUS_ERRTYPE_ADDRESSPARITY       0x0006
#define PCIXBUS_ERRTYPE_COMMANDPARITY       0x0007

typedef union _WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS {
    struct {
        ULONGLONG ErrorStatus:1;
        ULONGLONG ErrorType:1;
        ULONGLONG BusId:1;
        ULONGLONG BusAddress:1;
        ULONGLONG BusData:1;
        ULONGLONG BusCommand:1;
        ULONGLONG RequesterId:1;
        ULONGLONG CompleterId:1;
        ULONGLONG TargetId:1;
        ULONGLONG Reserved:55;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS, *PWHEA_PCIXBUS_ERROR_SECTION_VALIDBITS;

typedef union _WHEA_PCIXBUS_ID {
    struct {
        UCHAR BusNumber;
        UCHAR BusSegment;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} WHEA_PCIXBUS_ID, *PWHEA_PCIXBUS_ID;

typedef union _WHEA_PCIXBUS_COMMAND {
    struct {
        ULONGLONG Command:56;
        ULONGLONG PCIXCommand:1;
        ULONGLONG Reserved:7;
    } DUMMYSTRUCTNAME;
    ULONGLONG AsULONGLONG;
} WHEA_PCIXBUS_COMMAND, *PWHEA_PCIXBUS_COMMAND;

typedef struct _WHEA_PCIXBUS_ERROR_SECTION {
    WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS ValidBits;
    WHEA_ERROR_STATUS ErrorStatus;
    USHORT ErrorType;
    WHEA_PCIXBUS_ID BusId;
    ULONG Reserved;
    ULONGLONG BusAddress;
    ULONGLONG BusData;
    WHEA_PCIXBUS_COMMAND BusCommand;
    ULONGLONG RequesterId;
    ULONGLONG CompleterId;
    ULONGLONG TargetId;
} WHEA_PCIXBUS_ERROR_SECTION, *PWHEA_PCIXBUS_ERROR_SECTION;

#if WHEA_DOWNLEVEL_TYPE_NAMES

typedef WHEA_PCIXBUS_ERROR_SECTION_VALIDBITS
    WHEA_PCIXBUS_ERROR_VALIDBITS,
    *PWHEA_PCIXBUS_ERROR_VALIDBITS;

typedef WHEA_PCIXBUS_ERROR_SECTION
    WHEA_PCIXBUS_ERROR, *PWHEA_PCIXBUS_ERROR;

#endif

CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, ValidBits,    0, 8);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, ErrorStatus,  8, 8);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, ErrorType,   16, 2);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, BusId,       18, 2);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, Reserved,    20, 4);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, BusAddress,  24, 8);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, BusData,     32, 8);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, BusCommand,  40, 8);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, RequesterId, 48, 8);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, CompleterId, 56, 8);
CPER_FIELD_CHECK(WHEA_PCIXBUS_ERROR_SECTION, TargetId,    64, 8);

//----------------------------------------------- WHEA_PCIXDEVICE_ERROR_SECTION

typedef union _WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS {
    struct {
        ULONGLONG ErrorStatus:1;
        ULONGLONG IdInfo:1;
        ULONGLONG MemoryNumber:1;
        ULONGLONG IoNumber:1;
        ULONGLONG RegisterDataPairs:1;
        ULONGLONG Reserved:59;
    } DUMMYSTRUCTNAME;
    ULONGLONG ValidBits;
} WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS,
  *PWHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS;

typedef struct _WHEA_PCIXDEVICE_ID {
    USHORT VendorId;
    USHORT DeviceId;
    ULONG ClassCode:24;
    ULONG FunctionNumber:8;
    ULONG DeviceNumber:8;
    ULONG BusNumber:8;
    ULONG SegmentNumber:8;
    ULONG Reserved1:8;
    ULONG Reserved2;
} WHEA_PCIXDEVICE_ID, *PWHEA_PCIXDEVICE_ID;

typedef struct WHEA_PCIXDEVICE_REGISTER_PAIR {
    ULONGLONG Register;
    ULONGLONG Data;
} WHEA_PCIXDEVICE_REGISTER_PAIR, *PWHEA_PCIXDEVICE_REGISTER_PAIR;

typedef struct _WHEA_PCIXDEVICE_ERROR_SECTION {
    WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS ValidBits;
    WHEA_ERROR_STATUS ErrorStatus;
    WHEA_PCIXDEVICE_ID IdInfo;
    ULONG MemoryNumber;
    ULONG IoNumber;
    WHEA_PCIXDEVICE_REGISTER_PAIR RegisterDataPairs[ANYSIZE_ARRAY];
} WHEA_PCIXDEVICE_ERROR_SECTION, *PWHEA_PCIXDEVICE_ERROR_SECTION;

#if WHEA_DOWNLEVEL_TYPE_NAMES

typedef WHEA_PCIXDEVICE_ERROR_SECTION_VALIDBITS
    WHEA_PCIXDEVICE_ERROR_VALIDBITS, *PWHEA_PCIXDEVICE_ERROR_VALIDBITS;

typedef WHEA_PCIXDEVICE_ERROR_SECTION
    WHEA_PCIXDEVICE_ERROR, *PWHEA_PCIXDEVICE_ERROR;

#endif

CPER_FIELD_CHECK(WHEA_PCIXDEVICE_ERROR_SECTION, ValidBits,          0,  8);
CPER_FIELD_CHECK(WHEA_PCIXDEVICE_ERROR_SECTION, ErrorStatus,        8,  8);
CPER_FIELD_CHECK(WHEA_PCIXDEVICE_ERROR_SECTION, IdInfo,            16, 16);
CPER_FIELD_CHECK(WHEA_PCIXDEVICE_ERROR_SECTION, MemoryNumber,      32,  4);
CPER_FIELD_CHECK(WHEA_PCIXDEVICE_ERROR_SECTION, IoNumber,          36,  4);
CPER_FIELD_CHECK(WHEA_PCIXDEVICE_ERROR_SECTION, RegisterDataPairs, 40, 16);

//---------------------------------------- WHEA_FIRMWARE_ERROR_RECORD_REFERENCE

#define WHEA_FIRMWARE_RECORD_TYPE_IPFSAL 0

typedef struct _WHEA_FIRMWARE_ERROR_RECORD_REFERENCE {
    UCHAR Type;
    UCHAR Reserved[7];
    ULONGLONG FirmwareRecordId;
} WHEA_FIRMWARE_ERROR_RECORD_REFERENCE, *PWHEA_FIRMWARE_ERROR_RECORD_REFERENCE;

#if WHEA_DOWNLEVEL_TYPE_NAMES

typedef WHEA_FIRMWARE_ERROR_RECORD_REFERENCE
    WHEA_FIRMWARE_RECORD, *PWHEA_FIRMWARE_RECORD;

#endif

CPER_FIELD_CHECK(WHEA_FIRMWARE_ERROR_RECORD_REFERENCE, Type,             0,  1);
CPER_FIELD_CHECK(WHEA_FIRMWARE_ERROR_RECORD_REFERENCE, Reserved,         1,  7);
CPER_FIELD_CHECK(WHEA_FIRMWARE_ERROR_RECORD_REFERENCE, FirmwareRecordId, 8,  8);

//
// This is the start of the Microsoft specific extensions to the Common Platform
// Error Record specification. This is in accordance with Appendix N, section
// 2.3 of the Unified Extensible Firware Interface specification, which allows
// the specification of non-standard section bodies.
//

//------------------------------------------------------------- XPF_MCA_SECTION

typedef union _MCG_STATUS {
    struct {
        ULONG RestartIpValid:1;
        ULONG ErrorIpValid:1;
        ULONG MachineCheckInProgress:1;
        ULONG Reserved1:29;
        ULONG Reserved2;
    } DUMMYSTRUCTNAME;
    ULONGLONG QuadPart;
} MCG_STATUS, *PMCG_STATUS;

typedef union _MCI_STATUS {
    struct {
        USHORT McaErrorCode;
        USHORT ModelErrorCode;
        ULONG OtherInformation : 23;
        ULONG ActionRequired : 1;
        ULONG Signalling : 1;
        ULONG ContextCorrupt : 1;
        ULONG AddressValid : 1;
        ULONG MiscValid : 1;
        ULONG ErrorEnabled : 1;
        ULONG UncorrectedError : 1;
        ULONG StatusOverFlow : 1;
        ULONG Valid : 1;
    } DUMMYSTRUCTNAME;
    ULONG64 QuadPart;
} MCI_STATUS, *PMCI_STATUS;

typedef enum _WHEA_CPU_VENDOR {
    WheaCpuVendorOther = 0,
    WheaCpuVendorIntel,
    WheaCpuVendorAmd
} WHEA_CPU_VENDOR, *PWHEA_CPU_VENDOR;

#define WHEA_XPF_MCA_EXTREG_MAX_COUNT            24
#define WHEA_XPF_MCA_SECTION_VERSION             1

typedef struct _WHEA_XPF_MCA_SECTION {
    ULONG               VersionNumber;
    WHEA_CPU_VENDOR     CpuVendor;
    LARGE_INTEGER       Timestamp;
    ULONG               ProcessorNumber;
    MCG_STATUS          GlobalStatus;
    ULONGLONG           InstructionPointer;
    ULONG               BankNumber;
    MCI_STATUS          Status;
    ULONGLONG           Address;
    ULONGLONG           Misc;
    ULONG               ExtendedRegisterCount;
    ULONG               Reserved2;
    ULONGLONG           ExtendedRegisters[WHEA_XPF_MCA_EXTREG_MAX_COUNT];
} WHEA_XPF_MCA_SECTION, *PWHEA_XPF_MCA_SECTION;

//------------------------------------------------------ WHEA_NMI_ERROR_SECTION

typedef union _WHEA_NMI_ERROR_SECTION_FLAGS {
    struct {
        ULONG HypervisorError:1;
        ULONG Reserved:31;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_NMI_ERROR_SECTION_FLAGS, *PWHEA_NMI_ERROR_SECTION_FLAGS;

typedef struct _WHEA_NMI_ERROR_SECTION {
    UCHAR Data[8];
    WHEA_NMI_ERROR_SECTION_FLAGS Flags;
} WHEA_NMI_ERROR_SECTION, *PWHEA_NMI_ERROR_SECTION;

#include <poppack.h>


//-------------------------------------- Standard Error Notification Type GUIDs

/* 2dce8bb1-bdd7-450e-b9ad-9cf4ebd4f890 */
DEFINE_GUID(CMC_NOTIFY_TYPE_GUID,
            0x2dce8bb1, 0xbdd7, 0x450e, 0xb9, 0xad,
            0x9c, 0xf4, 0xeb, 0xd4, 0xf8, 0x90);

/* 4e292f96-d843-4a55-a8c2-d481f27ebeee */
DEFINE_GUID(CPE_NOTIFY_TYPE_GUID,
            0x4e292f96, 0xd843, 0x4a55, 0xa8, 0xc2,
            0xd4, 0x81, 0xf2, 0x7e, 0xbe, 0xee);

/* e8f56ffe-919c-4cc5-ba88-65abe14913bb */
DEFINE_GUID(MCE_NOTIFY_TYPE_GUID,
            0xe8f56ffe, 0x919c, 0x4cc5, 0xba, 0x88,
            0x65, 0xab, 0xe1, 0x49, 0x13, 0xbb);

/* cf93c01f-1a16-4dfc-b8bc-9c4daf67c104 */
DEFINE_GUID(PCIe_NOTIFY_TYPE_GUID,
            0xcf93c01f, 0x1a16, 0x4dfc, 0xb8, 0xbc,
            0x9c, 0x4d, 0xaf, 0x67, 0xc1, 0x04);

/* cc5263e8-9308-454a-89d0-340bd39bc98e */
DEFINE_GUID(INIT_NOTIFY_TYPE_GUID,
            0xcc5263e8, 0x9308, 0x454a, 0x89, 0xd0,
            0x34, 0x0b, 0xd3, 0x9b, 0xc9, 0x8e);

/* 5bad89ff-b7e6-42c9-814a-cf2485d6e98a */
DEFINE_GUID(NMI_NOTIFY_TYPE_GUID,
            0x5bad89ff, 0xb7e6, 0x42c9, 0x81, 0x4a,
            0xcf, 0x24, 0x85, 0xd6, 0xe9, 0x8a);

/* 3d61a466-ab40-409a-a698-f362d464b38f */
DEFINE_GUID(BOOT_NOTIFY_TYPE_GUID,
            0x3d61a466, 0xab40, 0x409a, 0xa6, 0x98,
            0xf3, 0x62, 0xd4, 0x64, 0xb3, 0x8f);

//------------------------------------------- Standard Error Section type GUIDs

/* 9876ccad-47b4-4bdb-b65e-16f193c4f3db */
DEFINE_GUID(PROCESSOR_GENERIC_ERROR_SECTION_GUID,
            0x9876ccad, 0x47b4, 0x4bdb, 0xb6, 0x5e,
            0x16, 0xf1, 0x93, 0xc4, 0xf3, 0xdb);

/* dc3ea0b0-a144-4797-b95b-53fa242b6e1d */
DEFINE_GUID(XPF_PROCESSOR_ERROR_SECTION_GUID,
            0xdc3ea0b0, 0xa144, 0x4797, 0xb9, 0x5b,
            0x53, 0xfa, 0x24, 0x2b, 0x6e, 0x1d);

/* e429faf1-3cb7-11d4-bca7-0080c73c8881 */
DEFINE_GUID(IPF_PROCESSOR_ERROR_SECTION_GUID,
            0xe429faf1, 0x3cb7, 0x11d4, 0xbc, 0xa7,
            0x00, 0x80, 0xc7, 0x3c, 0x88, 0x81);

/* a5bc1114-6f64-4ede-b863-3e83ed7c83b1 */
DEFINE_GUID(MEMORY_ERROR_SECTION_GUID,
            0xa5bc1114, 0x6f64, 0x4ede, 0xb8, 0x63,
            0x3e, 0x83, 0xed, 0x7c, 0x83, 0xb1);

/* d995e954-bbc1-430f-ad91-b44dcb3c6f35 */
DEFINE_GUID(PCIEXPRESS_ERROR_SECTION_GUID,
            0xd995e954, 0xbbc1, 0x430f, 0xad, 0x91,
            0xb4, 0x4d, 0xcb, 0x3c, 0x6f, 0x35);

/* c5753963-3b84-4095-bf78-eddad3f9c9dd */
DEFINE_GUID(PCIXBUS_ERROR_SECTION_GUID,
            0xc5753963, 0x3b84, 0x4095, 0xbf, 0x78,
            0xed, 0xda, 0xd3, 0xf9, 0xc9, 0xdd);

/* eb5e4685-ca66-4769-b6a2-26068b001326 */
DEFINE_GUID(PCIXDEVICE_ERROR_SECTION_GUID,
            0xeb5e4685, 0xca66, 0x4769, 0xb6, 0xa2,
            0x26, 0x06, 0x8b, 0x00, 0x13, 0x26);

/* 81212a96-09ed-4996-9471-8d729c8e69ed */
DEFINE_GUID(FIRMWARE_ERROR_RECORD_REFERENCE_GUID,
            0x81212a96, 0x09ed, 0x4996, 0x94, 0x71,
            0x8d, 0x72, 0x9c, 0x8e, 0x69, 0xed);

//-------------------------------------- Processor check information type GUIDs

/* a55701f5-e3ef-43de-ac72-249b573fad2c */
DEFINE_GUID(WHEA_CACHECHECK_GUID,
            0xa55701f5, 0xe3ef, 0x43de, 0xac, 0x72,
            0x24, 0x9b, 0x57, 0x3f, 0xad, 0x2c);

/* fc06b535-5e1f-4562-9f25-0a3b9adb63c3 */
DEFINE_GUID(WHEA_TLBCHECK_GUID,
            0xfc06b535, 0x5e1f, 0x4562, 0x9f, 0x25,
            0x0a, 0x3b, 0x9a, 0xdb, 0x63, 0xc3);

/* 1cf3f8b3-c5b1-49a2-aa59-5eef92ffa63c */
DEFINE_GUID(WHEA_BUSCHECK_GUID,
            0x1cf3f8b3, 0xc5b1, 0x49a2, 0xaa, 0x59,
            0x5e, 0xef, 0x92, 0xff, 0xa6, 0x3c);

/* 48ab7f57-dc34-4f6c-a7d3-b0b5b0a74314 */
DEFINE_GUID(WHEA_MSCHECK_GUID,
            0x48ab7f57, 0xdc34, 0x4f6c, 0xa7, 0xd3,
            0xb0, 0xb5, 0xb0, 0xa7, 0x43, 0x14);

//
// This is the start of the Microsoft specific extensions to the Common Platform
// Error Record specification. This is in accordance with Appendix N, section
// 2.3 of the Unified Extensible Firware Interface specification, which allows
// the specification of non-standard section bodies.
//

//---------------------------------------------------- Microsoft record creator

/* cf07c4bd-b789-4e18-b3c4-1f732cb57131 */
DEFINE_GUID(WHEA_RECORD_CREATOR_GUID,
            0xcf07c4bd,
            0xb789, 0x4e18,
            0xb3, 0xc4, 0x1f, 0x73, 0x2c, 0xb5, 0x71, 0x31);

//--------------------------------------- Microsoft specific notification types

/* 3e62a467-ab40-409a-a698-f362d464b38f */
DEFINE_GUID(GENERIC_NOTIFY_TYPE_GUID,
            0x3e62a467,
            0xab40, 0x409a,
            0xa6, 0x98, 0xf3, 0x62, 0xd4, 0x64, 0xb3, 0x8f);

//-------------------------------------- Microsoft specific error section types

/* 6f3380d1-6eb0-497f-a578-4d4c65a71617 */
DEFINE_GUID(IPF_SAL_RECORD_SECTION_GUID,
            0x6f3380d1,
            0x6eb0, 0x497f,
            0xa5, 0x78, 0x4d, 0x4c, 0x65, 0xa7, 0x16, 0x17);

/* 8a1e1d01-42f9-4557-9c33-565e5cc3f7e8 */
DEFINE_GUID(XPF_MCA_SECTION_GUID,
            0x8a1e1d01,
            0x42f9, 0x4557,
            0x9c, 0x33, 0x56, 0x5e, 0x5c, 0xc3, 0xf7, 0xe8);

/* e71254e7-c1b9-4940-ab76-909703a4320f */
DEFINE_GUID(NMI_SECTION_GUID,
            0xe71254e7,
            0xc1b9, 0x4940,
            0xab, 0x76, 0x90, 0x97, 0x03, 0xa4, 0x32, 0x0f);

/* e71254e8-c1b9-4940-ab76-909703a4320f */
DEFINE_GUID(GENERIC_SECTION_GUID,
            0xe71254e8,
            0xc1b9, 0x4940,
            0xab, 0x76, 0x90, 0x97, 0x03, 0xa4, 0x32, 0x0f);

/* e71254e9-c1b9-4940-ab76-909703a4320f */
DEFINE_GUID(WHEA_ERROR_PACKET_SECTION_GUID,
            0xe71254e9,
            0xc1b9, 0x4940,
            0xab, 0x76, 0x90, 0x97, 0x03, 0xa4, 0x32, 0x0f);


#if defined(_NTPSHEDDLL_)

#define NTPSHEDAPI

#else

#define NTPSHEDAPI DECLSPEC_IMPORT

#endif

#include <pshpack1.h>

//----------------------------------------------------------- WHEA_ERROR_PACKET

typedef enum _WHEA_ERROR_TYPE {
    WheaErrTypeProcessor = 0,
    WheaErrTypeMemory,
    WheaErrTypePCIExpress,
    WheaErrTypeNMI,
    WheaErrTypePCIXBus,
    WheaErrTypePCIXDevice,
    WheaErrTypeGeneric
} WHEA_ERROR_TYPE, *PWHEA_ERROR_TYPE;

typedef union _WHEA_ERROR_PACKET_FLAGS {
    struct {
        ULONG PreviousError:1;
        ULONG Reserved1:1;
        ULONG HypervisorError:1;
        ULONG Simulated:1;
        ULONG PlatformPfaControl:1;
        ULONG PlatformDirectedOffline:1;
        ULONG Reserved2:26;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_PACKET_FLAGS, *PWHEA_ERROR_PACKET_FLAGS;

typedef enum _WHEA_ERROR_PACKET_DATA_FORMAT {
    WheaDataFormatIPFSalRecord = 0,
    WheaDataFormatXPFMCA,
    WheaDataFormatMemory,
    WheaDataFormatPCIExpress,
    WheaDataFormatNMIPort,
    WheaDataFormatPCIXBus,
    WheaDataFormatPCIXDevice,
    WheaDataFormatGeneric,
    WheaDataFormatMax
} WHEA_ERROR_PACKET_DATA_FORMAT, *PWHEA_ERROR_PACKET_DATA_FORMAT;

typedef enum _WHEA_RAW_DATA_FORMAT {
    WheaRawDataFormatIPFSalRecord = 0x00,
    WheaRawDataFormatIA32MCA,
    WheaRawDataFormatIntel64MCA,
    WheaRawDataFormatAMD64MCA,
    WheaRawDataFormatMemory,
    WheaRawDataFormatPCIExpress,
    WheaRawDataFormatNMIPort,
    WheaRawDataFormatPCIXBus,
    WheaRawDataFormatPCIXDevice,
    WheaRawDataFormatGeneric,
    WheaRawDataFormatMax
} WHEA_RAW_DATA_FORMAT, *PWHEA_RAW_DATA_FORMAT;

typedef struct _WHEA_ERROR_PACKET_V1 {
    ULONG                   Signature;                          // +0x00 (0)
    WHEA_ERROR_PACKET_FLAGS Flags;                              // +0x04 (4)
    ULONG                   Size;                               // +0x08 (8)
    ULONG                   RawDataLength;                      // +0x0C (12)
    ULONGLONG               Reserved1;                          // +0x10 (16)
    ULONGLONG               Context;                            // +0x18 (24)
    WHEA_ERROR_TYPE         ErrorType;                          // +0x20 (32)
    WHEA_ERROR_SEVERITY     ErrorSeverity;                      // +0x24 (36)
    ULONG                   ErrorSourceId;                      // +0x28 (40)
    WHEA_ERROR_SOURCE_TYPE  ErrorSourceType;                    // +0x2C (44)
    ULONG                   Reserved2;                          // +0x30 (48)
    ULONG                   Version;                            // +0x34 (52)
    ULONGLONG               Cpu;                                // +0x38 (56)
    union {
        WHEA_PROCESSOR_GENERIC_ERROR_SECTION    ProcessorError; // +0x40 (64)
        WHEA_MEMORY_ERROR_SECTION               MemoryError;
        WHEA_NMI_ERROR_SECTION                  NmiError;
        WHEA_PCIEXPRESS_ERROR_SECTION           PciExpressError;
        WHEA_PCIXBUS_ERROR_SECTION              PciXBusError;
        WHEA_PCIXDEVICE_ERROR_SECTION           PciXDeviceError;
    } u;
    WHEA_RAW_DATA_FORMAT     RawDataFormat;                     // +0x110 (272)
    ULONG                    RawDataOffset;                     // +0x114 (276)
    UCHAR                    RawData[1];                        // +0x118 (280)

} WHEA_ERROR_PACKET_V1, *PWHEA_ERROR_PACKET_V1;

#define WHEA_ERROR_PACKET_V1_SIGNATURE  'tPrE'
#define WHEA_ERROR_PACKET_V1_VERSION    2

typedef struct _WHEA_ERROR_PACKET_V2 {
    ULONG Signature;
    ULONG Version;
    ULONG Length;
    WHEA_ERROR_PACKET_FLAGS Flags;
    WHEA_ERROR_TYPE ErrorType;
    WHEA_ERROR_SEVERITY ErrorSeverity;
    ULONG ErrorSourceId;
    WHEA_ERROR_SOURCE_TYPE ErrorSourceType;
    GUID NotifyType;
    ULONGLONG Context;
    WHEA_ERROR_PACKET_DATA_FORMAT DataFormat;
    ULONG Reserved1;
    ULONG DataOffset;
    ULONG DataLength;
    ULONG PshedDataOffset;
    ULONG PshedDataLength;
    // UCHAR Data[ANYSIZE_ARRAY];
    // UCHAR PshedData[ANYSIZE_ARRAY];
} WHEA_ERROR_PACKET_V2, *PWHEA_ERROR_PACKET_V2;

CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, Signature,         0,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, Version,           4,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, Length,            8,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, Flags,            12,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, ErrorType,        16,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, ErrorSeverity,    20,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, ErrorSourceId,    24,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, ErrorSourceType,  28,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, NotifyType,       32,  16);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, Context,          48,   8);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, DataFormat,       56,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, Reserved1,        60,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, DataOffset,       64,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, DataLength,       68,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, PshedDataOffset,  72,   4);
CPER_FIELD_CHECK(WHEA_ERROR_PACKET_V2, PshedDataLength,  76,   4);

#define WHEA_ERROR_PACKET_V2_SIGNATURE 'AEHW'
#define WHEA_ERROR_PACKET_V2_VERSION   3

#if (NTDDI_VERSION >= NTDDI_WIN7)

#define WHEA_ERROR_PACKET_SIGNATURE     WHEA_ERROR_PACKET_V2_SIGNATURE
#define WHEA_ERROR_PACKET_VERSION       WHEA_ERROR_PACKET_V2_VERSION
typedef struct _WHEA_ERROR_PACKET_V2    WHEA_ERROR_PACKET, *PWHEA_ERROR_PACKET;

#else

#define WHEA_ERROR_PACKET_SIGNATURE     WHEA_ERROR_PACKET_V1_SIGNATURE
#define WHEA_ERROR_PACKET_VERSION       WHEA_ERROR_PACKET_V1_VERSION
#define WHEA_ERROR_PKT_SIGNATURE        WHEA_ERROR_PACKET_SIGNATURE
#define WHEA_ERROR_PKT_VERSION          WHEA_ERROR_PACKET_VERSION
typedef struct _WHEA_ERROR_PACKET_V1    WHEA_ERROR_PACKET, *PWHEA_ERROR_PACKET;

#endif

//---------------------------------------------------------- WHEA_GENERIC_ERROR

//
// These structure define the data format that must be used by error sources
// when reporting errors of the generic error type.
//

typedef union _WHEA_GENERIC_ERROR_BLOCKSTATUS {
    struct {
        ULONG UncorrectableError:1;
        ULONG CorrectableError:1;
        ULONG MultipleUncorrectableErrors:1;
        ULONG MultipleCorrectableErrors:1;
        ULONG ErrorDataEntryCount:10;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_GENERIC_ERROR_BLOCKSTATUS, *PWHEA_GENERIC_ERROR_BLOCKSTATUS;

typedef struct _WHEA_GENERIC_ERROR {
    WHEA_GENERIC_ERROR_BLOCKSTATUS BlockStatus;
    ULONG RawDataOffset;
    ULONG RawDataLength;
    ULONG DataLength;
    WHEA_ERROR_SEVERITY ErrorSeverity;
    UCHAR Data[1];
} WHEA_GENERIC_ERROR, *PWHEA_GENERIC_ERROR;

typedef struct _WHEA_GENERIC_ERROR_DATA_ENTRY {
    GUID SectionType;
    WHEA_ERROR_SEVERITY ErrorSeverity;
    WHEA_REVISION Revision;
    UCHAR ValidBits;
    UCHAR Flags;
    ULONG ErrorDataLength;
    GUID FRUId;
    UCHAR FRUText[20];
    UCHAR Data[1];
} WHEA_GENERIC_ERROR_DATA_ENTRY, *PWHEA_GENERIC_ERROR_DATA_ENTRY;

#include <poppack.h>

// end_ntddk
// begin_nthal

//------------------------------------------------- WHEA_ERROR_SOURCE_CALLBACKS

typedef
NTSTATUS
(*WHEA_ERROR_SOURCE_CORRECT)(
    _Inout_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _Out_ PULONG MaximumSectionLength
    );

typedef
NTSTATUS
(*WHEA_ERROR_SOURCE_INITIALIZE)(
    _In_ ULONG Phase,
    _Inout_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _Inout_opt_ PVOID Context
    );

typedef
NTSTATUS
(*WHEA_ERROR_SOURCE_CREATE_RECORD)(
    _Inout_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _Inout_ PWHEA_ERROR_PACKET ErrorPacket,
    _Out_writes_bytes_to_(BufferSize, *RecordLength) PWHEA_ERROR_RECORD ErrorRecord,
    _In_ ULONG BufferSize,
    _Inout_opt_ PVOID Context
    );

typedef
NTSTATUS
(*WHEA_ERROR_SOURCE_RECOVER)(
    _Inout_ PVOID Context,
    _Inout_ PWHEA_ERROR_SEVERITY Severity
    );

typedef struct _WHEA_ERROR_SOURCE_CONFIGURATION {
    ULONG Flags;
    WHEA_ERROR_SOURCE_CORRECT Correct;
    WHEA_ERROR_SOURCE_INITIALIZE Initialize;
    WHEA_ERROR_SOURCE_CREATE_RECORD CreateRecord;
    WHEA_ERROR_SOURCE_RECOVER Recover;
} WHEA_ERROR_SOURCE_CONFIGURATION, *PWHEA_ERROR_SOURCE_CONFIGURATION;

//-----------------------------------------------------------------------------

NTKERNELAPI
NTSTATUS
WheaReportHwError(
    _Inout_ PWHEA_ERROR_PACKET ErrorPacket
    );

NTKERNELAPI
NTSTATUS
WheaAddErrorSource(
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _In_opt_ PVOID Context
    );

NTKERNELAPI
PWHEA_ERROR_SOURCE_DESCRIPTOR
WheaGetErrorSource (
    _In_ ULONG ErrorSourceId
    );

NTKERNELAPI
NTSTATUS
WheaRemoveErrorSource(
    _In_ HANDLE Handle
    );

NTKERNELAPI
NTSTATUS
WheaConfigureErrorSource (
    _In_ WHEA_ERROR_SOURCE_TYPE SourceType,
    _In_ PWHEA_ERROR_SOURCE_CONFIGURATION Configuration
    );

NTKERNELAPI
NTSTATUS
WheaInitializeRecordHeader (
    _Out_ PWHEA_ERROR_RECORD_HEADER Header
    );

#if defined (_AMD64_)

//--------------------------------------------------- Deferred Recovery Service

typedef struct _WHEA_DRS_OBJECT *PWHEA_DRS_OBJECT;

typedef
VOID
(*WHEA_DRS_HANDLER) (
    _Inout_ PWHEA_DRS_OBJECT DrsObject,
    _In_ PVOID Context
    );

typedef struct _WHEA_DRS_OBJECT {
    PWHEA_DRS_OBJECT Next;
    LONG Busy;
    WHEA_DRS_HANDLER Handler;
    KIRQL Level;
    PVOID Context;
} WHEA_DRS_OBJECT;

NTKERNELAPI
VOID
WheaDeferredRecoveryService (
    VOID
    );

NTKERNELAPI
VOID
WheaInitializeDeferredRecoveryObject (
    _Out_ PWHEA_DRS_OBJECT Object,
    _In_ WHEA_DRS_HANDLER Handler,
    _In_ KIRQL Level
    );

NTKERNELAPI
BOOLEAN
WheaRequestDeferredRecovery (
    _Inout_ PWHEA_DRS_OBJECT Object,
    _In_opt_ PVOID Context
    );

#endif // defined (_AMD64_)

//---------------------------------------------------- Recovery helper services

NTKERNELAPI
NTSTATUS
WheaAttemptPhysicalPageOffline (
    _In_ PFN_NUMBER Page,
    _In_ BOOLEAN PlatformDirected,
    _In_ BOOLEAN Poisoned
    );

// end_nthal
// begin_ntddk

//----------------------------------------------- WheaGetErrPacketFromErrRecord

_Must_inspect_result_
__inline
PWHEA_ERROR_PACKET
WheaGetErrPacketFromErrRecord (
    _In_ PWHEA_ERROR_RECORD Record
    )

/*++

Routine Description:

    This routine will search out the error packet contained within an error
    record and return a reference to it.

Arguments:

    Record - Supplies a pointer to the error record to be searched.

Return Value:

    If successful, a pointer to the error packet.

    NULL otherwise.

--*/

{

    PWHEA_ERROR_PACKET Packet;
    PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR Descriptor;
    ULONG Section;
    ULONG SizeRequired;

    Packet = NULL;
    if (Record->Header.Signature != WHEA_ERROR_RECORD_SIGNATURE) {
        goto GetErrPacketFromErrRecordEnd;
    }

    //
    // Calculate the size required for the header and section descriptors.
    // Ensure that at least these will be properly contained within the extent
    // of the error record.
    //

    SizeRequired = sizeof(WHEA_ERROR_RECORD_HEADER) +
        (sizeof(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR) *
         Record->Header.SectionCount);

    if (Record->Header.Length < SizeRequired) {
        goto GetErrPacketFromErrRecordEnd;
    }

    //
    // Step through the section descriptors looking for the error packet. If the
    // error packet descriptor is found, ensure that the error packet section is
    // properly contained within the extent of the error record.
    //

    Descriptor = &Record->SectionDescriptor[0];
    for (Section = 0; Section < Record->Header.SectionCount; Section += 1) {

        if (RtlCompareMemory(&Descriptor->SectionType,
                             &WHEA_ERROR_PACKET_SECTION_GUID,
                             sizeof(GUID)) == sizeof(GUID)) {

                SizeRequired = Descriptor->SectionOffset +
                    Descriptor->SectionLength;

                if (Record->Header.Length < SizeRequired) {
                    goto GetErrPacketFromErrRecordEnd;
                }

                Packet = (PWHEA_ERROR_PACKET)
                    (((PUCHAR)Record) + Descriptor->SectionOffset);

#pragma warning(suppress: 26019)
                if (Packet->Signature != WHEA_ERROR_PACKET_SIGNATURE) {
                    Packet = NULL;
                }

                goto GetErrPacketFromErrRecordEnd;
        }

        Descriptor += 1;
    }

GetErrPacketFromErrRecordEnd:
    return Packet;
}

//------------------------------------------- WHEA_ERROR_INJECTION_CAPABILITIES

//
// PSHED plug-ins use this structure to communicate error injection capabilities
// to the operating system.
//

typedef union _WHEA_ERROR_INJECTION_CAPABILITIES {
    struct {
        ULONG ProcessorCorrectable:1;                   // 0x00000001
        ULONG ProcessorUncorrectableNonFatal:1;         // 0x00000002
        ULONG ProcessorUncorrectableFatal:1;            // 0x00000004
        ULONG MemoryCorrectable:1;                      // 0x00000008
        ULONG MemoryUncorrectableNonFatal:1;            // 0x00000010
        ULONG MemoryUncorrectableFatal:1;               // 0x00000020
        ULONG PCIExpressCorrectable:1;                  // 0x00000040
        ULONG PCIExpressUncorrectableNonFatal:1;        // 0x00000080
        ULONG PCIExpressUncorrectableFatal:1;           // 0x00000100
        ULONG PlatformCorrectable:1;                    // 0x00000200
        ULONG PlatformUncorrectableNonFatal:1;          // 0x00000400
        ULONG PlatformUncorrectableFatal:1;             // 0x00000800
        ULONG IA64Corrected:1;                          // 0x00001000
        ULONG IA64Recoverable:1;                        // 0x00002000
        ULONG IA64Fatal:1;                              // 0x00004000
        ULONG IA64RecoverableCache:1;                   // 0x00008000
        ULONG IA64RecoverableRegFile:1;                 // 0x00010000
        ULONG Reserved:15;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} WHEA_ERROR_INJECTION_CAPABILITIES, *PWHEA_ERROR_INJECTION_CAPABILITIES;

#define INJECT_ERRTYPE_PROCESSOR_CORRECTABLE                    0x00000001
#define INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLENONFATAL          0x00000002
#define INJECT_ERRTYPE_PROCESSOR_UNCORRECTABLEFATAL             0x00000004
#define INJECT_ERRTYPE_MEMORY_CORRECTABLE                       0x00000008
#define INJECT_ERRTYPE_MEMORY_UNCORRECTABLENONFATAL             0x00000010
#define INJECT_ERRTYPE_MEMORY_UNCORRECTABLEFATAL                0x00000020
#define INJECT_ERRTYPE_PCIEXPRESS_CORRECTABLE                   0x00000040
#define INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLENONFATAL         0x00000080
#define INJECT_ERRTYPE_PCIEXPRESS_UNCORRECTABLEFATAL            0x00000100
#define INJECT_ERRTYPE_PLATFORM_CORRECTABLE                     0x00000200
#define INJECT_ERRTYPE_PLATFORM_UNCORRECTABLENONFATAL           0x00000400
#define INJECT_ERRTYPE_PLATFORM_UNCORRECTABLEFATAL              0x00000800

//----------------------------------------------------------- In-use Page Offline Callbacks

#if defined (_AMD64_)

typedef
BOOLEAN
(*PFN_IN_USE_PAGE_OFFLINE_NOTIFY) (
    _In_ PFN_NUMBER Page,
    _In_ BOOLEAN PlatformDirected,
    _In_ BOOLEAN Poisoned,
    _In_ PVOID Context
    );

NTKERNELAPI
NTSTATUS
WheaRegisterInUsePageOfflineNotification (
    _In_ PFN_IN_USE_PAGE_OFFLINE_NOTIFY Callback,
    _In_opt_ PVOID Context
    );

NTKERNELAPI
NTSTATUS
WheaUnregisterInUsePageOfflineNotification (
    _In_ PFN_IN_USE_PAGE_OFFLINE_NOTIFY Callback
    );

#endif // _AMD64_

typedef struct _WHEA_RECOVERY_CONTEXT {
    union {
        struct {
            ULONG_PTR Address;
            BOOLEAN Consumed;
            UINT16 ErrorCode;
            BOOLEAN ErrorIpValid;
            BOOLEAN RestartIpValid;
        } MemoryError;
    };
    UINT64 PartitionId;  //HV_PARTITION_ID
    UINT32 VpIndex;      //HV_VP_INDEX

} WHEA_RECOVERY_CONTEXT, *PWHEA_RECOVERY_CONTEXT;

#if !defined(XBOX_SYSTEMOS)

typedef
NTSTATUS
(HVL_WHEA_ERROR_NOTIFICATION) (
    _In_ PWHEA_RECOVERY_CONTEXT RecoveryContext,
    _In_ BOOLEAN PlatformDirected,
    _In_ BOOLEAN Poisoned
    );

typedef HVL_WHEA_ERROR_NOTIFICATION *PHVL_WHEA_ERROR_NOTIFICATION;

extern PHVL_WHEA_ERROR_NOTIFICATION HvlpWheaErrorNotificationCallback;

NTKERNELAPI
NTSTATUS
HvlRegisterWheaErrorNotification (
    _In_ PHVL_WHEA_ERROR_NOTIFICATION Callback
    );

NTKERNELAPI
NTSTATUS
HvlUnregisterWheaErrorNotification(
    _In_ PHVL_WHEA_ERROR_NOTIFICATION Callback
    );

#endif

// end_ntddk
// begin_nthal

//-------------------------------------------------------------- PSHED Services

//
// The following services are provided by the PSHED for use by the kernel as
// well as the various error source type providers. These include the HAL and
// PCI driver, amongst others.
//

NTPSHEDAPI
NTSTATUS
PshedAttemptErrorRecovery(
    _Inout_ PWHEA_ERROR_RECORD ErrorRecord
    );

NTPSHEDAPI
VOID
PshedBugCheckSystem (
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _In_ PWHEA_ERROR_RECORD ErrorRecord
    );

NTPSHEDAPI
NTSTATUS
PshedClearErrorRecord(
    _In_ ULONG Flags,
    _In_ ULONGLONG RecordId
    );

NTPSHEDAPI
NTSTATUS
PshedDisableErrorSource (
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTPSHEDAPI
NTSTATUS
PshedEnableErrorSource (
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTPSHEDAPI
NTSTATUS
PshedFinalizeErrorRecord(
    _Inout_ PWHEA_ERROR_RECORD ErrorRecord,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTPSHEDAPI
NTSTATUS
PshedGetAllErrorSources (
    _Out_ PULONG ErrorSourceCount,
    _Inout_ _At_(*Buffer, _Pre_readable_byte_size_(*Length) _Post_readable_byte_size_(*Length)) PUCHAR *Buffer,
    _Inout_ PULONG Length
    );

NTPSHEDAPI
NTSTATUS
PshedGetBootErrorPacket (
    _Out_ PULONG BootPacketLength,
    _Out_ PWHEA_ERROR_PACKET *BootPacket
    );

NTPSHEDAPI
NTSTATUS
PshedGetErrorSourceInfo (
    _In_ WHEA_ERROR_SOURCE_TYPE ErrorSource,
    _Inout_ PWHEA_ERROR_SOURCE_DESCRIPTOR Descriptor
    );

NTPSHEDAPI
NTSTATUS
PshedGetInjectionCapabilities (
    _Out_ PWHEA_ERROR_INJECTION_CAPABILITIES Capabilities
    );

NTPSHEDAPI
NTSTATUS
PshedInjectError (
    _In_ ULONG ErrorType,
    _In_ ULONGLONG Parameter1,
    _In_ ULONGLONG Parameter2,
    _In_ ULONGLONG Parameter3,
    _In_ ULONGLONG Parameter4
    );

NTPSHEDAPI
NTSTATUS
PshedReadErrorRecord(
    _In_ ULONG Flags,
    _In_ ULONGLONG ErrorRecordId,
    _Out_ PULONGLONG NextErrorRecordId,
    _Out_ PULONG RecordLength,
    _Outptr_result_bytebuffer_(*RecordLength) PWHEA_ERROR_RECORD *ErrorRecord
    );

NTPSHEDAPI
NTSTATUS
PshedRetrieveErrorInfo (
    _Inout_ PWHEA_ERROR_PACKET ErrorPkt,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTPSHEDAPI
NTSTATUS
PshedSetErrorSourceInfo (
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

NTPSHEDAPI
NTSTATUS
PshedWriteErrorRecord(
    _In_ ULONG Flags,
    _In_ ULONG RecordLength,
    _In_reads_bytes_(RecordLength) PWHEA_ERROR_RECORD ErrorRecord
    );

NTPSHEDAPI
VOID
PshedMarkHiberPhase (
    VOID
    );

NTPSHEDAPI
LOGICAL
PshedArePluginsPresent (
    VOID
    );

//------------------------------------------------------- Internal Error Values

#define WHEA_INTERNAL_ERROR_PSHEDHESTSOURCEINITFAILED  0x00000001
#define WHEA_INTERNAL_ERROR_WHEAINFOALLOCFAILED        0x00000002
#define WHEA_INTERNAL_ERROR_PSHEDINITFAILED            0x00000003
#define WHEA_INTERNAL_ERROR_CREATEPERPROCINFOFAILED    0x00000004
#define WHEA_INTERNAL_ERROR_QUERYERRSOURCESFAILED      0x00000005
#define WHEA_INTERNAL_ERROR_ERRSOURCEINITFAILED        0x00000006
#define WHEA_INTERNAL_ERROR_ERRSOURCETABLEINITFAILED   0x00000007
#define WHEA_INTERNAL_ERROR_PSHEDERRSOURCEINITFAILED   0x00000008
#define WHEA_INTERNAL_ERROR_INVALIDERRORSOURCE         0x00000009
#define WHEA_INTERNAL_ERROR_NOERRORRECORD              0x0000000A
#define WHEA_INTERNAL_ERROR_INVALIDFATALERROR          0x0000000B

//------------------------------------------------------ WHEA_PSHED_INIT_PACKET

typedef struct _WHEA_PSHED_INIT_PACKET {
    ULONG Size;
    ULONG Version;
} WHEA_PSHED_INIT_PACKET, *PWHEA_PSHED_INIT_PACKET;

// end_nthal
// begin_ntddk

//------------------------------------------------ PSHED Plug-in Callback Types

_Must_inspect_result_
typedef
NTSTATUS
(*PSHED_PI_GET_ALL_ERROR_SOURCES) (
    _Inout_opt_ PVOID PluginContext,
    _Inout_ PULONG Count,
    _Inout_updates_bytes_(*Length) PWHEA_ERROR_SOURCE_DESCRIPTOR *ErrorSrcs,
    _Inout_ PULONG Length
    );

_Must_inspect_result_
typedef
NTSTATUS
(*PSHED_PI_GET_ERROR_SOURCE_INFO) (
    _Inout_opt_ PVOID PluginContext,
    _Inout_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

_Must_inspect_result_
typedef
NTSTATUS
(*PSHED_PI_SET_ERROR_SOURCE_INFO) (
    _Inout_opt_ PVOID PluginContext,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

typedef
NTSTATUS
 (*PSHED_PI_ENABLE_ERROR_SOURCE) (
    _Inout_opt_ PVOID PluginContext,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

typedef
NTSTATUS
 (*PSHED_PI_DISABLE_ERROR_SOURCE) (
    _Inout_opt_ PVOID PluginContext,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource
    );

typedef
NTSTATUS
(*PSHED_PI_WRITE_ERROR_RECORD) (
    _Inout_opt_ PVOID PluginContext,
    _In_ ULONG Flags,
    _In_ ULONG RecordLength,
    _In_reads_bytes_(RecordLength) PWHEA_ERROR_RECORD ErrorRecord
    );

_Must_inspect_result_
typedef
NTSTATUS
(*PSHED_PI_READ_ERROR_RECORD) (
    _Inout_opt_ PVOID PluginContext,
    _In_ ULONG Flags,
    _In_ ULONGLONG ErrorRecordId,
    _Out_ PULONGLONG NextErrorRecordId,
    _Inout_ PULONG RecordLength,
    _Out_writes_bytes_(*RecordLength) PWHEA_ERROR_RECORD ErrorRecord
    );

typedef
NTSTATUS
(*PSHED_PI_CLEAR_ERROR_RECORD) (
    _Inout_opt_ PVOID PluginContext,
    _In_ ULONG Flags,
    _In_ ULONGLONG ErrorRecordId
    );

typedef
NTSTATUS
(*PSHED_PI_RETRIEVE_ERROR_INFO) (
    _Inout_opt_ PVOID PluginContext,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _In_ ULONGLONG BufferLength,
    _Inout_updates_bytes_(BufferLength) PWHEA_ERROR_PACKET Packet
    );

typedef
NTSTATUS
(*PSHED_PI_FINALIZE_ERROR_RECORD) (
    _Inout_opt_ PVOID PluginContext,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _In_ ULONG BufferLength,
    _Inout_updates_bytes_(BufferLength) PWHEA_ERROR_RECORD ErrorRecord
    );

typedef
NTSTATUS
(*PSHED_PI_CLEAR_ERROR_STATUS) (
    _Inout_opt_ PVOID PluginContext,
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _In_ ULONG BufferLength,
    _In_reads_bytes_(BufferLength) PWHEA_ERROR_RECORD ErrorRecord
    );

_Must_inspect_result_
typedef
NTSTATUS
(*PSHED_PI_ATTEMPT_ERROR_RECOVERY) (
    _Inout_opt_ PVOID PluginContext,
    _In_ ULONG BufferLength,
    _In_reads_bytes_(BufferLength) PWHEA_ERROR_RECORD ErrorRecord
    );

_Must_inspect_result_
typedef
NTSTATUS
(*PSHED_PI_GET_INJECTION_CAPABILITIES) (
    _Inout_opt_ PVOID PluginContext,
    _Out_ PWHEA_ERROR_INJECTION_CAPABILITIES Capabilities
    );

_Must_inspect_result_
typedef
NTSTATUS
(*PSHED_PI_INJECT_ERROR) (
    _Inout_opt_ PVOID PluginContext,
    _In_ ULONGLONG ErrorType,
    _In_ ULONGLONG Parameter1,
    _In_ ULONGLONG Parameter2,
    _In_ ULONGLONG Parameter3,
    _In_ ULONGLONG Parameter4
    );

//--------------------------------------- WHEA_PSHED_PLUGIN_REGISTRATION_PACKET

typedef struct _WHEA_PSHED_PLUGIN_CALLBACKS {
    PSHED_PI_GET_ALL_ERROR_SOURCES GetAllErrorSources;
    PVOID Reserved;
    PSHED_PI_GET_ERROR_SOURCE_INFO GetErrorSourceInfo;
    PSHED_PI_SET_ERROR_SOURCE_INFO SetErrorSourceInfo;
    PSHED_PI_ENABLE_ERROR_SOURCE EnableErrorSource;
    PSHED_PI_DISABLE_ERROR_SOURCE DisableErrorSource;
    PSHED_PI_WRITE_ERROR_RECORD WriteErrorRecord;
    PSHED_PI_READ_ERROR_RECORD ReadErrorRecord;
    PSHED_PI_CLEAR_ERROR_RECORD ClearErrorRecord;
    PSHED_PI_RETRIEVE_ERROR_INFO RetrieveErrorInfo;
    PSHED_PI_FINALIZE_ERROR_RECORD FinalizeErrorRecord;
    PSHED_PI_CLEAR_ERROR_STATUS ClearErrorStatus;
    PSHED_PI_ATTEMPT_ERROR_RECOVERY AttemptRecovery;
    PSHED_PI_GET_INJECTION_CAPABILITIES GetInjectionCapabilities;
    PSHED_PI_INJECT_ERROR InjectError;
} WHEA_PSHED_PLUGIN_CALLBACKS, *PWHEA_PSHED_PLUGIN_CALLBACKS;

typedef struct _WHEA_PSHED_PLUGIN_REGISTRATION_PACKET {
    ULONG Length;
    ULONG Version;
    PVOID Context;
    ULONG FunctionalAreaMask;
    ULONG Reserved;
    WHEA_PSHED_PLUGIN_CALLBACKS Callbacks;
} WHEA_PSHED_PLUGIN_REGISTRATION_PACKET,
  *PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET;

#define WHEA_PLUGIN_REGISTRATION_PACKET_VERSION 0x00010000

//
// These defines specify the values of the bits in the functional area mask
// field of the PSHED plug-in registration packet.
//

#define PshedFADiscovery              0x00000001
#define PshedFAErrorSourceControl     0x00000002
#define PshedFAErrorRecordPersistence 0x00000004
#define PshedFAErrorInfoRetrieval     0x00000008
#define PshedFAErrorRecovery          0x00000010
#define PshedFAErrorInjection         0x00000020

//------------------------------------------------------ PSHED Plug-in services

#define WHEA_WRITE_FLAG_DUMMY 0x00000001

//
// The following services are exported by the PSHED for use by PSHED plug-ins.
//

#if (NTDDI_VERSION >= NTDDI_WS08)
_IRQL_requires_max_(DISPATCH_LEVEL)
__drv_allocatesMem(Mem)
_Post_writable_byte_size_(Size)
_Must_inspect_result_
NTPSHEDAPI
PVOID
PshedAllocateMemory (
    _In_ ULONG Size
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS08)
_IRQL_requires_max_(DISPATCH_LEVEL)
NTPSHEDAPI
VOID
PshedFreeMemory (
    _In_ __drv_freesMem(Mem) PVOID Address
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS08)
NTPSHEDAPI
BOOLEAN
PshedIsSystemWheaEnabled (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS08)
_IRQL_requires_max_(PASSIVE_LEVEL)
NTPSHEDAPI
NTSTATUS
PshedRegisterPlugin (
    _Inout_ PWHEA_PSHED_PLUGIN_REGISTRATION_PACKET Packet
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS08)
NTPSHEDAPI
BOOLEAN
PshedSynchronizeExecution (
    _In_ PWHEA_ERROR_SOURCE_DESCRIPTOR ErrorSource,
    _In_ PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    _In_ PVOID SynchronizeContext
    );
#endif

//----------------------------------------------- Error record access functions

_Must_inspect_result_
__inline
BOOLEAN
WheaIsValidErrorRecordSignature (
    _In_ PWHEA_ERROR_RECORD Record
    )

/*++

Routine Description:

    This routine will compare the error record signature with the proper values
    and signal whether it is correct or not.

Arguments:

    Record - Supplies a pointer to the error record.

Return Value:

    TRUE if the error record signature is correct.

    FALSE otherwise.

--*/

{

    BOOLEAN Valid;

    if ((Record->Header.Signature == WHEA_ERROR_RECORD_SIGNATURE) &&
        (Record->Header.Revision.AsUSHORT == WHEA_ERROR_RECORD_REVISION) &&
        (Record->Header.SignatureEnd == WHEA_ERROR_RECORD_SIGNATURE_END)) {

        Valid = TRUE;

    } else {
        Valid = FALSE;
    }

    return Valid;
}

_Must_inspect_result_
__inline
NTSTATUS
WheaFindErrorRecordSection (
    _In_ PWHEA_ERROR_RECORD Record,
    _In_ const GUID *SectionType,
    _Out_ PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR *SectionDescriptor,
    _Out_opt_ PVOID *SectionData
    )

/*++

Routine Description:

    This routine provides a means to search an error record for a specific
    section.

Arguments:

    Record - Supplies a pointer to the error record.

    SectionType - Supplies a GUID specifying the section being sought. This may
        be any standard common platform error record or implementation specific
        section type.

    Descriptor - Supplies a location in which a pointer to the descriptor for
        the found section is returned.

    Section - Supplies an optional location in which a pointer to the found
        section is returned.

Return Value:

    STATUS_SUCCESS if the specified section is found.

    STATUS_NOT_FOUND if the specified section is not found.

    STATUS_INVALID_PARAMETER if the record does not appear well formed or the
        context parameter is null in cases where it is required.

--*/

{

    NTSTATUS Status;
    PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR Descriptor;
    ULONG Index;
    ULONG MinimumLength;

    if ((Record == NULL) ||
        (SectionType == NULL) ||
        (SectionDescriptor == NULL) ||
        (WheaIsValidErrorRecordSignature(Record) == FALSE) ||
        (Record->Header.SectionCount == 0)) {

        Status = STATUS_INVALID_PARAMETER;
        goto FindErrorRecordSectionEnd;
    }

    //
    // Ensure that the supplied record is at least as long as required to store
    // the descriptors for the sections supposedly in the record.
    //

    MinimumLength = sizeof(WHEA_ERROR_RECORD_HEADER) +
        (Record->Header.SectionCount *
         sizeof(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR));

    if (Record->Header.Length < MinimumLength) {
        Status = STATUS_INVALID_PARAMETER;
        goto FindErrorRecordSectionEnd;
    }

    //
    // Iterate through the record searching for the section in question.
    //

    Descriptor = &Record->SectionDescriptor[0];
    for (Index = 0; Index < Record->Header.SectionCount; Index += 1) {
        if (RtlCompareMemory(&Descriptor->SectionType,
                             SectionType,
                             sizeof(GUID)) == sizeof(GUID)) {

            break;
        }

        Descriptor += 1;
    }

    if (Index >= Record->Header.SectionCount) {
        Status = STATUS_NOT_FOUND;
        goto FindErrorRecordSectionEnd;
    }

    //
    // If the descriptor describes a section that is not completely contained
    // within the record then the record is invalid.
    //

    if ((Descriptor->SectionOffset + Descriptor->SectionLength) >
        Record->Header.Length) {

        Status = STATUS_INVALID_PARAMETER;
        goto FindErrorRecordSectionEnd;
    }

    //
    // Return the descriptor and optionally a pointer to the section itself.
    //

    *SectionDescriptor = Descriptor;
    if (SectionData != NULL) {
        *SectionData = (PVOID)(((PUCHAR)Record) + Descriptor->SectionOffset);
    }

    Status = STATUS_SUCCESS;

FindErrorRecordSectionEnd:
    return Status;
}

_Must_inspect_result_
__inline
NTSTATUS
WheaFindNextErrorRecordSection (
    _In_ PWHEA_ERROR_RECORD Record,
    _Inout_ ULONG *Context,
    _Out_ PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR *SectionDescriptor,
    _Out_opt_ PVOID *SectionData
    )

/*++

Routine Description:

    This routine allows the caller to iterate through the sections in an error
    record.

Arguments:

    Record - Supplies a pointer to the error record.

    Context - Supplies a pointer to a variable that maintains the current state
        of the search. This variable should be zero for the first call, and the
        same variable should be used in subsequent calls to enumerate the next
        sections in the record.

    Descriptor - Supplies a location in which a pointer to the descriptor for
        the found section is returned.

    Section - Supplies an optional location in which a pointer to the found
        section is returned.

Return Value:

    STATUS_SUCCESS if the specified section is found.

    STATUS_NOT_FOUND if the specified section is not found.

    STATUS_INVALID_PARAMETER if the record does not appear well formed or a
        required parameter is null.

--*/

{

    NTSTATUS Status;
    PWHEA_ERROR_RECORD_SECTION_DESCRIPTOR Descriptor;
    ULONG Index;
    ULONG MinimumLength;

    if ((Record == NULL) ||
        (Context == NULL) ||
        (SectionDescriptor == NULL) ||
        (WheaIsValidErrorRecordSignature(Record) == FALSE) ||
        (Record->Header.SectionCount == 0)) {

        Status = STATUS_INVALID_PARAMETER;
        goto FindNextErrorRecordSectionEnd;
    }

    //
    // Ensure that the supplied record is at least as long as required to store
    // the descriptors for the sections supposedly in the record.
    //

    MinimumLength = sizeof(WHEA_ERROR_RECORD_HEADER) +
        (Record->Header.SectionCount *
         sizeof(WHEA_ERROR_RECORD_SECTION_DESCRIPTOR));

    if (Record->Header.Length < MinimumLength) {
        Status = STATUS_INVALID_PARAMETER;
        goto FindNextErrorRecordSectionEnd;
    }

    //
    // If the index is greater than the number of sections, then it has been
    // incorrectly fabricated by the caller or the record had section removed
    // during the enumeration. Either way, this is different to the case where
    // there are no sections left.
    //

    Index = *Context;
    if (Index > Record->Header.SectionCount) {
        Status = STATUS_INVALID_PARAMETER;
        goto FindNextErrorRecordSectionEnd;
    }

    if (Index == Record->Header.SectionCount) {
        Status = STATUS_NOT_FOUND;
        goto FindNextErrorRecordSectionEnd;
    }

    Descriptor = &Record->SectionDescriptor[Index];

    //
    // If the descriptor describes a section that is not completely contained
    // within the record then the record is invalid.
    //

    if ((Descriptor->SectionOffset + Descriptor->SectionLength) >
        Record->Header.Length) {

        Status = STATUS_INVALID_PARAMETER;
        goto FindNextErrorRecordSectionEnd;
    }

    *Context = Index + 1;
    *SectionDescriptor = Descriptor;
    if (SectionData != NULL) {
        *SectionData = (PVOID)(((PUCHAR)Record) + Descriptor->SectionOffset);
    }

    Status = STATUS_SUCCESS;

FindNextErrorRecordSectionEnd:
    return Status;
}

//
// SOC Subsystem bugcheck reporting information
//
typedef enum _SOC_SUBSYSTEM_TYPE {
    SOC_SUBSYS_WIRELESS_MODEM = 0,
    SOC_SUBSYS_AUDIO_DSP = 1,
    SOC_SUBSYS_WIRELSS_CONNECTIVITY = 2,
    SOC_SUBSYS_SENSORS = 3,


    //
    // Subsystem types starting from 0x10000 are reserved for SoC vendor use.
    //

    SOC_SUBSYS_VENDOR_DEFINED = 0x10000
} SOC_SUBSYSTEM_TYPE, *PSOC_SUBSYSTEM_TYPE;


typedef struct _SOC_SUBSYSTEM_FAILURE_DETAILS {
    SOC_SUBSYSTEM_TYPE SubsysType;
    ULONG64 FirmwareVersion;
    ULONG64 HardwareVersion;
    ULONG   UnifiedFailureRegionSize;
    CHAR    UnifiedFailureRegion[1];
} SOC_SUBSYSTEM_FAILURE_DETAILS, *PSOC_SUBSYSTEM_FAILURE_DETAILS;


//
// PPM interface contract version
//
// This version number specifies the internal interface version number of the
// PPM interfaces. The kernel will only accept PPM registrations from processor
// drivers with a matching version number. Any time any change to the below
// interfaces are made, this version number should be bumped to make sure PPM
// drivers do not load with a non-matching kernel.
//

#define PROCESSOR_INTERFACE_VERSION 42

//
// Performance feedback interface
//

_Function_class_(PROCESSOR_FEEDBACK_INSTANTANEOUS_READ)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_FEEDBACK_INSTANTANEOUS_READ) (
    _In_ ULONG_PTR Context,
    _Out_ PULONG Value
    );

typedef PROCESSOR_FEEDBACK_INSTANTANEOUS_READ *PPROCESSOR_FEEDBACK_INSTANTANEOUS_READ;

_Function_class_(PROCESSOR_FEEDBACK_DIFFERENTIAL_READ)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_FEEDBACK_DIFFERENTIAL_READ) (
    _In_ ULONG_PTR Context,
    _In_ BOOLEAN Reset,
    _Out_ PULONG64 ReferenceCount,
    _Out_ PULONG64 ActualCount
    );

typedef PROCESSOR_FEEDBACK_DIFFERENTIAL_READ *PPROCESSOR_FEEDBACK_DIFFERENTIAL_READ;

typedef struct _PROCESSOR_FEEDBACK_COUNTER {
    union {
        PPROCESSOR_FEEDBACK_INSTANTANEOUS_READ InstantaneousRead;
        PPROCESSOR_FEEDBACK_DIFFERENTIAL_READ DifferentialRead;
    };

    ULONG NominalRate;
    ULONG Type;
    BOOLEAN Affinitized;
    BOOLEAN Differential;
} PROCESSOR_FEEDBACK_COUNTER, *PPROCESSOR_FEEDBACK_COUNTER;

#define PROCESSOR_FEEDBACK_COUNTER_FREQUENCY      0x00
#define PROCESSOR_FEEDBACK_COUNTER_PERFORMANCE    0x01
#define PROCESSOR_FEEDBACK_COUNTER_MAX            0x02


//
// Old performance feedback interface
//

_Function_class_(PROCESSOR_FETCH_MSR_ROUTINE)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_FETCH_MSR_ROUTINE) (
    _Out_ PULONG64 MSRValue
    );

typedef PROCESSOR_FETCH_MSR_ROUTINE *PPROCESSOR_FETCH_MSR_ROUTINE;

//
// Static processor policy interface
//

_Function_class_(PROCESSOR_POLICY_ACTION)
_IRQL_requires_same_
typedef
NTSTATUS
(FASTCALL PROCESSOR_POLICY_ACTION) (
    VOID
    );

typedef PROCESSOR_POLICY_ACTION *PPROCESSOR_POLICY_ACTION;

_Function_class_(PROCESSOR_POLICY_HANDLER)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_POLICY_HANDLER) (
    _In_ ULONG_PTR Context,
    _In_ ULONG Policy
    );

typedef PROCESSOR_POLICY_HANDLER *PPROCESSOR_POLICY_HANDLER;

//
// Energy estimation interface.
//

_Function_class_(PROCESSOR_COMPUTE_ENERGY_ROUTINE)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_COMPUTE_ENERGY_ROUTINE) (
    _In_reads_(PO_EFFICIENCY_CLASSES) PULONG64 ActiveTime,
    _In_reads_(PO_EFFICIENCY_CLASSES) PULONG64 TotalTime,
    _In_reads_(PO_EFFICIENCY_CLASSES) PULONG FrequencyPercent,
    _Out_writes_(PO_EFFICIENCY_CLASSES) PULONG64 EnergyConsumed
    );

typedef PROCESSOR_COMPUTE_ENERGY_ROUTINE *PPROCESSOR_COMPUTE_ENERGY_ROUTINE;

_Function_class_(PROCESSOR_SNAP_ENERGYCOUNTERS_ROUTINE)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_SNAP_ENERGYCOUNTERS_ROUTINE) (
    __in ULONG ProcIndex,
    __in BOOLEAN Remote,
    __in BOOLEAN SnapPmc
    );

typedef PROCESSOR_SNAP_ENERGYCOUNTERS_ROUTINE *PPROCESSOR_SNAP_ENERGYCOUNTERS_ROUTINE;

//
// Performance control interface.
//

_Function_class_(PROCESSOR_PERF_REINITIALIZE_HANDLER)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_PERF_REINITIALIZE_HANDLER) (
    _In_ ULONG_PTR Context
    );

typedef PROCESSOR_PERF_REINITIALIZE_HANDLER *PPROCESSOR_PERF_REINITIALIZE_HANDLER;

#define PROCESSOR_PERF_SELECTION_ALLOW_THROTTLE    0x1
#define PROCESSOR_PERF_SELECTION_ROUND_DOWN        0x2

_Function_class_(PROCESSOR_PERF_SELECTION_HANDLER)
_IRQL_requires_same_
typedef
ULONG
(FASTCALL PROCESSOR_PERF_SELECTION_HANDLER) (
    _In_ ULONG_PTR Context,
    _In_ ULONG TargetPercent,
    _In_ ULONG MinPercent,
    _In_ ULONG MaxPercent,
    _In_ ULONG Flags,
    _Out_ PULONG Frequency,
    _Out_ PULONG64 State
    );

typedef PROCESSOR_PERF_SELECTION_HANDLER *PPROCESSOR_PERF_SELECTION_HANDLER;

#define PROCESSOR_PERF_CONTEXT_FORCE_STATE         ULONG_MAX

_Function_class_(PROCESSOR_PERF_CONTROL_HANDLER)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_PERF_CONTROL_HANDLER) (
    _In_ ULONG_PTR Context,
    _In_ ULONG64 State,
    _In_ ULONG MinPercent,
    _In_ ULONG MaxPercent,
    _In_ ULONG TolerancePercent,
    _In_ BOOLEAN Autonomous,
    _In_ BOOLEAN Initiate,
    _In_ BOOLEAN Force
    );

typedef PROCESSOR_PERF_CONTROL_HANDLER *PPROCESSOR_PERF_CONTROL_HANDLER;

_Function_class_(PROCESSOR_PERF_CONTROL_CALLBACK)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_PERF_CONTROL_CALLBACK) (
    VOID
    );

typedef PROCESSOR_PERF_CONTROL_CALLBACK *PPROCESSOR_PERF_CONTROL_CALLBACK;

_Function_class_(PROCESSOR_PERF_CONTROL_ACTION)
_IRQL_requires_same_
typedef
VOID
(FASTCALL PROCESSOR_PERF_CONTROL_ACTION) (
    _In_ PPROCESSOR_PERF_CONTROL_CALLBACK Callback
    );

typedef PROCESSOR_PERF_CONTROL_ACTION *PPROCESSOR_PERF_CONTROL_ACTION;

//
// Core parking interface
//

_Function_class_(PROCESSOR_PARK_PREFERENCE_HANDLER)
_IRQL_requires_same_
typedef
VOID
(PROCESSOR_PARK_PREFERENCE_HANDLER) (
    _In_ UCHAR EvaluationType,
    _In_ ULONGLONG EvaluationTime,
    _In_ ULONG UnparkCount,
    _In_ PKAFFINITY_EX ParkGroup,
    _In_opt_ PKAFFINITY_EX Unparked,
    _Inout_opt_ PKAFFINITY_EX HintPark,
    _Inout_opt_ PKAFFINITY_EX HintUnpark
    );

typedef PROCESSOR_PARK_PREFERENCE_HANDLER *PPROCESSOR_PARK_PREFERENCE_HANDLER;

_Function_class_(PROCESSOR_PARK_MASK_HANDLER)
_IRQL_requires_same_
typedef
VOID
(PROCESSOR_PARK_MASK_HANDLER) (
    _In_ ULONGLONG EvaluationTime,
    _In_ PKAFFINITY_EX Parked
    );

typedef PROCESSOR_PARK_MASK_HANDLER *PPROCESSOR_PARK_MASK_HANDLER;

_Function_class_(PROCESSOR_PERF_CHECK_COMPLETE_HANDLER)
_IRQL_requires_same_
typedef
VOID
(PROCESSOR_PERF_CHECK_COMPLETE_HANDLER) (
    _In_ ULONG_PTR Context,
    _In_ ULONGLONG EvaluationTime
    );

typedef PROCESSOR_PERF_CHECK_COMPLETE_HANDLER
    *PPROCESSOR_PERF_CHECK_COMPLETE_HANDLER;

//
// idle interface
//

#define PROCESSOR_IDLE_OVERRIDE_DISABLED  (0xffffffff)

typedef struct _PROCESSOR_IDLE_CONSTRAINTS {
    ULONG64 TotalTime;
    ULONG64 IdleTime;
    ULONG64 ExpectedIdleDuration;
    ULONG64 MaxIdleDuration;
    ULONG OverrideState;
    ULONG TimeCheck;
    UCHAR PromotePercent;
    UCHAR DemotePercent;
    BOOLEAN Parked;
    BOOLEAN Interruptible;
    BOOLEAN PlatformIdle;
    UCHAR ExpectedWakeReason;
} PROCESSOR_IDLE_CONSTRAINTS, *PPROCESSOR_IDLE_CONSTRAINTS;

typedef struct _PROCESSOR_IDLE_DEPENDENCY {
    ULONG ProcessorIndex;
    UCHAR ExpectedState;
    BOOLEAN AllowDeeperStates;
    BOOLEAN LooseDependency;
} PROCESSOR_IDLE_DEPENDENCY, *PPROCESSOR_IDLE_DEPENDENCY;

typedef struct _PROCESSOR_IDLE_PREPARE_INFO {
    PVOID Context;
    PROCESSOR_IDLE_CONSTRAINTS Constraints;
    ULONG DependencyCount;
    _Field_range_(0, DependencyCount) ULONG DependencyUsed;
    _Field_size_part_(DependencyCount, DependencyUsed) PPROCESSOR_IDLE_DEPENDENCY DependencyArray;
    ULONG PlatformIdleStateIndex;
    ULONG ProcessorIdleStateIndex;
    ULONG IdleSelectFailureMask;
} PROCESSOR_IDLE_PREPARE_INFO, *PPROCESSOR_IDLE_PREPARE_INFO;

typedef struct _PROCESSOR_PLATFORM_STATE_RESIDENCY {
    ULONG64 Residency;
    ULONG64 TransitionCount;
} PROCESSOR_PLATFORM_STATE_RESIDENCY, *PPROCESSOR_PLATFORM_STATE_RESIDENCY;

typedef struct _PROCESSOR_PLATFORM_STATE_RESIDENCIES {
    ULONG Count;
    PROCESSOR_PLATFORM_STATE_RESIDENCY States[ANYSIZE_ARRAY];
} PROCESSOR_PLATFORM_STATE_RESIDENCIES, *PPROCESSOR_PLATFORM_STATE_RESIDENCIES;

#define PROCESSOR_NO_EXPECTED_STATE       (0xffffffff)
#define PROCESSOR_IDLE_STATE_ABORT        (0xffffffff)
#define PROCESSOR_IDLE_STATE_FALLBACK_HAL (0xfffffffe)
#define PLATFORM_IDLE_STATE_NONE          (0xffffffff)
#define PLATFORM_IDLE_STATE_UNKNOWN_RESIDENCY (0xffffffffffffffff)

_Function_class_(PROCESSOR_IDLE_PRESELECT)
_IRQL_requires_same_
typedef
ULONG
FASTCALL
PROCESSOR_IDLE_PRESELECT (
    _In_ PVOID Context,
    _Inout_ PPROCESSOR_IDLE_CONSTRAINTS Constraints
    );

typedef PROCESSOR_IDLE_PRESELECT *PPROCESSOR_IDLE_PRESELECT;

_Function_class_(PROCESSOR_IDLE_PREPARE)
_IRQL_requires_same_
typedef
VOID
FASTCALL
PROCESSOR_IDLE_PREPARE (
    _Inout_ PPROCESSOR_IDLE_PREPARE_INFO PrepareInfo
    );

typedef PROCESSOR_IDLE_PREPARE *PPROCESSOR_IDLE_PREPARE;

_Function_class_(PROCESSOR_IDLE_TEST)
_IRQL_requires_same_
typedef
ULONG
FASTCALL
PROCESSOR_IDLE_TEST (
    _In_ PVOID Context,
    _In_ ULONG ProcessorIndex,
    _In_ ULONG PlatformIndex
    );

typedef PROCESSOR_IDLE_TEST *PPROCESSOR_IDLE_TEST;

_Function_class_(PROCESSOR_IDLE_AVAILABILITY_CHECK)
_IRQL_requires_same_
typedef
ULONG
FASTCALL
PROCESSOR_IDLE_AVAILABILITY_CHECK (
    _In_ PVOID Context,
    _In_ ULONG ProcessorIndex
    );

typedef PROCESSOR_IDLE_AVAILABILITY_CHECK *PPROCESSOR_IDLE_AVAILABILITY_CHECK;

_Function_class_(PROCESSOR_IDLE_EXECUTE)
_IRQL_requires_same_
typedef
NTSTATUS
FASTCALL
PROCESSOR_IDLE_EXECUTE (
    _In_ PVOID Context,
    _In_ ULONG ProcessorState,
    _In_ ULONG PlatformState,
    _In_ ULONG CoordinatedSelectionCount,
    _In_reads_(CoordinatedSelectionCount) PULONG CoordinatedSelection
    );

typedef PROCESSOR_IDLE_EXECUTE *PPROCESSOR_IDLE_EXECUTE;

_Function_class_(PROCESSOR_IDLE_COMPLETE)
_IRQL_requires_same_
typedef
VOID
FASTCALL
PROCESSOR_IDLE_COMPLETE (
    _In_ PVOID Context,
    _In_ ULONG ProcessorState,
    _In_ ULONG PlatformState,
    _In_ ULONG CoordinatedSelectionCount,
    _In_reads_(CoordinatedSelectionCount) PULONG CoordinatedSelection
    );

typedef PROCESSOR_IDLE_COMPLETE *PPROCESSOR_IDLE_COMPLETE;

_Function_class_(PROCESSOR_IDLE_CANCEL)
_IRQL_requires_same_
typedef
VOID
FASTCALL
PROCESSOR_IDLE_CANCEL (
    _In_ PVOID Context,
    _In_ ULONG Reason
    );

typedef PROCESSOR_IDLE_CANCEL *PPROCESSOR_IDLE_CANCEL;

_Function_class_(PROCESSOR_IS_HALTED)
_IRQL_requires_same_
typedef
BOOLEAN
FASTCALL
PROCESSOR_IS_HALTED (
    _In_ PVOID Context
    );

typedef PROCESSOR_IS_HALTED *PPROCESSOR_IS_HALTED;

_Function_class_(PROCESSOR_INITIATE_WAKE)
_IRQL_requires_same_
typedef
BOOLEAN
FASTCALL
PROCESSOR_INITIATE_WAKE (
    _In_ PVOID Context
    );

typedef PROCESSOR_INITIATE_WAKE *PPROCESSOR_INITIATE_WAKE;

_Function_class_(PROCESSOR_QUERY_PLATFORM_STATE_RESIDENCY)
_IRQL_requires_same_
typedef
NTSTATUS
FASTCALL
PROCESSOR_QUERY_PLATFORM_STATE_RESIDENCY (
    _In_ PVOID Context,
    _Inout_ PPROCESSOR_PLATFORM_STATE_RESIDENCIES PlatformStateResidencies
    );

typedef PROCESSOR_QUERY_PLATFORM_STATE_RESIDENCY *PPROCESSOR_QUERY_PLATFORM_STATE_RESIDENCY;

typedef struct _PROCESSOR_IDLE_STATE_EX {
    ULONG Interruptible          :1;
    ULONG CacheCoherent          :1;
    ULONG ThreadContextRetained  :1;
    ULONG CStateType             :4;
    ULONG WakesSpuriously        :1;
    ULONG PlatformOnly           :1;
    ULONG Reserved               :21;
    ULONG NoCState               :1;
    ULONG InterruptsEnabled      :1;
    ULONG Latency;
    ULONG BreakEvenDuration;
    ULONG Power;
    UNICODE_STRING Name;
} PROCESSOR_IDLE_STATE_EX, *PPROCESSOR_IDLE_STATE_EX;

typedef struct _PROCESSOR_IDLE_STATES_EX {
    ULONG Version;
    PROCESSOR_NUMBER Processor;
    PVOID Context;
    BOOLEAN EstimateIdleDuration;
    BOOLEAN Update;
    UCHAR InterfaceVersion;

    //
    // V1 idle interface
    //

    PPROCESSOR_IDLE_PREPARE IdlePrepare;
    PPROCESSOR_IDLE_CANCEL IdleCancel;

    //
    // V2 idle interface
    //

    PPROCESSOR_IDLE_PRESELECT IdlePreselect;
    PPROCESSOR_IDLE_TEST IdleTest;
    PPROCESSOR_IDLE_AVAILABILITY_CHECK IdleAvailabilityCheck;
    PPROCESSOR_IDLE_EXECUTE IdlePreExecute;

    //
    // Common interface
    //

    PPROCESSOR_IDLE_EXECUTE IdleExecute;
    PPROCESSOR_IDLE_COMPLETE IdleComplete;
    PPROCESSOR_IS_HALTED IdleIsHalted;
    PPROCESSOR_INITIATE_WAKE IdleInitiateWake;
    ULONG MaximumDependencies;
    ULONG ProcessorIdleCount;
    _Field_size_(ProcessorIdleCount) PROCESSOR_IDLE_STATE_EX State[ANYSIZE_ARRAY];
} PROCESSOR_IDLE_STATES_EX, *PPROCESSOR_IDLE_STATES_EX;

#define PROCESSOR_IDLE_INTERFACE_V1  0
#define PROCESSOR_IDLE_INTERFACE_V2  1

typedef struct _PLATFORM_IDLE_STATE {
    PROCESSOR_NUMBER InitiatingProcessor;
    BOOLEAN OneInitiator;
    UCHAR InitiatingState;
    ULONG Latency;
    ULONG BreakEvenTime;
    ULONG DependencyCount;
    UNICODE_STRING Name;
    _Field_size_(DependencyCount) PPROCESSOR_IDLE_DEPENDENCY Dependencies;
} PLATFORM_IDLE_STATE, *PPLATFORM_IDLE_STATE;

typedef struct _PLATFORM_IDLE_STATES {
    ULONG Version;
    ULONG Count;
    ULONG Definitions;
    PPROCESSOR_IDLE_TEST IdleTest;
    PPROCESSOR_IDLE_EXECUTE IdlePreExecute;
    PPROCESSOR_IDLE_COMPLETE IdleComplete;
    PPROCESSOR_QUERY_PLATFORM_STATE_RESIDENCY QueryPlatformStateResidency;
    BOOLEAN Update;
    _Field_size_(Definitions) PLATFORM_IDLE_STATE State[ANYSIZE_ARRAY];
} PLATFORM_IDLE_STATES, *PPLATFORM_IDLE_STATES;

typedef struct _COORDINATED_IDLE_DEPENDENCY {
    ULONG ProcessorIndex;
    ULONG OptionCount;
    _Field_size_(OptionCount) struct _PEP_COORDINATED_DEPENDENCY_OPTION *Options;
} COORDINATED_IDLE_DEPENDENCY, *PCOORDINATED_IDLE_DEPENDENCY;

typedef struct _COORDINATED_IDLE_STATE {
    KAFFINITY_EX Processors;
    UNICODE_STRING Name;
    ULONG Latency;
    ULONG BreakEvenTime;
    ULONG MaximumDependencyOptions;
    ULONG DependencyCount;
    BOOLEAN Platform;
    BOOLEAN WakesSpuriously;
    BOOLEAN Interruptible;
    _Field_size_(DependencyCount) PCOORDINATED_IDLE_DEPENDENCY Dependencies;
} COORDINATED_IDLE_STATE, *PCOORDINATED_IDLE_STATE;

typedef struct _COORDINATED_IDLE_STATES {
    ULONG Count;
    PPROCESSOR_IDLE_TEST IdleTest;
    PPROCESSOR_IDLE_EXECUTE IdlePreExecute;
    PPROCESSOR_IDLE_COMPLETE IdleComplete;
    PPROCESSOR_QUERY_PLATFORM_STATE_RESIDENCY QueryPlatformStateResidency;
    BOOLEAN Update;
    _Field_size_(Count) COORDINATED_IDLE_STATE State[ANYSIZE_ARRAY];
} COORDINATED_IDLE_STATES, *PCOORDINATED_IDLE_STATES;

typedef struct _PROCESSOR_IDLE_STATES_HV {
    ULONG Version;
    ULONG InitialApicId;
    PVOID IdleStateConfig;
} PROCESSOR_IDLE_STATES_HV, *PPROCESSOR_IDLE_STATES_HV;

typedef struct _PROCESSOR_PERF_STATES_HV {
    ULONG Version;
    ULONG InitialApicId;
    PVOID PerfStateConfig;
    PVOID ThrottleStateConfig;
    PVOID PccConfig;
} PROCESSOR_PERF_STATES_HV, *PPROCESSOR_PERF_STATES_HV;

typedef struct _PROCESSOR_PERF_CAP_HV {
    ULONG Version;
    ULONG InitialApicId;
    ULONG Ppc;
    ULONG Tpc;
    ULONG ThermalCap;
} PROCESSOR_PERF_CAP_HV, *PPROCESSOR_PERF_CAP_HV;

typedef struct _PROCESSOR_IDLE_DOMAIN {
    KAFFINITY_EX Members;
} PROCESSOR_IDLE_DOMAIN, *PPROCESSOR_IDLE_DOMAIN;

typedef struct _PROCESSOR_IDLE_DOMAINS {
    ULONG Version;
    ULONG Count;
    KAFFINITY_EX TargetProcessors;
    _Field_size_(Count) PROCESSOR_IDLE_DOMAIN State[ANYSIZE_ARRAY];
} PROCESSOR_IDLE_DOMAINS, *PPROCESSOR_IDLE_DOMAINS;

typedef struct _PPM_FORCE_IDLE {
    ULONG CStateIndex;
    PROCESSOR_NUMBER ProcessorNumber;
} PPM_FORCE_IDLE, *PPPM_FORCE_IDLE;

typedef struct _PROCESSOR_PERF_INFO {
    PROCESSOR_NUMBER Number;
    ULONG_PTR PerfContext;
    ULONG PlatformCap;
    ULONG ThermalCap;
    ULONG LimitReasons;
} PROCESSOR_PERF_INFO, *PPROCESSOR_PERF_INFO;

typedef struct _PROCESSOR_PERF_STATES {
    ULONG Version;
    USHORT Type;
    BOOLEAN HardPlatformCap;
    BOOLEAN AffinitizeControl;
    BOOLEAN EfficientThrottle;
    ULONG ProcessorCount;
    ULONG NominalFrequency;
    ULONG MaxPerfPercent;
    ULONG MinPerfPercent;
    ULONG MinThrottlePercent;
    ULONG FeedbackCounterCount;
    ULONG MinimumPerfCheckPeriod;
    UCHAR AutonomousMode;
    ULONG64 MinimumRelativePerformance;
    ULONG64 NominalRelativePerformance;
    ULONG_PTR GlobalContext;
    KAFFINITY_EX TargetProcessors;
    PPROCESSOR_FETCH_MSR_ROUTINE GetFFHThrottleState;
    PPROCESSOR_POLICY_HANDLER TimeWindowHandler;
    PPROCESSOR_POLICY_HANDLER BoostPolicyHandler;
    PPROCESSOR_POLICY_HANDLER BoostModeHandler;
    PPROCESSOR_POLICY_HANDLER EnergyPerfPreferenceHandler;
    PPROCESSOR_POLICY_HANDLER AutonomousActivityWindowHandler;
    PPROCESSOR_POLICY_HANDLER AutonomousModeHandler;
    PPROCESSOR_POLICY_ACTION StartPolicyUpdate;
    PPROCESSOR_POLICY_ACTION CompletePolicyUpdate;
    PPROCESSOR_PERF_REINITIALIZE_HANDLER ReinitializeHandler;
    PPROCESSOR_PERF_SELECTION_HANDLER PerfSelectionHandler;
    PPROCESSOR_PERF_CONTROL_HANDLER PerfControlHandler;
    PPROCESSOR_PERF_CONTROL_ACTION PerfControlReadFeedback;
    PPROCESSOR_PERF_CONTROL_ACTION PerfControlAcquirePerformance;
    PPROCESSOR_PERF_CONTROL_ACTION PerfControlCommitPerformance;
    PPROCESSOR_PARK_PREFERENCE_HANDLER ParkPreference;
    PPROCESSOR_PARK_MASK_HANDLER ParkMask;
    PPROCESSOR_PERF_CHECK_COMPLETE_HANDLER PerfCheckComplete;
    _Field_size_(FeedbackCounterCount)
        PPROCESSOR_FEEDBACK_COUNTER FeedbackCounters;
    _Field_size_(ProcessorCount) PPROCESSOR_PERF_INFO Processors;
    _Field_size_(ProcessorCount * FeedbackCounterCount)
        PULONG_PTR CounterContexts;
} PROCESSOR_PERF_STATES, *PPROCESSOR_PERF_STATES;

typedef struct _PROCESSOR_PERF_STATES_COUNTERS_HV {
    ULONG Version;
    PVOID HypervisorStates;
    PPROCESSOR_PERF_STATES KernelStates;
} PROCESSOR_PERF_STATES_COUNTERS_HV, *PPROCESSOR_PERF_STATES_COUNTERS_HV;

//
// Don't let the processor driver constrain the perf check to anything >50ms.
//
#define PROCESSOR_PERF_MINIMUM_PERIOD_LIMIT 500000

typedef struct _PROCESSOR_CAP {
    ULONG Version;
    PROCESSOR_NUMBER ProcessorNumber;
    ULONG PlatformCap;
    ULONG ThermalCap;
    ULONG LimitReasons;
} PROCESSOR_CAP, *PPROCESSOR_CAP;

typedef struct _PROCESSOR_IDLE_VETO {
    ULONG Version;
    PROCESSOR_NUMBER ProcessorNumber;
    ULONG StateIndex;
    ULONG VetoReason;
    BOOLEAN Increment;
} PROCESSOR_IDLE_VETO, *PPROCESSOR_IDLE_VETO;

typedef struct _PLATFORM_IDLE_VETO {
    ULONG Version;
    ULONG StateIndex;
    ULONG VetoReason;
    BOOLEAN Increment;
} PLATFORM_IDLE_VETO, *PPLATFORM_IDLE_VETO;

typedef struct _PREREGISTERED_VETO_LIST {
    ULONG VetoCount;
    UNICODE_STRING VetoNames[ANYSIZE_ARRAY];
} PREREGISTERED_VETO_LIST, *PPREREGISTERED_VETO_LIST;

typedef struct _PROCESSOR_LOAD {
    PROCESSOR_NUMBER ProcessorNumber;
    UCHAR BusyPercentage;
    UCHAR FrequencyPercentage;
} PROCESSOR_LOAD, *PPROCESSOR_LOAD;

typedef struct _PEP_IDLE_VETO_REQUEST {
    ULONG StateIndex;
    ULONG VetoReason;
    BOOLEAN Increment;
} PEP_IDLE_VETO_REQUEST, *PPEP_IDLE_VETO_REQUEST;

// {E1500736-3E7F-4eb8-9013-F454CD4EDF75}
DEFINE_GUID(GUID_PROCESSOR_IDLE_VETO,
0xe1500736, 0x3e7f, 0x4eb8, 0x90, 0x13, 0xf4, 0x54, 0xcd, 0x4e, 0xdf, 0x75);

// {D3DC1B9D-F2D0-4d18-B6EF-5F2C06C0A2E0}
DEFINE_GUID(GUID_PLATFORM_IDLE_VETO,
0xd3dc1b9d, 0xf2d0, 0x4d18, 0xb6, 0xef, 0x5f, 0x2c, 0x6, 0xc0, 0xa2, 0xe0);

typedef struct _PEP_IDLE_UPDATE_REQUEST {
    ULONG StateIndex;
    ULONG Latency;
    ULONG BreakEvenDuration;
} PEP_IDLE_UPDATE_REQUEST, *PPEP_IDLE_UPDATE_REQUEST;

// {00A19FE5-1DD6-494f-9D46-4F04E0295F67}
DEFINE_GUID(GUID_PROCESSOR_IDLE_UPDATE,
0xa19fe5, 0x1dd6, 0x494f, 0x9d, 0x46, 0x4f, 0x4, 0xe0, 0x29, 0x5f, 0x67);

// {1BC4B44F-06FA-4f2e-B78D-8A440924F0EE}
DEFINE_GUID(GUID_PLATFORM_IDLE_UPDATE,
0x1bc4b44f, 0x6fa, 0x4f2e, 0xb7, 0x8d, 0x8a, 0x44, 0x9, 0x24, 0xf0, 0xee);

//
// This table is the direct-call dispatch table for processor drivers to
// communicate with the processor power manager.
//

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_PERF_STATES (
    _In_ PPROCESSOR_PERF_STATES PerfStates
    );

typedef PPM_DISPATCH_REGISTER_PERF_STATES *PPPM_DISPATCH_REGISTER_PERF_STATES;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_PERF_CAP (
    _In_ PPROCESSOR_CAP PerfCap
    );

typedef PPM_DISPATCH_REGISTER_PERF_CAP *PPPM_DISPATCH_REGISTER_PERF_CAP;

typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
PPM_DISPATCH_REGISTER_SPM_SETTINGS (
    _In_opt_ HANDLE ExternalRootKey
    );

typedef PPM_DISPATCH_REGISTER_SPM_SETTINGS *PPPM_DISPATCH_REGISTER_SPM_SETTINGS;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_IDLE_STATES (
    _In_ PPROCESSOR_IDLE_STATES_EX IdleStates
    );

typedef PPM_DISPATCH_REGISTER_IDLE_STATES *PPPM_DISPATCH_REGISTER_IDLE_STATES;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_IDLE_DOMAINS (
    _In_ CONST PROCESSOR_IDLE_DOMAINS *IdleDomains
    );

typedef PPM_DISPATCH_REGISTER_IDLE_DOMAINS *PPPM_DISPATCH_REGISTER_IDLE_DOMAINS;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_PLATFORM_STATES (
    _In_ PPLATFORM_IDLE_STATES PlatformIdleStates
    );

typedef PPM_DISPATCH_REGISTER_PLATFORM_STATES
    *PPPM_DISPATCH_REGISTER_PLATFORM_STATES;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_COORDINATED_STATES (
    _In_ PCOORDINATED_IDLE_STATES CoordinatedIdleStates
    );

typedef PPM_DISPATCH_REGISTER_COORDINATED_STATES
    *PPPM_DISPATCH_REGISTER_COORDINATED_STATES;

typedef
NTSTATUS
PPM_DISPATCH_UPDATE_PROCESSOR_IDLE_VETO (
    _In_ PPROCESSOR_IDLE_VETO IdleVeto
    );

typedef PPM_DISPATCH_UPDATE_PROCESSOR_IDLE_VETO
    *PPPM_DISPATCH_UPDATE_PROCESSOR_IDLE_VETO;

typedef
NTSTATUS
PPM_DISPATCH_UPDATE_PLATFORM_IDLE_VETO (
    _In_ PPLATFORM_IDLE_VETO IdleVeto
    );

typedef PPM_DISPATCH_UPDATE_PLATFORM_IDLE_VETO
    *PPPM_DISPATCH_UPDATE_PLATFORM_IDLE_VETO;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_VETO_LIST (
    _In_ PPREREGISTERED_VETO_LIST VetoList
    );

typedef PPM_DISPATCH_REGISTER_VETO_LIST *PPPM_DISPATCH_REGISTER_VETO_LIST;

typedef
NTSTATUS
PPM_DISPATCH_REMOVE_VETO_BIAS (
    VOID
    );

typedef PPM_DISPATCH_REMOVE_VETO_BIAS *PPPM_DISPATCH_REMOVE_VETO_BIAS;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_PERF_STATES_HV (
    _In_ CONST PROCESSOR_PERF_STATES_HV *PerfStates
    );

typedef PPM_DISPATCH_REGISTER_PERF_STATES_HV
    *PPPM_DISPATCH_REGISTER_PERF_STATES_HV;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_PERF_CAP_HV (
    _In_ CONST PROCESSOR_PERF_CAP_HV *PerfCap
    );

typedef PPM_DISPATCH_REGISTER_PERF_CAP_HV *PPPM_DISPATCH_REGISTER_PERF_CAP_HV;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_PERF_STATES_COUNTERS_HV (
    _In_ CONST PROCESSOR_PERF_STATES_COUNTERS_HV *PerfStateCounters
    );

typedef PPM_DISPATCH_REGISTER_PERF_STATES_COUNTERS_HV
    *PPPM_DISPATCH_REGISTER_PERF_STATES_COUNTERS_HV;

typedef
NTSTATUS
PPM_DISPATCH_REGISTER_IDLE_STATES_HV (
    _In_ CONST PROCESSOR_IDLE_STATES_HV *IdleStates
    );

typedef PPM_DISPATCH_REGISTER_IDLE_STATES_HV
    *PPPM_DISPATCH_REGISTER_IDLE_STATES_HV;

//
// POHANDLE isn't declared yet, use PVOID as a handle here.
//

typedef
NTSTATUS
PPM_DISPATCH_SET_PROCESSOR_PEP (
    _In_ PVOID Handle
    );

typedef PPM_DISPATCH_SET_PROCESSOR_PEP
    *PPPM_DISPATCH_SET_PROCESSOR_PEP;

typedef
NTSTATUS
PPM_DISPATCH_PARK_PREFERENCE_NOTIFICATION (
    _In_ PVOID Handle,
    _Inout_ struct _PEP_PPM_PARK_SELECTION_V2 *ParkSelection
    );

typedef PPM_DISPATCH_PARK_PREFERENCE_NOTIFICATION
    *PPPM_DISPATCH_PARK_PREFERENCE_NOTIFICATION;

typedef
NTSTATUS
PPM_DISPATCH_PARK_MASK_NOTIFICATION (
    _In_ PVOID Handle,
    _Inout_ struct _PEP_PPM_PARK_MASK *ParkMask
    );

typedef PPM_DISPATCH_PARK_MASK_NOTIFICATION
    *PPPM_DISPATCH_PARK_MASK_NOTIFICATION;

typedef
NTSTATUS
PPM_DISPATCH_IDLE_SELECT_NOTIFICATION (
    _In_ PVOID Handle,
    _Inout_ struct _PEP_PPM_IDLE_SELECT *IdleSelect
    );

typedef PPM_DISPATCH_IDLE_SELECT_NOTIFICATION
    *PPPM_DISPATCH_IDLE_SELECT_NOTIFICATION;

typedef
NTSTATUS
PPM_DISPATCH_QUERY_PLATFORM_STATE_NOTIFICATION (
    _In_ PVOID Handle,
    _Inout_ struct _PEP_PPM_QUERY_PLATFORM_STATE *QueryPlatformState,
    _In_ BOOLEAN Update
    );

typedef PPM_DISPATCH_QUERY_PLATFORM_STATE_NOTIFICATION
    *PPPM_DISPATCH_QUERY_PLATFORM_STATE_NOTIFICATION;

typedef
NTSTATUS
PPM_DISPATCH_QUERY_COORDINATED_DEPENDENCY_NOTIFICATION (
    _In_ PVOID Handle,
    _Inout_ struct _PEP_PPM_QUERY_COORDINATED_DEPENDENCY *QueryDependency
    );

typedef PPM_DISPATCH_QUERY_COORDINATED_DEPENDENCY_NOTIFICATION
    *PPPM_DISPATCH_QUERY_COORDINATED_DEPENDENCY_NOTIFICATION;

typedef
VOID
PPM_DISPATCH_REGISTER_ENERGY_ESTIMATION (
    _In_ PPROCESSOR_COMPUTE_ENERGY_ROUTINE ComputeEnergy,
    _In_ PPROCESSOR_SNAP_ENERGYCOUNTERS_ROUTINE SnapEnergyCounters
    );

typedef PPM_DISPATCH_REGISTER_ENERGY_ESTIMATION
    *PPPM_DISPATCH_REGISTER_ENERGY_ESTIMATION;

typedef struct _PPM_DRIVER_DISPATCH_TABLE {
    ULONG InterfaceVersion;
    PPPM_DISPATCH_REGISTER_PERF_STATES RegisterPerfStates;
    PPPM_DISPATCH_REGISTER_PERF_CAP RegisterPerfCap;
    PPPM_DISPATCH_REGISTER_SPM_SETTINGS RegisterSpmSettings;
    PPPM_DISPATCH_REGISTER_IDLE_STATES RegisterIdleStates;
    PPPM_DISPATCH_REGISTER_IDLE_DOMAINS RegisterIdleDomains;
    PPPM_DISPATCH_REGISTER_PLATFORM_STATES RegisterPlatformStates;
    PPPM_DISPATCH_REGISTER_COORDINATED_STATES RegisterCoordinatedStates;
    PPPM_DISPATCH_REGISTER_VETO_LIST RegisterVetoList;
    PPPM_DISPATCH_REMOVE_VETO_BIAS RemoveVetoBias;
    PPPM_DISPATCH_UPDATE_PROCESSOR_IDLE_VETO UpdateProcessorIdleVeto;
    PPPM_DISPATCH_UPDATE_PLATFORM_IDLE_VETO UpdatePlatformIdleVeto;
    PPPM_DISPATCH_REGISTER_PERF_STATES_HV RegisterPerfStatesHv;
    PPPM_DISPATCH_REGISTER_PERF_CAP_HV RegisterPerfCapHv;
    PPPM_DISPATCH_REGISTER_IDLE_STATES_HV RegisterIdleStatesHv;
    PPPM_DISPATCH_REGISTER_PERF_STATES_COUNTERS_HV RegisterPerfStatesCountersHv;
    PPPM_DISPATCH_SET_PROCESSOR_PEP SetProcessorPep;
    PPPM_DISPATCH_PARK_PREFERENCE_NOTIFICATION ParkPreferenceNotification;
    PPPM_DISPATCH_PARK_MASK_NOTIFICATION ParkMaskNotification;
    PPPM_DISPATCH_IDLE_SELECT_NOTIFICATION IdleSelectNotification;
    PPPM_DISPATCH_QUERY_PLATFORM_STATE_NOTIFICATION QueryPlatformStateNotification;
    PPPM_DISPATCH_QUERY_COORDINATED_DEPENDENCY_NOTIFICATION QueryCoordinatedDependencyNotification;
    PPPM_DISPATCH_REGISTER_ENERGY_ESTIMATION RegisterEnergyEstimation;
} PPM_DRIVER_DISPATCH_TABLE, *PPPM_DRIVER_DISPATCH_TABLE;


LOGICAL
DbgUnicodeStringToAnsiString (
    _Out_ PANSI_STRING AnsiFileName,
    _In_ PUNICODE_STRING UnicodeFileName
    );

VOID
DbgLoadUserImageSymbols (
    _In_ PSTRING FileName,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR ProcessId,
    _In_ ULONG CapturedSizeOfImage,
    _In_ ULONG CapturedCheckSum
    );

LOGICAL
DbgLoadImageSymbolsUnicode (
    _In_ PUNICODE_STRING UnicodeFileName,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR ProcessId
    );

LOGICAL
DbgUnLoadImageSymbolsUnicode (
    _In_opt_ PUNICODE_STRING UnicodeFileName,
    _In_ PVOID ImageBase,
    _In_ ULONG_PTR ProcessId
    );

//
// Definitions for live kernel mini-dump callback support.
//
typedef NTSTATUS (*PLKMD_SNAPDATA_ROUTINE) (
    _In_ PVOID CollectionContext,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length
    );

typedef BOOLEAN (*PLKMD_ISMEMORYBLOCKPRESENT_ROUTINE) (
    _In_ PVOID CollectionContext,
    _In_ PVOID Address,
    _In_opt_ ULONG Length
    );

typedef NTSTATUS (*PLKMD_CALLBACK_ROUTINE) (
    _In_ PLKMD_SNAPDATA_ROUTINE SnapDataRoutine,
    _In_ PLKMD_ISMEMORYBLOCKPRESENT_ROUTINE IsMemoryBlockPresentRoutine,
    _In_ PVOID CollectionContext,
    _In_opt_ PVOID CallbackContext,
    _In_ PVOID Object
    );

#define LKMD_PER_PROCESS    (0x00000001UL)
#define LKMD_PER_THREAD     (0x00000002UL)
#define LKMD_SAME_SESSION   (0x00000004UL)

NTSTATUS
DbgkLkmdRegisterCallback (
    _In_ PLKMD_CALLBACK_ROUTINE CallbackRoutine,
    _In_opt_ PVOID CallbackContext,
    _In_ ULONG Flags
    );

NTSTATUS
DbgkLkmdUnregisterCallback (
    _In_ PLKMD_CALLBACK_ROUTINE CallbackRoutine
    );

// begin_ntosifs

//
// Definitions for full live kernel dump and WER support
//

#pragma warning(push)
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int

typedef union DBGK_LIVEDUMP_FLAGS {
    struct {
        
        //
        // When set, capture user-mode process pages
        //

        ULONG  UserPages:1;
        ULONG  Reserved:31;
    };

    ULONG AsUlong;

}DBGK_LIVEDUMP_FLAGS, *PDBGK_LIVEDUMP_FLAGS; 

#pragma warning(pop)

//
// The function declaration provided to add secondary data to live kernel dump
//

typedef NTSTATUS (*PDBGK_LIVEDUMP_ADDSECONDARYDATA_ROUTINE) (

    // Report handle passed to the live dump callback routine
    _In_ HANDLE ReportHandle,

    // GUID to identify the secondary data
    _In_reads_bytes_(sizeof(GUID)) LPCGUID Identifier,   

    // Virtual address of data to add
    _In_reads_bytes_(Size) PVOID Data,

    // Size of data to add  
    _In_ ULONG Size
);

//
// Prototype of the callback function which will be called
// When a live dump is triggered
//

typedef NTSTATUS DBGK_LIVEDUMP_CALLBACK_ROUTINE(

    // An opaque handle to the WER report
    _In_ HANDLE ReportHandle,

    // Function pointer for a routine to add secondary data to the live dump
    _In_ PDBGK_LIVEDUMP_ADDSECONDARYDATA_ROUTINE AddSecondaryDataRoutine,

    // Bugcheck Code and Parameters
    _In_ ULONG BugCheckCode,
    _In_opt_ ULONG_PTR P1,  
    _In_opt_ ULONG_PTR P2,  
    _In_opt_ ULONG_PTR P3,  
    _In_opt_ ULONG_PTR P4,  

    // Caller supplied context
    _In_opt_ PVOID CallbackContext
    );
    
typedef DBGK_LIVEDUMP_CALLBACK_ROUTINE *PDBGK_LIVEDUMP_CALLBACK_ROUTINE;

//
// Defines the maximum component length name that can be passed
// to DbgkWerCaptureLiveKernelDump.
// 
// N.B. This definition must match WER_LIVE_KERNEL_REPORT_ID_LENGTH. 
//     There is a C_ASSERT in to verify this in ntos\dbgk\lkdmp\livekerneldump.c
//

#define DBGKWER_COMPONENT_NAME_LENGTH 16

_IRQL_requires_max_(PASSIVE_LEVEL)
NTKERNELAPI
NTSTATUS
DbgkWerCaptureLiveKernelDump (
    _In_ LPCWSTR ComponentName,
    _In_ ULONG BugCheckCode,
    _In_opt_ ULONG_PTR P1,
    _In_opt_ ULONG_PTR P2,
    _In_opt_ ULONG_PTR P3,
    _In_opt_ ULONG_PTR P4,
    _In_opt_ PVOID CallbackContext,
    _In_opt_ PDBGK_LIVEDUMP_CALLBACK_ROUTINE CallbackFunction,
    _In_opt_ DBGK_LIVEDUMP_FLAGS Flags
    );

#if !defined(XBOX_SYSTEMOS)

NTSTATUS
DbgkWerAddSecondaryData (
    _In_ HANDLE ReportHandle,
    _In_reads_bytes_(sizeof(GUID)) LPCGUID Identifier,  
    _In_reads_bytes_(Size) PVOID Data,
    _In_ ULONG Size
    );

#endif


#ifndef _OB_REFERENCE_TAGS_
#define _OB_REFERENCE_TAGS_

//
// Object Manager Public Reference Tags
//

#define REFTAG_AFDCONN 'CdfA'
#define REFTAG_AFDENDPOINT 'EdfA'
#define REFTAG_AFDPOLL 'PdfA'
#define REFTAG_ALEIO 'IelA'
#define REFTAG_ALEPROCTBL 'PelA'
#define REFTAG_ALESIDTOKEN 'SelA'
#define REFTAG_CFSFILTER 'FsfC'
#define REFTAG_DWMKERNEL 'KmwD'
#define REFTAG_HTTP 'pttH'
#define REFTAG_MAILSLOT 'sFsM'
#define REFTAG_NFSVOLUME 'VsfN'
#define REFTAG_PGMFILE 'TmgP'
#define REFTAG_PSLOOKUP 'ULsP'
#define REFTAG_PSWAKE 'kWsP'
#define REFTAG_RAWENDPOINT 'EwaR'
#define REFTAG_TCPENDPOINT 'EpcT'
#define REFTAG_TCPLISTENER 'LpcT'
#define REFTAG_TCPTCB 'TpcT'
#define REFTAG_UDPENDPOINT 'EpdU'
#define REFTAG_USRKDESKTOP 'DrsU'
#define REFTAG_VIDEO_PORT_I386 'idiV'
#define REFTAG_VIDEO_PORT 'PdiV'
#define REFTAG_WIN32K 'k23W'
#define REFTAG_WIN32KQUEUE 'q23W'
#define REFTAG_WIN32KRESTRICT 'r23W'
#define REFTAG_WIN32KSERVER 'S23W'
#define REFTAG_WIN32KSTUBS 's23W'
#define REFTAG_WS2IFSL 'i2sW'
#define REFTAG_WSKNAMERES 'NksW'
#define REFTAG_WSKPROV 'PksW'
#define REFTAG_WSKTDI 'TksW'

#endif // _OB_REFERENCE_TAGS_


//
// Define possible flags to be passed to ExInitializeDriverRuntime.  These
// flags define the behavior of the driver runtime opt-in package.
//

typedef enum _DRIVER_RUNTIME_INIT_FLAGS {
    //
    // The driver is built with POOL_NX_OPTIN and would like automatic
    // discovery of NonPagedPoolNx support.
    //
    // N.B.  To automatically gain the benefit of DrvRtPoolNxOptIn, the driver
    //       must also define POOL_NX_OPTIN.
    //

    DrvRtPoolNxOptIn             = 0x00000001,

    LastDrvRtFlag
} DRIVER_RUNTIME_INIT_FLAGS, * PDRIVER_RUNTIME_INIT_FLAGS;

typedef const enum _DRIVER_RUNTIME_INIT_FLAGS * PCDRIVER_RUNTIME_INIT_FLAGS;

FORCEINLINE
VOID
ExInitializeDriverRuntime(
    _In_ ULONG RuntimeFlags
    )

{

#if POOL_NX_OPTIN && !POOL_NX_OPTOUT
    ULONG MajorVersion;
    ULONG MinorVersion;
    NTSTATUS Status;
    RTL_OSVERSIONINFOW VersionInfo;

    VersionInfo.dwOSVersionInfoSize = sizeof (VersionInfo);

    Status = RtlGetVersion (&VersionInfo);

    if (!NT_VERIFY (NT_SUCCESS (Status))) {
        MajorVersion = 5;
        MinorVersion = 0;
    } else {
        MajorVersion = VersionInfo.dwMajorVersion;
        MinorVersion = VersionInfo.dwMinorVersion;
    }

    if ((RuntimeFlags & DrvRtPoolNxOptIn) != 0) {

        //
        // Discover whether NX pool support is available on this platform, and,
        // if so, initialize the default non-paged pool type.
        //

        if ((MajorVersion > 6) ||
            (MajorVersion == 6 &&
             MinorVersion >= 2)) {

            ExDefaultNonPagedPoolType = NonPagedPoolNx;
            ExDefaultMdlProtection = MdlMappingNoExecute;
        }
    }
#else
    UNREFERENCED_PARAMETER (RuntimeFlags);
#endif
}


extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *IoDriverObjectType;
extern POBJECT_TYPE *PsProcessType;
extern POBJECT_TYPE *PsThreadType;
extern POBJECT_TYPE *PsJobType;
extern POBJECT_TYPE *LpcPortObjectType;
extern POBJECT_TYPE *LpcWaitablePortObjectType;
extern POBJECT_TYPE MmSectionObjectType;


#ifdef __cplusplus
}    // extern "C"
#endif

#if defined (_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4001) /* nonstandard extension : single line comment */
#pragma warning(default:4201) /* nonstandard extension used : nameless struct/union */
#pragma warning(default:4214) /* nonstandard extension used : bit field types other then int */
#pragma warning(default:4115) /* named type definition in parentheses */
#endif
#endif

#endif // _NTOSP_
